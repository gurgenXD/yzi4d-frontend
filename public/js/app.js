(() => { var e = { 957: function (e) { var t; t = function () { "use strict"; function e(e, t) { var i = Object.keys(e); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); t && (s = s.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), i.push.apply(i, s) } return i } function t(t) { for (var i = 1; i < arguments.length; i++) { var n = null != arguments[i] ? arguments[i] : {}; i % 2 ? e(Object(n), !0).forEach((function (e) { s(t, e, n[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : e(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)) })) } return t } function i(e) { return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, i(e) } function s(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } function n(e) { return function (e) { if (Array.isArray(e)) return a(e) }(e) || function (e) { if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e) }(e) || o(e) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function o(e, t) { if (e) { if ("string" == typeof e) return a(e, t); var i = Object.prototype.toString.call(e).slice(8, -1); return "Object" === i && e.constructor && (i = e.constructor.name), "Map" === i || "Set" === i ? Array.from(e) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? a(e, t) : void 0 } } function a(e, t) { (null == t || t > e.length) && (t = e.length); for (var i = 0, s = new Array(t); i < t; i++)s[i] = e[i]; return s } var r = function (e) { return "string" == typeof e ? document.querySelector(e) : e() }, l = function (e, t) { var i = "string" == typeof e ? document.createElement(e) : e; for (var s in t) { var n = t[s]; if ("inside" === s) n.append(i); else if ("dest" === s) r(n[0]).insertAdjacentElement(n[1], i); else if ("around" === s) { var o = n; o.parentNode.insertBefore(i, o), i.append(o), null != o.getAttribute("autofocus") && o.focus() } else s in i ? i[s] = n : i.setAttribute(s, n) } return i }, c = function (e, t) { return e = String(e).toLowerCase(), t ? e.normalize("NFD").replace(/[\u0300-\u036f]/g, "").normalize("NFC") : e }, u = function (e, i) { return l("mark", t({ innerHTML: e }, "string" == typeof i && { class: i })).outerHTML }, d = function (e, t) { t.input.dispatchEvent(new CustomEvent(e, { bubbles: !0, detail: t.feedback, cancelable: !0 })) }, h = function (e, t, i) { var s = i || {}, n = s.mode, o = s.diacritics, a = s.highlight, r = c(t, o); if (t = String(t), e = c(e, o), "loose" === n) { var l = (e = e.replace(/ /g, "")).length, d = 0, h = Array.from(t).map((function (t, i) { return d < l && r[i] === e[d] && (t = a ? u(t, a) : t, d++), t })).join(""); if (d === l) return h } else { var p = r.indexOf(e); if (~p) return e = t.substring(p, p + e.length), a ? t.replace(e, u(e, a)) : t } }, p = function (e, t) { return new Promise((function (i, s) { var n; return (n = e.data).cache && n.store ? i() : new Promise((function (e, i) { return "function" == typeof n.src ? n.src(t).then(e, i) : e(n.src) })).then((function (t) { try { return e.feedback = n.store = t, d("response", e), i() } catch (e) { return s(e) } }), s) })) }, f = function (e, t) { var i = t.data, s = t.searchEngine, n = []; i.store.forEach((function (a, r) { var l = function (i) { var o = i ? a[i] : a, r = "function" == typeof s ? s(e, o) : h(e, o, { mode: s, diacritics: t.diacritics, highlight: t.resultItem.highlight }); if (r) { var l = { match: r, value: a }; i && (l.key = i), n.push(l) } }; if (i.keys) { var c, u = function (e, t) { var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"]; if (!i) { if (Array.isArray(e) || (i = o(e))) { i && (e = i); var s = 0, n = function () { }; return { s: n, n: function () { return s >= e.length ? { done: !0 } : { done: !1, value: e[s++] } }, e: function (e) { throw e }, f: n } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var a, r = !0, l = !1; return { s: function () { i = i.call(e) }, n: function () { var e = i.next(); return r = e.done, e }, e: function (e) { l = !0, a = e }, f: function () { try { r || null == i.return || i.return() } finally { if (l) throw a } } } }(i.keys); try { for (u.s(); !(c = u.n()).done;)l(c.value) } catch (e) { u.e(e) } finally { u.f() } } else l() })), i.filter && (n = i.filter(n)); var a = n.slice(0, t.resultsList.maxResults); t.feedback = { query: e, matches: n, results: a }, d("results", t) }, m = "aria-expanded", g = "aria-activedescendant", v = "aria-selected", b = function (e, i) { e.feedback.selection = t({ index: i }, e.feedback.results[i]) }, y = function (e) { e.isOpen || ((e.wrapper || e.input).setAttribute(m, !0), e.list.removeAttribute("hidden"), e.isOpen = !0, d("open", e)) }, w = function (e) { e.isOpen && ((e.wrapper || e.input).setAttribute(m, !1), e.input.setAttribute(g, ""), e.list.setAttribute("hidden", ""), e.isOpen = !1, d("close", e)) }, E = function (e, t) { var i = t.resultItem, s = t.list.getElementsByTagName(i.tag), o = !!i.selected && i.selected.split(" "); if (t.isOpen && s.length) { var a, r, l = t.cursor; e >= s.length && (e = 0), e < 0 && (e = s.length - 1), t.cursor = e, l > -1 && (s[l].removeAttribute(v), o && (r = s[l].classList).remove.apply(r, n(o))), s[e].setAttribute(v, !0), o && (a = s[e].classList).add.apply(a, n(o)), t.input.setAttribute(g, s[t.cursor].id), t.list.scrollTop = s[e].offsetTop - t.list.clientHeight + s[e].clientHeight + 5, t.feedback.cursor = t.cursor, b(t, e), d("navigate", t) } }, S = function (e) { E(e.cursor + 1, e) }, C = function (e) { E(e.cursor - 1, e) }, x = function (e, t, i) { (i = i >= 0 ? i : e.cursor) < 0 || (e.feedback.event = t, b(e, i), d("selection", e), w(e)) }; function k(e, i) { var s = this; return new Promise((function (n, o) { var a, r; return a = i || ((r = e.input) instanceof HTMLInputElement || r instanceof HTMLTextAreaElement ? r.value : r.innerHTML), function (e, t, i) { return t ? t(e) : e.length >= i }(a = e.query ? e.query(a) : a, e.trigger, e.threshold) ? p(e, a).then((function (i) { try { return e.feedback instanceof Error ? n() : (f(a, e), e.resultsList && function (e) { var i = e.resultsList, s = e.list, n = e.resultItem, o = e.feedback, a = o.matches, r = o.results; if (e.cursor = -1, s.innerHTML = "", a.length || i.noResults) { var c = new DocumentFragment; r.forEach((function (e, i) { var s = l(n.tag, t({ id: "".concat(n.id, "_").concat(i), role: "option", innerHTML: e.match, inside: c }, n.class && { class: n.class })); n.element && n.element(s, e) })), s.append(c), i.element && i.element(s, o), y(e) } else w(e) }(e), c.call(s)) } catch (e) { return o(e) } }), o) : (w(e), c.call(s)); function c() { return n() } })) } var T = function (e, t) { for (var i in e) for (var s in e[i]) t(i, s) }, A = function (e) { var i, s, n, o = e.events, a = (i = function () { return k(e) }, s = e.debounce, function () { clearTimeout(n), n = setTimeout((function () { return i() }), s) }), r = e.events = t({ input: t({}, o && o.input) }, e.resultsList && { list: o ? t({}, o.list) : {} }), l = { input: { input: function () { a() }, keydown: function (t) { !function (e, t) { switch (e.keyCode) { case 40: case 38: e.preventDefault(), 40 === e.keyCode ? S(t) : C(t); break; case 13: t.submit || e.preventDefault(), t.cursor >= 0 && x(t, e); break; case 9: t.resultsList.tabSelect && t.cursor >= 0 && x(t, e); break; case 27: t.input.value = "", w(t) } }(t, e) }, blur: function () { w(e) } }, list: { mousedown: function (e) { e.preventDefault() }, click: function (t) { !function (e, t) { var i = t.resultItem.tag.toUpperCase(), s = Array.from(t.list.querySelectorAll(i)), n = e.target.closest(i); n && n.nodeName === i && x(t, e, s.indexOf(n)) }(t, e) } } }; T(l, (function (t, i) { (e.resultsList || "input" === i) && (r[t][i] || (r[t][i] = l[t][i])) })), T(r, (function (t, i) { e[t].addEventListener(i, r[t][i]) })) }; function M(e) { var i = this; return new Promise((function (s, n) { var o, a, r; if (o = e.placeHolder, r = { role: "combobox", "aria-owns": (a = e.resultsList).id, "aria-haspopup": !0, "aria-expanded": !1 }, l(e.input, t(t({ "aria-controls": a.id, "aria-autocomplete": "both" }, o && { placeholder: o }), !e.wrapper && t({}, r))), e.wrapper && (e.wrapper = l("div", t({ around: e.input, class: e.name + "_wrapper" }, r))), a && (e.list = l(a.tag, t({ dest: [a.destination, a.position], id: a.id, role: "listbox", hidden: "hidden" }, a.class && { class: a.class }))), A(e), e.data.cache) return p(e).then((function (e) { try { return c.call(i) } catch (e) { return n(e) } }), n); function c() { return d("init", e), s() } return c.call(i) })) } function P(e) { var t = e.prototype; t.init = function () { M(this) }, t.start = function (e) { k(this, e) }, t.unInit = function () { if (this.wrapper) { var e = this.wrapper.parentNode; e.insertBefore(this.input, this.wrapper), e.removeChild(this.wrapper) } var t; T((t = this).events, (function (e, i) { t[e].removeEventListener(i, t.events[e][i]) })) }, t.open = function () { y(this) }, t.close = function () { w(this) }, t.goTo = function (e) { E(e, this) }, t.next = function () { S(this) }, t.previous = function () { C(this) }, t.select = function (e) { x(this, null, e) }, t.search = function (e, t, i) { return h(e, t, i) } } return function e(t) { this.options = t, this.id = e.instances = (e.instances || 0) + 1, this.name = "autoComplete", this.wrapper = 1, this.threshold = 1, this.debounce = 0, this.resultsList = { position: "afterend", tag: "ul", maxResults: 5 }, this.resultItem = { tag: "li" }, function (e) { var t = e.name, s = e.options, n = e.resultsList, o = e.resultItem; for (var a in s) if ("object" === i(s[a])) for (var l in e[a] || (e[a] = {}), s[a]) e[a][l] = s[a][l]; else e[a] = s[a]; e.selector = e.selector || "#" + t, n.destination = n.destination || e.selector, n.id = n.id || t + "_list_" + e.id, o.id = o.id || t + "_result", e.input = r(e.selector) }(this), P.call(this, e), M(this) } }, e.exports = t() }, 298: e => { "use strict"; function t(e, t) { var i = Object.keys(e); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); t && (s = s.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), i.push.apply(i, s) } return i } function i(e) { for (var i, n = 1; n < arguments.length; n++)i = null == arguments[n] ? {} : arguments[n], n % 2 ? t(Object(i), !0).forEach((function (t) { s(e, t, i[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : t(Object(i)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t)) })); return e } function s(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } const n = { threshold: 50, passive: !1 }; e.exports = class { constructor(e, t = {}) { this.options = i(i({}, n), t), this.element = null, this.touchStartX = 0, this.touchStartY = 0, this.touchEndX = 0, this.touchEndY = 0, this.onSwipeLeftAgent = null, this.onSwipeRightAgent = null, this.onSwipeUpAgent = null, this.onSwipeDownAgent = null, this.onTapAgent = null, this.onTouchStart = this.onTouchStart.bind(this), this.onTouchEnd = this.onTouchEnd.bind(this), this.onSwipeLeft = this.onSwipeLeft.bind(this), this.onSwipeRight = this.onSwipeRight.bind(this), this.onSwipeUp = this.onSwipeUp.bind(this), this.onSwipeDown = this.onSwipeDown.bind(this), this.onTap = this.onTap.bind(this), this.destroy = this.destroy.bind(this), this.handleGesture = this.handleGesture.bind(this); let s = !!this.options.passive && { passive: !0 }; this.element = e instanceof EventTarget ? e : document.querySelector(e), this.element.addEventListener("touchstart", this.onTouchStart, s), this.element.addEventListener("touchend", this.onTouchEnd, s) } onTouchStart(e) { this.touchStartX = e.changedTouches[0].screenX, this.touchStartY = e.changedTouches[0].screenY } onTouchEnd(e) { this.touchEndX = e.changedTouches[0].screenX, this.touchEndY = e.changedTouches[0].screenY, this.handleGesture() } onSwipeLeft(e) { this.onSwipeLeftAgent = e } onSwipeRight(e) { this.onSwipeRightAgent = e } onSwipeUp(e) { this.onSwipeUpAgent = e } onSwipeDown(e) { this.onSwipeDownAgent = e } onTap(e) { this.onTapAgent = e } destroy() { this.element.removeEventListener("touchstart", this.onTouchStart), this.element.removeEventListener("touchend", this.onTouchEnd) } handleGesture() { return this.touchEndX + this.options.threshold <= this.touchStartX ? (this.onSwipeLeftAgent && this.onSwipeLeftAgent(), "swiped left") : this.touchEndX - this.options.threshold >= this.touchStartX ? (this.onSwipeRightAgent && this.onSwipeRightAgent(), "swiped right") : this.touchEndY + this.options.threshold <= this.touchStartY ? (this.onSwipeUpAgent && this.onSwipeUpAgent(), "swiped up") : this.touchEndY - this.options.threshold >= this.touchStartY ? (this.onSwipeDownAgent && this.onSwipeDownAgent(), "swiped down") : this.touchEndY === this.touchStartY ? (this.onTapAgent && this.onTapAgent(), "tap") : void 0 } } } }, t = {}; function i(s) { var n = t[s]; if (void 0 !== n) return n.exports; var o = t[s] = { exports: {} }; return e[s].call(o.exports, o, o.exports, i), o.exports } (() => { "use strict"; var e = i(298); function t(e) { return "string" == typeof e || e instanceof String } function s(e) { var t; return "object" == typeof e && null != e && "Object" === (null == e || null == (t = e.constructor) ? void 0 : t.name) } function n(e, t) { return Array.isArray(t) ? n(e, ((e, i) => t.includes(i))) : Object.entries(e).reduce(((e, i) => { let [s, n] = i; return t(n, s) && (e[s] = n), e }), {}) } const o = "NONE", a = "LEFT", r = "FORCE_LEFT", l = "RIGHT", c = "FORCE_RIGHT"; function u(e) { return e.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1") } function d(e, t) { if (t === e) return !0; const i = Array.isArray(t), s = Array.isArray(e); let n; if (i && s) { if (t.length != e.length) return !1; for (n = 0; n < t.length; n++)if (!d(t[n], e[n])) return !1; return !0 } if (i != s) return !1; if (t && e && "object" == typeof t && "object" == typeof e) { const i = t instanceof Date, s = e instanceof Date; if (i && s) return t.getTime() == e.getTime(); if (i != s) return !1; const o = t instanceof RegExp, a = e instanceof RegExp; if (o && a) return t.toString() == e.toString(); if (o != a) return !1; const r = Object.keys(t); for (n = 0; n < r.length; n++)if (!Object.prototype.hasOwnProperty.call(e, r[n])) return !1; for (n = 0; n < r.length; n++)if (!d(e[r[n]], t[r[n]])) return !1; return !0 } return !(!t || !e || "function" != typeof t || "function" != typeof e) && t.toString() === e.toString() } class h { constructor(e) { for (Object.assign(this, e); this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos);)--this.oldSelection.start } get startChangePos() { return Math.min(this.cursorPos, this.oldSelection.start) } get insertedCount() { return this.cursorPos - this.startChangePos } get inserted() { return this.value.substr(this.startChangePos, this.insertedCount) } get removedCount() { return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0) } get removed() { return this.oldValue.substr(this.startChangePos, this.removedCount) } get head() { return this.value.substring(0, this.startChangePos) } get tail() { return this.value.substring(this.startChangePos + this.insertedCount) } get removeDirection() { return !this.removedCount || this.insertedCount ? o : this.oldSelection.end !== this.cursorPos && this.oldSelection.start !== this.cursorPos || this.oldSelection.end !== this.oldSelection.start ? a : l } } function p(e, t) { return new p.InputMask(e, t) } function f(e) { if (null == e) throw new Error("mask property should be defined"); return e instanceof RegExp ? p.MaskedRegExp : t(e) ? p.MaskedPattern : e === Date ? p.MaskedDate : e === Number ? p.MaskedNumber : Array.isArray(e) || e === Array ? p.MaskedDynamic : p.Masked && e.prototype instanceof p.Masked ? e : p.Masked && e instanceof p.Masked ? e.constructor : e instanceof Function ? p.MaskedFunction : (console.warn("Mask not found for mask", e), p.Masked) } function m(e) { if (!e) throw new Error("Options in not defined"); if (p.Masked) { if (e.prototype instanceof p.Masked) return { mask: e }; const { mask: t, ...i } = e instanceof p.Masked ? { mask: e } : s(e) && e.mask instanceof p.Masked ? e : {}; if (t) { const e = t.mask; return { ...n(t, ((e, t) => !t.startsWith("_"))), mask: t.constructor, _mask: e, ...i } } } return s(e) ? { ...e } : { mask: e } } function g(e) { if (p.Masked && e instanceof p.Masked) return e; const t = m(e), i = f(t.mask); if (!i) throw new Error("Masked class is not found for provided mask, appropriate module needs to be imported manually before creating mask."); return t.mask === i && delete t.mask, t._mask && (t.mask = t._mask, delete t._mask), new i(t) } p.createMask = g; class v { get selectionStart() { let e; try { e = this._unsafeSelectionStart } catch { } return null != e ? e : this.value.length } get selectionEnd() { let e; try { e = this._unsafeSelectionEnd } catch { } return null != e ? e : this.value.length } select(e, t) { if (null != e && null != t && (e !== this.selectionStart || t !== this.selectionEnd)) try { this._unsafeSelect(e, t) } catch { } } get isActive() { return !1 } } p.MaskElement = v; class b extends v { constructor(e) { super(), this.input = e, this._handlers = {} } get rootElement() { var e, t, i; return null != (e = null == (t = (i = this.input).getRootNode) ? void 0 : t.call(i)) ? e : document } get isActive() { return this.input === this.rootElement.activeElement } bindEvents(e) { Object.keys(e).forEach((t => this._toggleEventHandler(b.EVENTS_MAP[t], e[t]))) } unbindEvents() { Object.keys(this._handlers).forEach((e => this._toggleEventHandler(e))) } _toggleEventHandler(e, t) { this._handlers[e] && (this.input.removeEventListener(e, this._handlers[e]), delete this._handlers[e]), t && (this.input.addEventListener(e, t), this._handlers[e] = t) } } b.EVENTS_MAP = { selectionChange: "keydown", input: "input", drop: "drop", click: "click", focus: "focus", commit: "blur" }, p.HTMLMaskElement = b; class y extends b { constructor(e) { super(e), this.input = e, this._handlers = {} } get _unsafeSelectionStart() { return null != this.input.selectionStart ? this.input.selectionStart : this.value.length } get _unsafeSelectionEnd() { return this.input.selectionEnd } _unsafeSelect(e, t) { this.input.setSelectionRange(e, t) } get value() { return this.input.value } set value(e) { this.input.value = e } } p.HTMLMaskElement = b; class w extends b { get _unsafeSelectionStart() { const e = this.rootElement, t = e.getSelection && e.getSelection(), i = t && t.anchorOffset, s = t && t.focusOffset; return null == s || null == i || i < s ? i : s } get _unsafeSelectionEnd() { const e = this.rootElement, t = e.getSelection && e.getSelection(), i = t && t.anchorOffset, s = t && t.focusOffset; return null == s || null == i || i > s ? i : s } _unsafeSelect(e, t) { if (!this.rootElement.createRange) return; const i = this.rootElement.createRange(); i.setStart(this.input.firstChild || this.input, e), i.setEnd(this.input.lastChild || this.input, t); const s = this.rootElement, n = s.getSelection && s.getSelection(); n && (n.removeAllRanges(), n.addRange(i)) } get value() { return this.input.textContent || "" } set value(e) { this.input.textContent = e } } p.HTMLContenteditableMaskElement = w, p.InputMask = class { constructor(e, t) { this.el = e instanceof v ? e : e.isContentEditable && "INPUT" !== e.tagName && "TEXTAREA" !== e.tagName ? new w(e) : new y(e), this.masked = g(t), this._listeners = {}, this._value = "", this._unmaskedValue = "", this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange() } maskEquals(e) { var t; return null == e || (null == (t = this.masked) ? void 0 : t.maskEquals(e)) } get mask() { return this.masked.mask } set mask(e) { if (this.maskEquals(e)) return; if (!(e instanceof p.Masked) && this.masked.constructor === f(e)) return void this.masked.updateOptions({ mask: e }); const t = e instanceof p.Masked ? e : g({ mask: e }); t.unmaskedValue = this.masked.unmaskedValue, this.masked = t } get value() { return this._value } set value(e) { this.value !== e && (this.masked.value = e, this.updateControl(), this.alignCursor()) } get unmaskedValue() { return this._unmaskedValue } set unmaskedValue(e) { this.unmaskedValue !== e && (this.masked.unmaskedValue = e, this.updateControl(), this.alignCursor()) } get typedValue() { return this.masked.typedValue } set typedValue(e) { this.masked.typedValueEquals(e) || (this.masked.typedValue = e, this.updateControl(), this.alignCursor()) } get displayValue() { return this.masked.displayValue } _bindEvents() { this.el.bindEvents({ selectionChange: this._saveSelection, input: this._onInput, drop: this._onDrop, click: this._onClick, focus: this._onFocus, commit: this._onChange }) } _unbindEvents() { this.el && this.el.unbindEvents() } _fireEvent(e, t) { const i = this._listeners[e]; i && i.forEach((e => e(t))) } get selectionStart() { return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart } get cursorPos() { return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd } set cursorPos(e) { this.el && this.el.isActive && (this.el.select(e, e), this._saveSelection()) } _saveSelection() { this.displayValue !== this.el.value && console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."), this._selection = { start: this.selectionStart, end: this.cursorPos } } updateValue() { this.masked.value = this.el.value, this._value = this.masked.value } updateControl() { const e = this.masked.unmaskedValue, t = this.masked.value, i = this.displayValue, s = this.unmaskedValue !== e || this.value !== t; this._unmaskedValue = e, this._value = t, this.el.value !== i && (this.el.value = i), s && this._fireChangeEvents() } updateOptions(e) { const { mask: t, ...i } = e, s = !this.maskEquals(t), n = !d(this.masked, i); s && (this.mask = t), n && this.masked.updateOptions(i), (s || n) && this.updateControl() } updateCursor(e) { null != e && (this.cursorPos = e, this._delayUpdateCursor(e)) } _delayUpdateCursor(e) { this._abortUpdateCursor(), this._changingCursorPos = e, this._cursorChanging = setTimeout((() => { this.el && (this.cursorPos = this._changingCursorPos, this._abortUpdateCursor()) }), 10) } _fireChangeEvents() { this._fireEvent("accept", this._inputEvent), this.masked.isComplete && this._fireEvent("complete", this._inputEvent) } _abortUpdateCursor() { this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging) } alignCursor() { this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, a)) } alignCursorFriendly() { this.selectionStart === this.cursorPos && this.alignCursor() } on(e, t) { return this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t), this } off(e, t) { if (!this._listeners[e]) return this; if (!t) return delete this._listeners[e], this; const i = this._listeners[e].indexOf(t); return i >= 0 && this._listeners[e].splice(i, 1), this } _onInput(e) { if (this._inputEvent = e, this._abortUpdateCursor(), !this._selection) return this.updateValue(); const t = new h({ value: this.el.value, cursorPos: this.cursorPos, oldValue: this.displayValue, oldSelection: this._selection }), i = this.masked.rawInputValue, s = this.masked.splice(t.startChangePos, t.removed.length, t.inserted, t.removeDirection, { input: !0, raw: !0 }).offset, n = i === this.masked.rawInputValue ? t.removeDirection : o; let a = this.masked.nearestInputPos(t.startChangePos + s, n); n !== o && (a = this.masked.nearestInputPos(a, o)), this.updateControl(), this.updateCursor(a), delete this._inputEvent } _onChange() { this.displayValue !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection() } _onDrop(e) { e.preventDefault(), e.stopPropagation() } _onFocus(e) { this.alignCursorFriendly() } _onClick(e) { this.alignCursorFriendly() } destroy() { this._unbindEvents(), this._listeners.length = 0, delete this.el } }; class E { static normalize(e) { return Array.isArray(e) ? e : [e, new E] } constructor(e) { Object.assign(this, { inserted: "", rawInserted: "", skip: !1, tailShift: 0 }, e) } aggregate(e) { return this.rawInserted += e.rawInserted, this.skip = this.skip || e.skip, this.inserted += e.inserted, this.tailShift += e.tailShift, this } get offset() { return this.tailShift + this.inserted.length } } p.ChangeDetails = E; class S { constructor(e, t, i) { void 0 === e && (e = ""), void 0 === t && (t = 0), this.value = e, this.from = t, this.stop = i } toString() { return this.value } extend(e) { this.value += String(e) } appendTo(e) { return e.append(this.toString(), { tail: !0 }).aggregate(e._appendPlaceholder()) } get state() { return { value: this.value, from: this.from, stop: this.stop } } set state(e) { Object.assign(this, e) } unshift(e) { if (!this.value.length || null != e && this.from >= e) return ""; const t = this.value[0]; return this.value = this.value.slice(1), t } shift() { if (!this.value.length) return ""; const e = this.value[this.value.length - 1]; return this.value = this.value.slice(0, -1), e } } class C { constructor(e) { this._value = "", this._update({ ...C.DEFAULTS, ...e }), this._initialized = !0 } updateOptions(e) { Object.keys(e).length && this.withValueRefresh(this._update.bind(this, e)) } _update(e) { Object.assign(this, e) } get state() { return { _value: this.value, _rawInputValue: this.rawInputValue } } set state(e) { this._value = e._value } reset() { this._value = "" } get value() { return this._value } set value(e) { this.resolve(e, { input: !0 }) } resolve(e, t) { void 0 === t && (t = { input: !0 }), this.reset(), this.append(e, t, ""), this.doCommit() } get unmaskedValue() { return this.value } set unmaskedValue(e) { this.resolve(e, {}) } get typedValue() { return this.parse ? this.parse(this.value, this) : this.unmaskedValue } set typedValue(e) { this.format ? this.value = this.format(e, this) : this.unmaskedValue = String(e) } get rawInputValue() { return this.extractInput(0, this.displayValue.length, { raw: !0 }) } set rawInputValue(e) { this.resolve(e, { raw: !0 }) } get displayValue() { return this.value } get isComplete() { return !0 } get isFilled() { return this.isComplete } nearestInputPos(e, t) { return e } totalInputPositions(e, t) { return void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length), Math.min(this.displayValue.length, t - e) } extractInput(e, t, i) { return void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length), this.displayValue.slice(e, t) } extractTail(e, t) { return void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length), new S(this.extractInput(e, t), e) } appendTail(e) { return t(e) && (e = new S(String(e))), e.appendTo(this) } _appendCharRaw(e, t) { return e ? (this._value += e, new E({ inserted: e, rawInserted: e })) : new E } _appendChar(e, t, i) { void 0 === t && (t = {}); const s = this.state; let n; if ([e, n] = this.doPrepareChar(e, t), n = n.aggregate(this._appendCharRaw(e, t)), n.inserted) { let e, o = !1 !== this.doValidate(t); if (o && null != i) { const t = this.state; !0 === this.overwrite && (e = i.state, i.unshift(this.displayValue.length - n.tailShift)); let s = this.appendTail(i); o = s.rawInserted === i.toString(), o && s.inserted || "shift" !== this.overwrite || (this.state = t, e = i.state, i.shift(), s = this.appendTail(i), o = s.rawInserted === i.toString()), o && s.inserted && (this.state = t) } o || (n = new E, this.state = s, i && e && (i.state = e)) } return n } _appendPlaceholder() { return new E } _appendEager() { return new E } append(e, i, s) { if (!t(e)) throw new Error("value should be string"); const n = t(s) ? new S(String(s)) : s; let o; null != i && i.tail && (i._beforeTailState = this.state), [e, o] = this.doPrepare(e, i); for (let t = 0; t < e.length; ++t) { const s = this._appendChar(e[t], i, n); if (!s.rawInserted && !this.doSkipInvalid(e[t], i, n)) break; o.aggregate(s) } return (!0 === this.eager || "append" === this.eager) && null != i && i.input && e && o.aggregate(this._appendEager()), null != n && (o.tailShift += this.appendTail(n).tailShift), o } remove(e, t) { return void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length), this._value = this.displayValue.slice(0, e) + this.displayValue.slice(t), new E } withValueRefresh(e) { if (this._refreshing || !this._initialized) return e(); this._refreshing = !0; const t = this.rawInputValue, i = this.value, s = e(); return this.rawInputValue = t, this.value && this.value !== i && 0 === i.indexOf(this.value) && this.append(i.slice(this.displayValue.length), {}, ""), delete this._refreshing, s } runIsolated(e) { if (this._isolated || !this._initialized) return e(this); this._isolated = !0; const t = this.state, i = e(this); return this.state = t, delete this._isolated, i } doSkipInvalid(e, t, i) { return Boolean(this.skipInvalid) } doPrepare(e, t) { return void 0 === t && (t = {}), E.normalize(this.prepare ? this.prepare(e, this, t) : e) } doPrepareChar(e, t) { return void 0 === t && (t = {}), E.normalize(this.prepareChar ? this.prepareChar(e, this, t) : e) } doValidate(e) { return (!this.validate || this.validate(this.value, this, e)) && (!this.parent || this.parent.doValidate(e)) } doCommit() { this.commit && this.commit(this.value, this) } splice(e, t, i, s, n) { void 0 === s && (s = o), void 0 === n && (n = { input: !0 }); const u = e + t, d = this.extractTail(u), h = !0 === this.eager || "remove" === this.eager; let p; h && (s = function (e) { switch (e) { case a: return r; case l: return c; default: return e } }(s), p = this.extractInput(0, u, { raw: !0 })); let f = e; const m = new E; if (s !== o && (f = this.nearestInputPos(e, t > 1 && 0 !== e && !h ? o : s), m.tailShift = f - e), m.aggregate(this.remove(f)), h && s !== o && p === this.rawInputValue) if (s === r) { let e; for (; p === this.rawInputValue && (e = this.displayValue.length);)m.aggregate(new E({ tailShift: -1 })).aggregate(this.remove(e - 1)) } else s === c && d.unshift(); return m.aggregate(this.append(i, n, d)) } maskEquals(e) { return this.mask === e } typedValueEquals(e) { const t = this.typedValue; return e === t || C.EMPTY_VALUES.includes(e) && C.EMPTY_VALUES.includes(t) || !!this.format && this.format(e, this) === this.format(this.typedValue, this) } } C.DEFAULTS = { skipInvalid: !0 }, C.EMPTY_VALUES = [void 0, null, ""], p.Masked = C; class x { constructor(e, t) { void 0 === e && (e = []), void 0 === t && (t = 0), this.chunks = e, this.from = t } toString() { return this.chunks.map(String).join("") } extend(e) { if (!String(e)) return; e = t(e) ? new S(String(e)) : e; const i = this.chunks[this.chunks.length - 1], s = i && (i.stop === e.stop || null == e.stop) && e.from === i.from + i.toString().length; if (e instanceof S) s ? i.extend(e.toString()) : this.chunks.push(e); else if (e instanceof x) { if (null == e.stop) { let t; for (; e.chunks.length && null == e.chunks[0].stop;)t = e.chunks.shift(), t.from += e.from, this.extend(t) } e.toString() && (e.stop = e.blockIndex, this.chunks.push(e)) } } appendTo(e) { if (!(e instanceof p.MaskedPattern)) return new S(this.toString()).appendTo(e); const t = new E; for (let i = 0; i < this.chunks.length && !t.skip; ++i) { const s = this.chunks[i], n = e._mapPosToBlock(e.displayValue.length), o = s.stop; let a; if (null != o && (!n || n.index <= o)) { if (s instanceof x || e._stops.indexOf(o) >= 0) { const i = e._appendPlaceholder(o); t.aggregate(i) } a = s instanceof x && e._blocks[o] } if (a) { const i = a.appendTail(s); i.skip = !1, t.aggregate(i), e._value += i.inserted; const n = s.toString().slice(i.rawInserted.length); n && t.aggregate(e.append(n, { tail: !0 })) } else t.aggregate(e.append(s.toString(), { tail: !0 })) } return t } get state() { return { chunks: this.chunks.map((e => e.state)), from: this.from, stop: this.stop, blockIndex: this.blockIndex } } set state(e) { const { chunks: t, ...i } = e; Object.assign(this, i), this.chunks = t.map((e => { const t = "chunks" in e ? new x : new S; return t.state = e, t })) } unshift(e) { if (!this.chunks.length || null != e && this.from >= e) return ""; const t = null != e ? e - this.from : e; let i = 0; for (; i < this.chunks.length;) { const e = this.chunks[i], s = e.unshift(t); if (e.toString()) { if (!s) break; ++i } else this.chunks.splice(i, 1); if (s) return s } return "" } shift() { if (!this.chunks.length) return ""; let e = this.chunks.length - 1; for (; 0 <= e;) { const t = this.chunks[e], i = t.shift(); if (t.toString()) { if (!i) break; --e } else this.chunks.splice(e, 1); if (i) return i } return "" } } class k { constructor(e, t) { this.masked = e, this._log = []; const { offset: i, index: s } = e._mapPosToBlock(t) || (t < 0 ? { index: 0, offset: 0 } : { index: this.masked._blocks.length, offset: 0 }); this.offset = i, this.index = s, this.ok = !1 } get block() { return this.masked._blocks[this.index] } get pos() { return this.masked._blockStartPos(this.index) + this.offset } get state() { return { index: this.index, offset: this.offset, ok: this.ok } } set state(e) { Object.assign(this, e) } pushState() { this._log.push(this.state) } popState() { const e = this._log.pop(); return e && (this.state = e), e } bindBlock() { this.block || (this.index < 0 && (this.index = 0, this.offset = 0), this.index >= this.masked._blocks.length && (this.index = this.masked._blocks.length - 1, this.offset = this.block.displayValue.length)) } _pushLeft(e) { for (this.pushState(), this.bindBlock(); 0 <= this.index; --this.index, this.offset = (null == (t = this.block) ? void 0 : t.displayValue.length) || 0) { var t; if (e()) return this.ok = !0 } return this.ok = !1 } _pushRight(e) { for (this.pushState(), this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0)if (e()) return this.ok = !0; return this.ok = !1 } pushLeftBeforeFilled() { return this._pushLeft((() => { if (!this.block.isFixed && this.block.value) return this.offset = this.block.nearestInputPos(this.offset, r), 0 !== this.offset || void 0 })) } pushLeftBeforeInput() { return this._pushLeft((() => { if (!this.block.isFixed) return this.offset = this.block.nearestInputPos(this.offset, a), !0 })) } pushLeftBeforeRequired() { return this._pushLeft((() => { if (!(this.block.isFixed || this.block.isOptional && !this.block.value)) return this.offset = this.block.nearestInputPos(this.offset, a), !0 })) } pushRightBeforeFilled() { return this._pushRight((() => { if (!this.block.isFixed && this.block.value) return this.offset = this.block.nearestInputPos(this.offset, c), this.offset !== this.block.value.length || void 0 })) } pushRightBeforeInput() { return this._pushRight((() => { if (!this.block.isFixed) return this.offset = this.block.nearestInputPos(this.offset, o), !0 })) } pushRightBeforeRequired() { return this._pushRight((() => { if (!(this.block.isFixed || this.block.isOptional && !this.block.value)) return this.offset = this.block.nearestInputPos(this.offset, o), !0 })) } } class T { constructor(e) { Object.assign(this, e), this._value = "", this.isFixed = !0 } get value() { return this._value } get unmaskedValue() { return this.isUnmasking ? this.value : "" } get rawInputValue() { return this._isRawInput ? this.value : "" } get displayValue() { return this.value } reset() { this._isRawInput = !1, this._value = "" } remove(e, t) { return void 0 === e && (e = 0), void 0 === t && (t = this._value.length), this._value = this._value.slice(0, e) + this._value.slice(t), this._value || (this._isRawInput = !1), new E } nearestInputPos(e, t) { void 0 === t && (t = o); const i = this._value.length; switch (t) { case a: case r: return 0; default: return i } } totalInputPositions(e, t) { return void 0 === e && (e = 0), void 0 === t && (t = this._value.length), this._isRawInput ? t - e : 0 } extractInput(e, t, i) { return void 0 === e && (e = 0), void 0 === t && (t = this._value.length), void 0 === i && (i = {}), i.raw && this._isRawInput && this._value.slice(e, t) || "" } get isComplete() { return !0 } get isFilled() { return Boolean(this._value) } _appendChar(e, t) { void 0 === t && (t = {}); const i = new E; if (this.isFilled) return i; const s = !0 === this.eager || "append" === this.eager, n = this.char === e && (this.isUnmasking || t.input || t.raw) && (!t.raw || !s) && !t.tail; return n && (i.rawInserted = this.char), this._value = i.inserted = this.char, this._isRawInput = n && (t.raw || t.input), i } _appendEager() { return this._appendChar(this.char, { tail: !0 }) } _appendPlaceholder() { const e = new E; return this.isFilled || (this._value = e.inserted = this.char), e } extractTail() { return new S("") } appendTail(e) { return t(e) && (e = new S(String(e))), e.appendTo(this) } append(e, t, i) { const s = this._appendChar(e[0], t); return null != i && (s.tailShift += this.appendTail(i).tailShift), s } doCommit() { } get state() { return { _value: this._value, _rawInputValue: this.rawInputValue } } set state(e) { this._value = e._value, this._isRawInput = Boolean(e._rawInputValue) } } class A { constructor(e) { const { parent: t, isOptional: i, placeholderChar: s, displayChar: n, lazy: o, eager: a, ...r } = e; this.masked = g(r), Object.assign(this, { parent: t, isOptional: i, placeholderChar: s, displayChar: n, lazy: o, eager: a }) } reset() { this.isFilled = !1, this.masked.reset() } remove(e, t) { return void 0 === e && (e = 0), void 0 === t && (t = this.value.length), 0 === e && t >= 1 ? (this.isFilled = !1, this.masked.remove(e, t)) : new E } get value() { return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "") } get unmaskedValue() { return this.masked.unmaskedValue } get rawInputValue() { return this.masked.rawInputValue } get displayValue() { return this.masked.value && this.displayChar || this.value } get isComplete() { return Boolean(this.masked.value) || this.isOptional } _appendChar(e, t) { if (void 0 === t && (t = {}), this.isFilled) return new E; const i = this.masked.state, s = this.masked._appendChar(e, this.currentMaskFlags(t)); return s.inserted && !1 === this.doValidate(t) && (s.inserted = s.rawInserted = "", this.masked.state = i), s.inserted || this.isOptional || this.lazy || t.input || (s.inserted = this.placeholderChar), s.skip = !s.inserted && !this.isOptional, this.isFilled = Boolean(s.inserted), s } append(e, t, i) { return this.masked.append(e, this.currentMaskFlags(t), i) } _appendPlaceholder() { const e = new E; return this.isFilled || this.isOptional || (this.isFilled = !0, e.inserted = this.placeholderChar), e } _appendEager() { return new E } extractTail(e, t) { return this.masked.extractTail(e, t) } appendTail(e) { return this.masked.appendTail(e) } extractInput(e, t, i) { return void 0 === e && (e = 0), void 0 === t && (t = this.value.length), this.masked.extractInput(e, t, i) } nearestInputPos(e, t) { void 0 === t && (t = o); const i = this.value.length, s = Math.min(Math.max(e, 0), i); switch (t) { case a: case r: return this.isComplete ? s : 0; case l: case c: return this.isComplete ? s : i; default: return s } } totalInputPositions(e, t) { return void 0 === e && (e = 0), void 0 === t && (t = this.value.length), this.value.slice(e, t).length } doValidate(e) { return this.masked.doValidate(this.currentMaskFlags(e)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(e))) } doCommit() { this.masked.doCommit() } get state() { return { _value: this.value, _rawInputValue: this.rawInputValue, masked: this.masked.state, isFilled: this.isFilled } } set state(e) { this.masked.state = e.masked, this.isFilled = e.isFilled } currentMaskFlags(e) { var t; return { ...e, _beforeTailState: (null == e || null == (t = e._beforeTailState) ? void 0 : t.masked) || (null == e ? void 0 : e._beforeTailState) } } } A.DEFAULT_DEFINITIONS = { 0: /\d/, a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, "*": /./ }, p.MaskedRegExp = class extends C { updateOptions(e) { super.updateOptions(e) } _update(e) { const t = e.mask; t && (e.validate = e => e.search(t) >= 0), super._update(e) } }; class M extends C { constructor(e) { super({ ...M.DEFAULTS, ...e, definitions: Object.assign({}, A.DEFAULT_DEFINITIONS, null == e ? void 0 : e.definitions) }) } updateOptions(e) { super.updateOptions(e) } _update(e) { e.definitions = Object.assign({}, this.definitions, e.definitions), super._update(e), this._rebuildMask() } _rebuildMask() { const e = this.definitions; this._blocks = [], this.exposeBlock = void 0, this._stops = [], this._maskedBlocks = {}; const t = this.mask; if (!t || !e) return; let i = !1, s = !1; for (let n = 0; n < t.length; ++n) { if (this.blocks) { const e = t.slice(n), i = Object.keys(this.blocks).filter((t => 0 === e.indexOf(t))); i.sort(((e, t) => t.length - e.length)); const s = i[0]; if (s) { const { expose: e, ...t } = m(this.blocks[s]), i = g({ lazy: this.lazy, eager: this.eager, placeholderChar: this.placeholderChar, displayChar: this.displayChar, overwrite: this.overwrite, ...t, parent: this }); i && (this._blocks.push(i), e && (this.exposeBlock = i), this._maskedBlocks[s] || (this._maskedBlocks[s] = []), this._maskedBlocks[s].push(this._blocks.length - 1)), n += s.length - 1; continue } } let o = t[n], a = o in e; if (o === M.STOP_CHAR) { this._stops.push(this._blocks.length); continue } if ("{" === o || "}" === o) { i = !i; continue } if ("[" === o || "]" === o) { s = !s; continue } if (o === M.ESCAPE_CHAR) { if (++n, o = t[n], !o) break; a = !1 } const r = a ? new A({ isOptional: s, lazy: this.lazy, eager: this.eager, placeholderChar: this.placeholderChar, displayChar: this.displayChar, ...m(e[o]), parent: this }) : new T({ char: o, eager: this.eager, isUnmasking: i }); this._blocks.push(r) } } get state() { return { ...super.state, _blocks: this._blocks.map((e => e.state)) } } set state(e) { const { _blocks: t, ...i } = e; this._blocks.forEach(((e, i) => e.state = t[i])), super.state = i } reset() { super.reset(), this._blocks.forEach((e => e.reset())) } get isComplete() { return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every((e => e.isComplete)) } get isFilled() { return this._blocks.every((e => e.isFilled)) } get isFixed() { return this._blocks.every((e => e.isFixed)) } get isOptional() { return this._blocks.every((e => e.isOptional)) } doCommit() { this._blocks.forEach((e => e.doCommit())), super.doCommit() } get unmaskedValue() { return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce(((e, t) => e + t.unmaskedValue), "") } set unmaskedValue(e) { if (this.exposeBlock) { const t = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length); this.exposeBlock.unmaskedValue = e, this.appendTail(t), this.doCommit() } else super.unmaskedValue = e } get value() { return this.exposeBlock ? this.exposeBlock.value : this._blocks.reduce(((e, t) => e + t.value), "") } set value(e) { if (this.exposeBlock) { const t = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length); this.exposeBlock.value = e, this.appendTail(t), this.doCommit() } else super.value = e } get typedValue() { return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue } set typedValue(e) { if (this.exposeBlock) { const t = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length); this.exposeBlock.typedValue = e, this.appendTail(t), this.doCommit() } else super.typedValue = e } get displayValue() { return this._blocks.reduce(((e, t) => e + t.displayValue), "") } appendTail(e) { return super.appendTail(e).aggregate(this._appendPlaceholder()) } _appendEager() { var e; const t = new E; let i = null == (e = this._mapPosToBlock(this.displayValue.length)) ? void 0 : e.index; if (null == i) return t; this._blocks[i].isFilled && ++i; for (let e = i; e < this._blocks.length; ++e) { const i = this._blocks[e]._appendEager(); if (!i.inserted) break; t.aggregate(i) } return t } _appendCharRaw(e, t) { void 0 === t && (t = {}); const i = this._mapPosToBlock(this.displayValue.length), s = new E; if (!i) return s; for (let o = i.index; ; ++o) { var n; const i = this._blocks[o]; if (!i) break; const a = i._appendChar(e, { ...t, _beforeTailState: null == (n = t._beforeTailState) || null == (n = n._blocks) ? void 0 : n[o] }), r = a.skip; if (s.aggregate(a), r || a.rawInserted) break } return s } extractTail(e, t) { void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length); const i = new x; return e === t || this._forEachBlocksInRange(e, t, ((e, t, s, n) => { const o = e.extractTail(s, n); o.stop = this._findStopBefore(t), o.from = this._blockStartPos(t), o instanceof x && (o.blockIndex = t), i.extend(o) })), i } extractInput(e, t, i) { if (void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length), void 0 === i && (i = {}), e === t) return ""; let s = ""; return this._forEachBlocksInRange(e, t, ((e, t, n, o) => { s += e.extractInput(n, o, i) })), s } _findStopBefore(e) { let t; for (let i = 0; i < this._stops.length; ++i) { const s = this._stops[i]; if (!(s <= e)) break; t = s } return t } _appendPlaceholder(e) { const t = new E; if (this.lazy && null == e) return t; const i = this._mapPosToBlock(this.displayValue.length); if (!i) return t; const s = i.index, n = null != e ? e : this._blocks.length; return this._blocks.slice(s, n).forEach((i => { if (!i.lazy || null != e) { var s; const e = i._appendPlaceholder(null == (s = i._blocks) ? void 0 : s.length); this._value += e.inserted, t.aggregate(e) } })), t } _mapPosToBlock(e) { let t = ""; for (let i = 0; i < this._blocks.length; ++i) { const s = this._blocks[i], n = t.length; if (t += s.displayValue, e <= t.length) return { index: i, offset: e - n } } } _blockStartPos(e) { return this._blocks.slice(0, e).reduce(((e, t) => e + t.displayValue.length), 0) } _forEachBlocksInRange(e, t, i) { void 0 === t && (t = this.displayValue.length); const s = this._mapPosToBlock(e); if (s) { const e = this._mapPosToBlock(t), n = e && s.index === e.index, o = s.offset, a = e && n ? e.offset : this._blocks[s.index].displayValue.length; if (i(this._blocks[s.index], s.index, o, a), e && !n) { for (let t = s.index + 1; t < e.index; ++t)i(this._blocks[t], t, 0, this._blocks[t].displayValue.length); i(this._blocks[e.index], e.index, 0, e.offset) } } } remove(e, t) { void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length); const i = super.remove(e, t); return this._forEachBlocksInRange(e, t, ((e, t, s, n) => { i.aggregate(e.remove(s, n)) })), i } nearestInputPos(e, t) { if (void 0 === t && (t = o), !this._blocks.length) return 0; const i = new k(this, e); if (t === o) return i.pushRightBeforeInput() ? i.pos : (i.popState(), i.pushLeftBeforeInput() ? i.pos : this.displayValue.length); if (t === a || t === r) { if (t === a) { if (i.pushRightBeforeFilled(), i.ok && i.pos === e) return e; i.popState() } if (i.pushLeftBeforeInput(), i.pushLeftBeforeRequired(), i.pushLeftBeforeFilled(), t === a) { if (i.pushRightBeforeInput(), i.pushRightBeforeRequired(), i.ok && i.pos <= e) return i.pos; if (i.popState(), i.ok && i.pos <= e) return i.pos; i.popState() } return i.ok ? i.pos : t === r ? 0 : (i.popState(), i.ok ? i.pos : (i.popState(), i.ok ? i.pos : 0)) } return t === l || t === c ? (i.pushRightBeforeInput(), i.pushRightBeforeRequired(), i.pushRightBeforeFilled() ? i.pos : t === c ? this.displayValue.length : (i.popState(), i.ok ? i.pos : (i.popState(), i.ok ? i.pos : this.nearestInputPos(e, a)))) : e } totalInputPositions(e, t) { void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length); let i = 0; return this._forEachBlocksInRange(e, t, ((e, t, s, n) => { i += e.totalInputPositions(s, n) })), i } maskedBlock(e) { return this.maskedBlocks(e)[0] } maskedBlocks(e) { const t = this._maskedBlocks[e]; return t ? t.map((e => this._blocks[e])) : [] } } M.DEFAULTS = { lazy: !0, placeholderChar: "_" }, M.STOP_CHAR = "`", M.ESCAPE_CHAR = "\\", M.InputDefinition = A, M.FixedDefinition = T, p.MaskedPattern = M; class P extends M { get _matchFrom() { return this.maxLength - String(this.from).length } constructor(e) { super(e) } updateOptions(e) { super.updateOptions(e) } _update(e) { const { to: t = this.to || 0, from: i = this.from || 0, maxLength: s = this.maxLength || 0, autofix: n = this.autofix, ...o } = e; this.to = t, this.from = i, this.maxLength = Math.max(String(t).length, s), this.autofix = n; const a = String(this.from).padStart(this.maxLength, "0"), r = String(this.to).padStart(this.maxLength, "0"); let l = 0; for (; l < r.length && r[l] === a[l];)++l; o.mask = r.slice(0, l).replace(/0/g, "\\0") + "0".repeat(this.maxLength - l), super._update(o) } get isComplete() { return super.isComplete && Boolean(this.value) } boundaries(e) { let t = "", i = ""; const [, s, n] = e.match(/^(\D*)(\d*)(\D*)/) || []; return n && (t = "0".repeat(s.length) + n, i = "9".repeat(s.length) + n), t = t.padEnd(this.maxLength, "0"), i = i.padEnd(this.maxLength, "9"), [t, i] } doPrepareChar(e, t) { let i; if (void 0 === t && (t = {}), [e, i] = super.doPrepareChar(e.replace(/\D/g, ""), t), !this.autofix || !e) return [e, i]; const s = String(this.from).padStart(this.maxLength, "0"), n = String(this.to).padStart(this.maxLength, "0"), o = this.value + e; if (o.length > this.maxLength) return ["", i]; const [a, r] = this.boundaries(o); return Number(r) < this.from ? [s[o.length - 1], i] : Number(a) > this.to ? "pad" === this.autofix && o.length < this.maxLength ? ["", i.aggregate(this.append(s[o.length - 1] + e, t))] : [n[o.length - 1], i] : [e, i] } doValidate(e) { const t = this.value; if (-1 === t.search(/[^0]/) && t.length <= this._matchFrom) return !0; const [i, s] = this.boundaries(t); return this.from <= Number(s) && Number(i) <= this.to && super.doValidate(e) } } p.MaskedRange = P; class O extends M { constructor(e) { const { mask: i, pattern: s, ...n } = { ...O.DEFAULTS, ...e }; super({ ...n, mask: t(i) ? i : s }) } updateOptions(e) { super.updateOptions(e) } _update(e) { const { mask: i, pattern: s, blocks: n, ...o } = { ...O.DEFAULTS, ...e }, a = Object.assign({}, O.GET_DEFAULT_BLOCKS()); e.min && (a.Y.from = e.min.getFullYear()), e.max && (a.Y.to = e.max.getFullYear()), e.min && e.max && a.Y.from === a.Y.to && (a.m.from = e.min.getMonth() + 1, a.m.to = e.max.getMonth() + 1, a.m.from === a.m.to && (a.d.from = e.min.getDate(), a.d.to = e.max.getDate())), Object.assign(a, this.blocks, n), Object.keys(a).forEach((t => { const i = a[t]; !("autofix" in i) && "autofix" in e && (i.autofix = e.autofix) })), super._update({ ...o, mask: t(i) ? i : s, blocks: a }) } doValidate(e) { const t = this.date; return super.doValidate(e) && (!this.isComplete || this.isDateExist(this.value) && null != t && (null == this.min || this.min <= t) && (null == this.max || t <= this.max)) } isDateExist(e) { return this.format(this.parse(e, this), this).indexOf(e) >= 0 } get date() { return this.typedValue } set date(e) { this.typedValue = e } get typedValue() { return this.isComplete ? super.typedValue : null } set typedValue(e) { super.typedValue = e } maskEquals(e) { return e === Date || super.maskEquals(e) } } O.GET_DEFAULT_BLOCKS = () => ({ d: { mask: P, from: 1, to: 31, maxLength: 2 }, m: { mask: P, from: 1, to: 12, maxLength: 2 }, Y: { mask: P, from: 1900, to: 9999 } }), O.DEFAULTS = { mask: Date, pattern: "d{.}`m{.}`Y", format: (e, t) => e ? [String(e.getDate()).padStart(2, "0"), String(e.getMonth() + 1).padStart(2, "0"), e.getFullYear()].join(".") : "", parse: (e, t) => { const [i, s, n] = e.split(".").map(Number); return new Date(n, s - 1, i) } }, p.MaskedDate = O; class _ extends C { constructor(e) { super({ ..._.DEFAULTS, ...e }), this.currentMask = void 0 } updateOptions(e) { super.updateOptions(e) } _update(e) { super._update(e), "mask" in e && (this.exposeMask = void 0, this.compiledMasks = Array.isArray(e.mask) ? e.mask.map((e => { const { expose: t, ...i } = m(e), s = g({ overwrite: this._overwrite, eager: this._eager, skipInvalid: this._skipInvalid, ...i }); return t && (this.exposeMask = s), s })) : []) } _appendCharRaw(e, t) { void 0 === t && (t = {}); const i = this._applyDispatch(e, t); return this.currentMask && i.aggregate(this.currentMask._appendChar(e, this.currentMaskFlags(t))), i } _applyDispatch(e, t, i) { void 0 === e && (e = ""), void 0 === t && (t = {}), void 0 === i && (i = ""); const s = t.tail && null != t._beforeTailState ? t._beforeTailState._value : this.value, n = this.rawInputValue, o = t.tail && null != t._beforeTailState ? t._beforeTailState._rawInputValue : n, a = n.slice(o.length), r = this.currentMask, l = new E, c = null == r ? void 0 : r.state; if (this.currentMask = this.doDispatch(e, { ...t }, i), this.currentMask) if (this.currentMask !== r) { if (this.currentMask.reset(), o) { const e = this.currentMask.append(o, { raw: !0 }); l.tailShift = e.inserted.length - s.length } a && (l.tailShift += this.currentMask.append(a, { raw: !0, tail: !0 }).tailShift) } else c && (this.currentMask.state = c); return l } _appendPlaceholder() { const e = this._applyDispatch(); return this.currentMask && e.aggregate(this.currentMask._appendPlaceholder()), e } _appendEager() { const e = this._applyDispatch(); return this.currentMask && e.aggregate(this.currentMask._appendEager()), e } appendTail(e) { const t = new E; return e && t.aggregate(this._applyDispatch("", {}, e)), t.aggregate(this.currentMask ? this.currentMask.appendTail(e) : super.appendTail(e)) } currentMaskFlags(e) { var t, i; return { ...e, _beforeTailState: (null == (t = e._beforeTailState) ? void 0 : t.currentMaskRef) === this.currentMask && (null == (i = e._beforeTailState) ? void 0 : i.currentMask) || e._beforeTailState } } doDispatch(e, t, i) { return void 0 === t && (t = {}), void 0 === i && (i = ""), this.dispatch(e, this, t, i) } doValidate(e) { return super.doValidate(e) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(e))) } doPrepare(e, t) { void 0 === t && (t = {}); let [i, s] = super.doPrepare(e, t); if (this.currentMask) { let e;[i, e] = super.doPrepare(i, this.currentMaskFlags(t)), s = s.aggregate(e) } return [i, s] } doPrepareChar(e, t) { void 0 === t && (t = {}); let [i, s] = super.doPrepareChar(e, t); if (this.currentMask) { let e;[i, e] = super.doPrepareChar(i, this.currentMaskFlags(t)), s = s.aggregate(e) } return [i, s] } reset() { var e; null == (e = this.currentMask) || e.reset(), this.compiledMasks.forEach((e => e.reset())) } get value() { return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : "" } set value(e) { this.exposeMask ? (this.exposeMask.value = e, this.currentMask = this.exposeMask, this._applyDispatch()) : super.value = e } get unmaskedValue() { return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : "" } set unmaskedValue(e) { this.exposeMask ? (this.exposeMask.unmaskedValue = e, this.currentMask = this.exposeMask, this._applyDispatch()) : super.unmaskedValue = e } get typedValue() { return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : "" } set typedValue(e) { if (this.exposeMask) return this.exposeMask.typedValue = e, this.currentMask = this.exposeMask, void this._applyDispatch(); let t = String(e); this.currentMask && (this.currentMask.typedValue = e, t = this.currentMask.unmaskedValue), this.unmaskedValue = t } get displayValue() { return this.currentMask ? this.currentMask.displayValue : "" } get isComplete() { var e; return Boolean(null == (e = this.currentMask) ? void 0 : e.isComplete) } get isFilled() { var e; return Boolean(null == (e = this.currentMask) ? void 0 : e.isFilled) } remove(e, t) { const i = new E; return this.currentMask && i.aggregate(this.currentMask.remove(e, t)).aggregate(this._applyDispatch()), i } get state() { var e; return { ...super.state, _rawInputValue: this.rawInputValue, compiledMasks: this.compiledMasks.map((e => e.state)), currentMaskRef: this.currentMask, currentMask: null == (e = this.currentMask) ? void 0 : e.state } } set state(e) { const { compiledMasks: t, currentMaskRef: i, currentMask: s, ...n } = e; t && this.compiledMasks.forEach(((e, i) => e.state = t[i])), null != i && (this.currentMask = i, this.currentMask.state = s), super.state = n } extractInput(e, t, i) { return this.currentMask ? this.currentMask.extractInput(e, t, i) : "" } extractTail(e, t) { return this.currentMask ? this.currentMask.extractTail(e, t) : super.extractTail(e, t) } doCommit() { this.currentMask && this.currentMask.doCommit(), super.doCommit() } nearestInputPos(e, t) { return this.currentMask ? this.currentMask.nearestInputPos(e, t) : super.nearestInputPos(e, t) } get overwrite() { return this.currentMask ? this.currentMask.overwrite : this._overwrite } set overwrite(e) { this._overwrite = e } get eager() { return this.currentMask ? this.currentMask.eager : this._eager } set eager(e) { this._eager = e } get skipInvalid() { return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid } set skipInvalid(e) { this._skipInvalid = e } maskEquals(e) { return Array.isArray(e) ? this.compiledMasks.every(((t, i) => { if (!e[i]) return; const { mask: s, ...n } = e[i]; return d(t, n) && t.maskEquals(s) })) : super.maskEquals(e) } typedValueEquals(e) { var t; return Boolean(null == (t = this.currentMask) ? void 0 : t.typedValueEquals(e)) } } _.DEFAULTS = void 0, _.DEFAULTS = { dispatch: (e, t, i, s) => { if (!t.compiledMasks.length) return; const n = t.rawInputValue, o = t.compiledMasks.map(((o, a) => { const l = t.currentMask === o, c = l ? o.displayValue.length : o.nearestInputPos(o.displayValue.length, r); return o.rawInputValue !== n ? (o.reset(), o.append(n, { raw: !0 })) : l || o.remove(c), o.append(e, t.currentMaskFlags(i)), o.appendTail(s), { index: a, weight: o.rawInputValue.length, totalInputPositions: o.totalInputPositions(0, Math.max(c, o.nearestInputPos(o.displayValue.length, r))) } })); return o.sort(((e, t) => t.weight - e.weight || t.totalInputPositions - e.totalInputPositions)), t.compiledMasks[o[0].index] } }, p.MaskedDynamic = _, p.MaskedEnum = class extends M { constructor(e) { super(e) } updateOptions(e) { super.updateOptions(e) } _update(e) { const { enum: t, ...i } = e; if (t) { const e = t.map((e => e.length)), s = Math.min(...e), n = Math.max(...e) - s; i.mask = "*".repeat(s), n && (i.mask += "[" + "*".repeat(n) + "]"), this.enum = t } super._update(i) } doValidate(e) { return this.enum.some((e => 0 === e.indexOf(this.unmaskedValue))) && super.doValidate(e) } }, p.MaskedFunction = class extends C { updateOptions(e) { super.updateOptions(e) } _update(e) { super._update({ ...e, validate: e.mask }) } }; class L extends C { constructor(e) { super({ ...L.DEFAULTS, ...e }) } updateOptions(e) { super.updateOptions(e) } _update(e) { super._update(e), this._updateRegExps() } _updateRegExps() { const e = "^" + (this.allowNegative ? "[+|\\-]?" : ""), t = (this.scale ? "(" + u(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$"; this._numberRegExp = new RegExp(e + "\\d*" + t), this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(u).join("") + "]", "g"), this._thousandsSeparatorRegExp = new RegExp(u(this.thousandsSeparator), "g") } _removeThousandsSeparators(e) { return e.replace(this._thousandsSeparatorRegExp, "") } _insertThousandsSeparators(e) { const t = e.split(this.radix); return t[0] = t[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), t.join(this.radix) } doPrepareChar(e, t) { void 0 === t && (t = {}); const [i, s] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (t.input && t.raw || !t.input && !t.raw) ? e.replace(this._mapToRadixRegExp, this.radix) : e), t); return e && !i && (s.skip = !0), !i || this.allowPositive || this.value || "-" === i || s.aggregate(this._appendChar("-")), [i, s] } _separatorsCount(e, t) { void 0 === t && (t = !1); let i = 0; for (let s = 0; s < e; ++s)this._value.indexOf(this.thousandsSeparator, s) === s && (++i, t && (e += this.thousandsSeparator.length)); return i } _separatorsCountFromSlice(e) { return void 0 === e && (e = this._value), this._separatorsCount(this._removeThousandsSeparators(e).length, !0) } extractInput(e, t, i) { return void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length), [e, t] = this._adjustRangeWithSeparators(e, t), this._removeThousandsSeparators(super.extractInput(e, t, i)) } _appendCharRaw(e, t) { if (void 0 === t && (t = {}), !this.thousandsSeparator) return super._appendCharRaw(e, t); const i = t.tail && t._beforeTailState ? t._beforeTailState._value : this._value, s = this._separatorsCountFromSlice(i); this._value = this._removeThousandsSeparators(this.value); const n = super._appendCharRaw(e, t); this._value = this._insertThousandsSeparators(this._value); const o = t.tail && t._beforeTailState ? t._beforeTailState._value : this._value, a = this._separatorsCountFromSlice(o); return n.tailShift += (a - s) * this.thousandsSeparator.length, n.skip = !n.rawInserted && e === this.thousandsSeparator, n } _findSeparatorAround(e) { if (this.thousandsSeparator) { const t = e - this.thousandsSeparator.length + 1, i = this.value.indexOf(this.thousandsSeparator, t); if (i <= e) return i } return -1 } _adjustRangeWithSeparators(e, t) { const i = this._findSeparatorAround(e); i >= 0 && (e = i); const s = this._findSeparatorAround(t); return s >= 0 && (t = s + this.thousandsSeparator.length), [e, t] } remove(e, t) { void 0 === e && (e = 0), void 0 === t && (t = this.displayValue.length), [e, t] = this._adjustRangeWithSeparators(e, t); const i = this.value.slice(0, e), s = this.value.slice(t), n = this._separatorsCount(i.length); this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(i + s)); const o = this._separatorsCountFromSlice(i); return new E({ tailShift: (o - n) * this.thousandsSeparator.length }) } nearestInputPos(e, t) { if (!this.thousandsSeparator) return e; switch (t) { case o: case a: case r: { const i = this._findSeparatorAround(e - 1); if (i >= 0) { const s = i + this.thousandsSeparator.length; if (e < s || this.value.length <= s || t === r) return i } break } case l: case c: { const t = this._findSeparatorAround(e); if (t >= 0) return t + this.thousandsSeparator.length } }return e } doValidate(e) { let t = Boolean(this._removeThousandsSeparators(this.value).match(this._numberRegExp)); if (t) { const e = this.number; t = t && !isNaN(e) && (null == this.min || this.min >= 0 || this.min <= this.number) && (null == this.max || this.max <= 0 || this.number <= this.max) } return t && super.doValidate(e) } doCommit() { if (this.value) { const e = this.number; let t = e; null != this.min && (t = Math.max(t, this.min)), null != this.max && (t = Math.min(t, this.max)), t !== e && (this.unmaskedValue = this.format(t, this)); let i = this.value; this.normalizeZeros && (i = this._normalizeZeros(i)), this.padFractionalZeros && this.scale > 0 && (i = this._padFractionalZeros(i)), this._value = i } super.doCommit() } _normalizeZeros(e) { const t = this._removeThousandsSeparators(e).split(this.radix); return t[0] = t[0].replace(/^(\D*)(0*)(\d*)/, ((e, t, i, s) => t + s)), e.length && !/\d$/.test(t[0]) && (t[0] = t[0] + "0"), t.length > 1 && (t[1] = t[1].replace(/0*$/, ""), t[1].length || (t.length = 1)), this._insertThousandsSeparators(t.join(this.radix)) } _padFractionalZeros(e) { if (!e) return e; const t = e.split(this.radix); return t.length < 2 && t.push(""), t[1] = t[1].padEnd(this.scale, "0"), t.join(this.radix) } doSkipInvalid(e, t, i) { void 0 === t && (t = {}); const s = 0 === this.scale && e !== this.thousandsSeparator && (e === this.radix || e === L.UNMASKED_RADIX || this.mapToRadix.includes(e)); return super.doSkipInvalid(e, t, i) && !s } get unmaskedValue() { return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, L.UNMASKED_RADIX) } set unmaskedValue(e) { super.unmaskedValue = e } get typedValue() { return this.parse(this.unmaskedValue, this) } set typedValue(e) { this.rawInputValue = this.format(e, this).replace(L.UNMASKED_RADIX, this.radix) } get number() { return this.typedValue } set number(e) { this.typedValue = e } get allowNegative() { return null != this.min && this.min < 0 || null != this.max && this.max < 0 } get allowPositive() { return null != this.min && this.min > 0 || null != this.max && this.max > 0 } typedValueEquals(e) { return (super.typedValueEquals(e) || L.EMPTY_VALUES.includes(e) && L.EMPTY_VALUES.includes(this.typedValue)) && !(0 === e && "" === this.value) } } L.UNMASKED_RADIX = ".", L.EMPTY_VALUES = [...C.EMPTY_VALUES, 0], L.DEFAULTS = { mask: Number, radix: ",", thousandsSeparator: "", mapToRadix: [L.UNMASKED_RADIX], min: Number.MIN_SAFE_INTEGER, max: Number.MAX_SAFE_INTEGER, scale: 2, normalizeZeros: !0, padFractionalZeros: !1, parse: Number, format: e => e.toLocaleString("en-US", { useGrouping: !1, maximumFractionDigits: 20 }) }, p.MaskedNumber = L; const D = { MASKED: "value", UNMASKED: "unmaskedValue", TYPED: "typedValue" }; function F(e, t, i) { void 0 === t && (t = D.MASKED), void 0 === i && (i = D.MASKED); const s = g(e); return e => s.runIsolated((s => (s[t] = e, s[i]))) } p.PIPE_TYPE = D, p.createPipe = F, p.pipe = function (e, t, i, s) { return F(t, i, s)(e) }; try { globalThis.IMask = p } catch { } const I = (e, t = 1e4) => (e = parseFloat(e + "") || 0, Math.round((e + Number.EPSILON) * t) / t), B = function (e) { if (!(e && e instanceof Element && e.offsetParent)) return !1; const t = e.scrollHeight > e.clientHeight, i = window.getComputedStyle(e).overflowY, s = -1 !== i.indexOf("hidden"), n = -1 !== i.indexOf("visible"); return t && !s && !n }, z = function (e, t = void 0) { return !(!e || e === document.body || t && e === t) && (B(e) ? e : z(e.parentElement, t)) }, R = function (e) { var t = (new DOMParser).parseFromString(e, "text/html").body; if (t.childElementCount > 1) { for (var i = document.createElement("div"); t.firstChild;)i.appendChild(t.firstChild); return i } return t.firstChild }, j = e => `${e || ""}`.split(" ").filter((e => !!e)), V = (e, t, i) => { j(t).forEach((t => { e && e.classList.toggle(t, i || !1) })) }; class $ { constructor(e) { Object.defineProperty(this, "pageX", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "pageY", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "clientX", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "clientY", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "id", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "time", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "nativePointer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.nativePointer = e, this.pageX = e.pageX, this.pageY = e.pageY, this.clientX = e.clientX, this.clientY = e.clientY, this.id = self.Touch && e instanceof Touch ? e.identifier : -1, this.time = Date.now() } } const N = { passive: !1 }; class H { constructor(e, { start: t = (() => !0), move: i = (() => { }), end: s = (() => { }) }) { Object.defineProperty(this, "element", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "startCallback", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "moveCallback", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "endCallback", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "currentPointers", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "startPointers", { enumerable: !0, configurable: !0, writable: !0, value: [] }), this.element = e, this.startCallback = t, this.moveCallback = i, this.endCallback = s; for (const e of ["onPointerStart", "onTouchStart", "onMove", "onTouchEnd", "onPointerEnd", "onWindowBlur"]) this[e] = this[e].bind(this); this.element.addEventListener("mousedown", this.onPointerStart, N), this.element.addEventListener("touchstart", this.onTouchStart, N), this.element.addEventListener("touchmove", this.onMove, N), this.element.addEventListener("touchend", this.onTouchEnd), this.element.addEventListener("touchcancel", this.onTouchEnd) } onPointerStart(e) { if (!e.buttons || 0 !== e.button) return; const t = new $(e); this.currentPointers.some((e => e.id === t.id)) || this.triggerPointerStart(t, e) && (window.addEventListener("mousemove", this.onMove), window.addEventListener("mouseup", this.onPointerEnd), window.addEventListener("blur", this.onWindowBlur)) } onTouchStart(e) { for (const t of Array.from(e.changedTouches || [])) this.triggerPointerStart(new $(t), e); window.addEventListener("blur", this.onWindowBlur) } onMove(e) { const t = this.currentPointers.slice(), i = "changedTouches" in e ? Array.from(e.changedTouches || []).map((e => new $(e))) : [new $(e)], s = []; for (const e of i) { const t = this.currentPointers.findIndex((t => t.id === e.id)); t < 0 || (s.push(e), this.currentPointers[t] = e) } s.length && this.moveCallback(e, this.currentPointers.slice(), t) } onPointerEnd(e) { e.buttons > 0 && 0 !== e.button || (this.triggerPointerEnd(e, new $(e)), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur)) } onTouchEnd(e) { for (const t of Array.from(e.changedTouches || [])) this.triggerPointerEnd(e, new $(t)) } triggerPointerStart(e, t) { return !!this.startCallback(t, e, this.currentPointers.slice()) && (this.currentPointers.push(e), this.startPointers.push(e), !0) } triggerPointerEnd(e, t) { const i = this.currentPointers.findIndex((e => e.id === t.id)); i < 0 || (this.currentPointers.splice(i, 1), this.startPointers.splice(i, 1), this.endCallback(e, t, this.currentPointers.slice())) } onWindowBlur() { this.clear() } clear() { for (; this.currentPointers.length;) { const e = this.currentPointers[this.currentPointers.length - 1]; this.currentPointers.splice(this.currentPointers.length - 1, 1), this.startPointers.splice(this.currentPointers.length - 1, 1), this.endCallback(new Event("touchend", { bubbles: !0, cancelable: !0, clientX: e.clientX, clientY: e.clientY }), e, this.currentPointers.slice()) } } stop() { this.element.removeEventListener("mousedown", this.onPointerStart, N), this.element.removeEventListener("touchstart", this.onTouchStart, N), this.element.removeEventListener("touchmove", this.onMove, N), this.element.removeEventListener("touchend", this.onTouchEnd), this.element.removeEventListener("touchcancel", this.onTouchEnd), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur) } } function q(e, t) { return t ? Math.sqrt(Math.pow(t.clientX - e.clientX, 2) + Math.pow(t.clientY - e.clientY, 2)) : 0 } function W(e, t) { return t ? { clientX: (e.clientX + t.clientX) / 2, clientY: (e.clientY + t.clientY) / 2 } : e } const G = e => "object" == typeof e && null !== e && e.constructor === Object && "[object Object]" === Object.prototype.toString.call(e), X = (e, ...t) => { const i = t.length; for (let s = 0; s < i; s++) { const i = t[s] || {}; Object.entries(i).forEach((([t, i]) => { const s = Array.isArray(i) ? [] : {}; e[t] || Object.assign(e, { [t]: s }), G(i) ? Object.assign(e[t], X(s, i)) : Array.isArray(i) ? Object.assign(e, { [t]: [...i] }) : Object.assign(e, { [t]: i }) })) } return e }, Y = function (e, t) { return e.split(".").reduce(((e, t) => "object" == typeof e ? e[t] : void 0), t) }; class U { constructor(e = {}) { Object.defineProperty(this, "options", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "events", { enumerable: !0, configurable: !0, writable: !0, value: new Map }), this.setOptions(e); for (const e of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) e.startsWith("on") && "function" == typeof this[e] && (this[e] = this[e].bind(this)) } setOptions(e) { this.options = e ? X({}, this.constructor.defaults, e) : {}; for (const [e, t] of Object.entries(this.option("on") || {})) this.on(e, t) } option(e, ...t) { let i = Y(e, this.options); return i && "function" == typeof i && (i = i.call(this, this, ...t)), i } optionFor(e, t, i, ...s) { let n = Y(t, e); var o; "string" != typeof (o = n) || isNaN(o) || isNaN(parseFloat(o)) || (n = parseFloat(n)), "true" === n && (n = !0), "false" === n && (n = !1), n && "function" == typeof n && (n = n.call(this, this, e, ...s)); let a = Y(t, this.options); return a && "function" == typeof a ? n = a.call(this, this, e, ...s, n) : void 0 === n && (n = a), void 0 === n ? i : n } cn(e) { const t = this.options.classes; return t && t[e] || "" } localize(e, t = []) { e = String(e).replace(/\{\{(\w+).?(\w+)?\}\}/g, ((e, t, i) => { let s = ""; return i ? s = this.option(`${t[0] + t.toLowerCase().substring(1)}.l10n.${i}`) : t && (s = this.option(`l10n.${t}`)), s || (s = e), s })); for (let i = 0; i < t.length; i++)e = e.split(t[i][0]).join(t[i][1]); return e.replace(/\{\{(.*?)\}\}/g, ((e, t) => t)) } on(e, t) { let i = []; "string" == typeof e ? i = e.split(" ") : Array.isArray(e) && (i = e), this.events || (this.events = new Map), i.forEach((e => { let i = this.events.get(e); i || (this.events.set(e, []), i = []), i.includes(t) || i.push(t), this.events.set(e, i) })) } off(e, t) { let i = []; "string" == typeof e ? i = e.split(" ") : Array.isArray(e) && (i = e), i.forEach((e => { const i = this.events.get(e); if (Array.isArray(i)) { const e = i.indexOf(t); e > -1 && i.splice(e, 1) } })) } emit(e, ...t) { [...this.events.get(e) || []].forEach((e => e(this, ...t))), "*" !== e && this.emit("*", e, ...t) } } Object.defineProperty(U, "version", { enumerable: !0, configurable: !0, writable: !0, value: "5.0.22" }), Object.defineProperty(U, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: {} }); class Z extends U { constructor(e = {}) { super(e), Object.defineProperty(this, "plugins", { enumerable: !0, configurable: !0, writable: !0, value: {} }) } attachPlugins(e = {}) { const t = new Map; for (const [i, s] of Object.entries(e)) { const e = this.option(i), n = this.plugins[i]; n || !1 === e ? n && !1 === e && (n.detach(), delete this.plugins[i]) : t.set(i, new s(this, e || {})) } for (const [e, i] of t) this.plugins[e] = i, i.attach(); this.emit("attachPlugins") } detachPlugins(e) { e = e || Object.keys(this.plugins); for (const t of e) { const e = this.plugins[t]; e && e.detach(), delete this.plugins[t] } return this.emit("detachPlugins"), this } } var K; !function (e) { e[e.Init = 0] = "Init", e[e.Error = 1] = "Error", e[e.Ready = 2] = "Ready", e[e.Panning = 3] = "Panning", e[e.Mousemove = 4] = "Mousemove", e[e.Destroy = 5] = "Destroy" }(K || (K = {})); const J = ["a", "b", "c", "d", "e", "f"], Q = { PANUP: "Move up", PANDOWN: "Move down", PANLEFT: "Move left", PANRIGHT: "Move right", ZOOMIN: "Zoom in", ZOOMOUT: "Zoom out", TOGGLEZOOM: "Toggle zoom level", TOGGLE1TO1: "Toggle zoom level", ITERATEZOOM: "Toggle zoom level", ROTATECCW: "Rotate counterclockwise", ROTATECW: "Rotate clockwise", FLIPX: "Flip horizontally", FLIPY: "Flip vertically", FITX: "Fit horizontally", FITY: "Fit vertically", RESET: "Reset", TOGGLEFS: "Toggle fullscreen" }, ee = { content: null, width: "auto", height: "auto", panMode: "drag", touch: !0, dragMinThreshold: 3, lockAxis: !1, mouseMoveFactor: 1, mouseMoveFriction: .12, zoom: !0, pinchToZoom: !0, panOnlyZoomed: "auto", minScale: 1, maxScale: 2, friction: .25, dragFriction: .35, decelFriction: .05, click: "toggleZoom", dblClick: !1, wheel: "zoom", wheelLimit: 7, spinner: !0, bounds: "auto", infinite: !1, rubberband: !0, bounce: !0, maxVelocity: 75, transformParent: !1, classes: { content: "f-panzoom__content", isLoading: "is-loading", canZoomIn: "can-zoom_in", canZoomOut: "can-zoom_out", isDraggable: "is-draggable", isDragging: "is-dragging", inFullscreen: "in-fullscreen", htmlHasFullscreen: "with-panzoom-in-fullscreen" }, l10n: Q }, te = '<div class="f-spinner"><svg viewBox="0 0 50 50"><circle cx="25" cy="25" r="20"></circle><circle cx="25" cy="25" r="20"></circle></svg></div>', ie = e => e && null !== e && e instanceof Element && "nodeType" in e, se = (e, t) => { e && j(t).forEach((t => { e.classList.remove(t) })) }, ne = (e, t) => { e && j(t).forEach((t => { e.classList.add(t) })) }, oe = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 }, ae = 1e3, re = "mousemove", le = "drag", ce = "content"; let ue = null, de = null; class he extends Z { get isTouchDevice() { return null === de && (de = window.matchMedia("(hover: none)").matches), de } get isMobile() { return null === ue && (ue = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)), ue } get panMode() { return this.options.panMode !== re || this.isTouchDevice ? le : re } get panOnlyZoomed() { const e = this.options.panOnlyZoomed; return "auto" === e ? this.isTouchDevice : e } get isInfinite() { return this.option("infinite") } get angle() { return 180 * Math.atan2(this.current.b, this.current.a) / Math.PI || 0 } get targetAngle() { return 180 * Math.atan2(this.target.b, this.target.a) / Math.PI || 0 } get scale() { const { a: e, b: t } = this.current; return Math.sqrt(e * e + t * t) || 1 } get targetScale() { const { a: e, b: t } = this.target; return Math.sqrt(e * e + t * t) || 1 } get minScale() { return this.option("minScale") || 1 } get fullScale() { const { contentRect: e } = this; return e.fullWidth / e.fitWidth || 1 } get maxScale() { return this.fullScale * (this.option("maxScale") || 1) || 1 } get coverScale() { const { containerRect: e, contentRect: t } = this, i = Math.max(e.height / t.fitHeight, e.width / t.fitWidth) || 1; return Math.min(this.fullScale, i) } get isScaling() { return Math.abs(this.targetScale - this.scale) > 1e-5 && !this.isResting } get isContentLoading() { const e = this.content; return !!(e && e instanceof HTMLImageElement) && !e.complete } get isResting() { if (this.isBouncingX || this.isBouncingY) return !1; for (const e of J) { const t = "e" == e || "f" === e ? .001 : 1e-5; if (Math.abs(this.target[e] - this.current[e]) > t) return !1 } return !(!this.ignoreBounds && !this.checkBounds().inBounds) } constructor(e, t = {}, i = {}) { var s; if (super(t), Object.defineProperty(this, "pointerTracker", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "resizeObserver", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "updateTimer", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "clickTimer", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "rAF", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "isTicking", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "friction", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "ignoreBounds", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "isBouncingX", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "isBouncingY", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "clicks", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "trackingPoints", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "pwt", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "cwd", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "pmme", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "state", { enumerable: !0, configurable: !0, writable: !0, value: K.Init }), Object.defineProperty(this, "isDragging", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "container", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "content", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "spinner", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "containerRect", { enumerable: !0, configurable: !0, writable: !0, value: { width: 0, height: 0, innerWidth: 0, innerHeight: 0 } }), Object.defineProperty(this, "contentRect", { enumerable: !0, configurable: !0, writable: !0, value: { top: 0, right: 0, bottom: 0, left: 0, fullWidth: 0, fullHeight: 0, fitWidth: 0, fitHeight: 0, width: 0, height: 0 } }), Object.defineProperty(this, "dragStart", { enumerable: !0, configurable: !0, writable: !0, value: { x: 0, y: 0, top: 0, left: 0, time: 0 } }), Object.defineProperty(this, "dragOffset", { enumerable: !0, configurable: !0, writable: !0, value: { x: 0, y: 0, time: 0 } }), Object.defineProperty(this, "current", { enumerable: !0, configurable: !0, writable: !0, value: Object.assign({}, oe) }), Object.defineProperty(this, "target", { enumerable: !0, configurable: !0, writable: !0, value: Object.assign({}, oe) }), Object.defineProperty(this, "velocity", { enumerable: !0, configurable: !0, writable: !0, value: { a: 0, b: 0, c: 0, d: 0, e: 0, f: 0 } }), Object.defineProperty(this, "lockedAxis", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), !e) throw new Error("Container Element Not Found"); this.container = e, this.initContent(), this.attachPlugins(Object.assign(Object.assign({}, he.Plugins), i)), this.emit("init"); const n = this.content; if (n.addEventListener("load", this.onLoad), n.addEventListener("error", this.onError), this.isContentLoading) { if (this.option("spinner")) { e.classList.add(this.cn("isLoading")); const t = R(te); !e.contains(n) || n.parentElement instanceof HTMLPictureElement ? this.spinner = e.appendChild(t) : this.spinner = (null === (s = n.parentElement) || void 0 === s ? void 0 : s.insertBefore(t, n)) || null } this.emit("beforeLoad") } else queueMicrotask((() => { this.enable() })) } initContent() { const { container: e } = this, t = this.cn(ce); let i = this.option(ce) || e.querySelector(`.${t}`); if (i || (i = e.querySelector("img,picture") || e.firstElementChild, i && ne(i, t)), i instanceof HTMLPictureElement && (i = i.querySelector("img")), !i) throw new Error("No content found"); this.content = i } onLoad() { this.spinner && (this.spinner.remove(), this.spinner = null), this.option("spinner") && this.container.classList.remove(this.cn("isLoading")), this.emit("afterLoad"), this.state === K.Init ? this.enable() : this.updateMetrics() } onError() { this.state !== K.Destroy && (this.spinner && (this.spinner.remove(), this.spinner = null), this.stop(), this.detachEvents(), this.state = K.Error, this.emit("error")) } attachObserver() { var e; const t = () => Math.abs(this.containerRect.width - this.container.getBoundingClientRect().width) > .1 || Math.abs(this.containerRect.height - this.container.getBoundingClientRect().height) > .1; this.resizeObserver || void 0 === window.ResizeObserver || (this.resizeObserver = new ResizeObserver((() => { this.updateTimer || (t() ? (this.onResize(), this.isMobile && (this.updateTimer = setTimeout((() => { t() && this.onResize(), this.updateTimer = null }), 500))) : this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null)) }))), null === (e = this.resizeObserver) || void 0 === e || e.observe(this.container) } detachObserver() { var e; null === (e = this.resizeObserver) || void 0 === e || e.disconnect() } attachEvents() { const { container: e } = this; e.addEventListener("click", this.onClick, { passive: !1, capture: !1 }), e.addEventListener("wheel", this.onWheel, { passive: !1 }), this.pointerTracker = new H(e, { start: this.onPointerDown, move: this.onPointerMove, end: this.onPointerUp }), document.addEventListener(re, this.onMouseMove) } detachEvents() { var e; const { container: t } = this; t.removeEventListener("click", this.onClick, { passive: !1, capture: !1 }), t.removeEventListener("wheel", this.onWheel, { passive: !1 }), null === (e = this.pointerTracker) || void 0 === e || e.stop(), this.pointerTracker = null, document.removeEventListener(re, this.onMouseMove), document.removeEventListener("keydown", this.onKeydown, !0), this.clickTimer && (clearTimeout(this.clickTimer), this.clickTimer = null), this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null) } animate() { const e = this.friction; this.setTargetForce(); const t = this.option("maxVelocity"); for (const i of J) e ? (this.velocity[i] *= 1 - e, t && !this.isScaling && (this.velocity[i] = Math.max(Math.min(this.velocity[i], t), -1 * t)), this.current[i] += this.velocity[i]) : this.current[i] = this.target[i]; this.setTransform(), this.setEdgeForce(), !this.isResting || this.isDragging ? this.rAF = requestAnimationFrame((() => this.animate())) : this.stop("current") } setTargetForce() { for (const e of J) "e" === e && this.isBouncingX || "f" === e && this.isBouncingY || (this.velocity[e] = (1 / (1 - this.friction) - 1) * (this.target[e] - this.current[e])) } checkBounds(e = 0, t = 0) { const { current: i } = this, s = i.e + e, n = i.f + t, o = this.getBounds(), { x: a, y: r } = o, l = a.min, c = a.max, u = r.min, d = r.max; let h = 0, p = 0; return l !== 1 / 0 && s < l ? h = l - s : c !== 1 / 0 && s > c && (h = c - s), u !== 1 / 0 && n < u ? p = u - n : d !== 1 / 0 && n > d && (p = d - n), Math.abs(h) < .001 && (h = 0), Math.abs(p) < .001 && (p = 0), Object.assign(Object.assign({}, o), { xDiff: h, yDiff: p, inBounds: !h && !p }) } clampTargetBounds() { const { target: e } = this, { x: t, y: i } = this.getBounds(); t.min !== 1 / 0 && (e.e = Math.max(e.e, t.min)), t.max !== 1 / 0 && (e.e = Math.min(e.e, t.max)), i.min !== 1 / 0 && (e.f = Math.max(e.f, i.min)), i.max !== 1 / 0 && (e.f = Math.min(e.f, i.max)) } calculateContentDim(e = this.current) { const { content: t, contentRect: i } = this, { fitWidth: s, fitHeight: n, fullWidth: o, fullHeight: a } = i; let r = o, l = a; if (this.option("zoom") || 0 !== this.angle) { const i = !(t instanceof HTMLImageElement || "none" !== window.getComputedStyle(t).maxWidth && "none" !== window.getComputedStyle(t).maxHeight), c = i ? o : s, u = i ? a : n, d = this.getMatrix(e), h = new DOMPoint(0, 0).matrixTransform(d), p = new DOMPoint(0 + c, 0).matrixTransform(d), f = new DOMPoint(0 + c, 0 + u).matrixTransform(d), m = new DOMPoint(0, 0 + u).matrixTransform(d), g = Math.abs(f.x - h.x), v = Math.abs(f.y - h.y), b = Math.abs(m.x - p.x), y = Math.abs(m.y - p.y); r = Math.max(g, b), l = Math.max(v, y) } return { contentWidth: r, contentHeight: l } } setEdgeForce() { if (this.ignoreBounds || this.isDragging || this.panMode === re || this.targetScale < this.scale) return this.isBouncingX = !1, void (this.isBouncingY = !1); const { target: e } = this, { x: t, y: i, xDiff: s, yDiff: n } = this.checkBounds(), o = this.option("maxVelocity"); let a = this.velocity.e, r = this.velocity.f; 0 !== s ? (this.isBouncingX = !0, s * a <= 0 ? a += .14 * s : (a = .14 * s, t.min !== 1 / 0 && (this.target.e = Math.max(e.e, t.min)), t.max !== 1 / 0 && (this.target.e = Math.min(e.e, t.max))), o && (a = Math.max(Math.min(a, o), -1 * o))) : this.isBouncingX = !1, 0 !== n ? (this.isBouncingY = !0, n * r <= 0 ? r += .14 * n : (r = .14 * n, i.min !== 1 / 0 && (this.target.f = Math.max(e.f, i.min)), i.max !== 1 / 0 && (this.target.f = Math.min(e.f, i.max))), o && (r = Math.max(Math.min(r, o), -1 * o))) : this.isBouncingY = !1, this.isBouncingX && (this.velocity.e = a), this.isBouncingY && (this.velocity.f = r) } enable() { const { content: e } = this, t = new DOMMatrixReadOnly(window.getComputedStyle(e).transform); for (const e of J) this.current[e] = this.target[e] = t[e]; this.updateMetrics(), this.attachObserver(), this.attachEvents(), this.state = K.Ready, this.emit("ready") } onClick(e) { var t; this.isDragging && (null === (t = this.pointerTracker) || void 0 === t || t.clear(), this.trackingPoints = [], this.startDecelAnim()); const i = e.target; if (!i || e.defaultPrevented) return; if (i && i.hasAttribute("disabled")) return e.preventDefault(), void e.stopPropagation(); if ((() => { const e = window.getSelection(); return e && "Range" === e.type })() && !i.closest("button")) return; const s = i.closest("[data-panzoom-action]"), n = i.closest("[data-panzoom-change]"), o = s || n, a = o && ie(o) ? o.dataset : null; if (a) { const t = a.panzoomChange, i = a.panzoomAction; if ((t || i) && e.preventDefault(), t) { let i = {}; try { i = JSON.parse(t) } catch (e) { console && console.warn("The given data was not valid JSON") } return void this.applyChange(i) } if (i) return void (this[i] && this[i]()) } if (Math.abs(this.dragOffset.x) > 3 || Math.abs(this.dragOffset.y) > 3) return e.preventDefault(), void e.stopPropagation(); const r = this.content.getBoundingClientRect(); if (this.dragStart.time && !this.canZoomOut() && (Math.abs(r.x - this.dragStart.x) > 2 || Math.abs(r.y - this.dragStart.y) > 2)) return; this.dragStart.time = 0; const l = t => { this.option("zoom") && t && "string" == typeof t && /(iterateZoom)|(toggle(Zoom|Full|Cover|Max)|(zoomTo(Fit|Cover|Max)))/.test(t) && "function" == typeof this[t] && (e.preventDefault(), this[t]({ event: e })) }, c = this.option("click", e), u = this.option("dblClick", e); u ? (this.clicks++, 1 == this.clicks && (this.clickTimer = setTimeout((() => { 1 === this.clicks ? (this.emit("click", e), !e.defaultPrevented && c && l(c)) : (this.emit("dblClick", e), e.defaultPrevented || l(u)), this.clicks = 0, this.clickTimer = null }), 350))) : (this.emit("click", e), !e.defaultPrevented && c && l(c)) } addTrackingPoint(e) { const t = this.trackingPoints.filter((e => e.time > Date.now() - 100)); t.push(e), this.trackingPoints = t } onPointerDown(e, t, i) { var s; if (!1 === this.option("touch", e)) return !1; this.pwt = 0, this.dragOffset = { x: 0, y: 0, time: 0 }, this.trackingPoints = []; const n = this.content.getBoundingClientRect(); if (this.dragStart = { x: n.x, y: n.y, top: n.top, left: n.left, time: Date.now() }, this.clickTimer) return !1; if (this.panMode === re && this.targetScale > 1) return e.preventDefault(), e.stopPropagation(), !1; const o = e.composedPath()[0]; if (!i.length) { if (["TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO", "IFRAME"].includes(o.nodeName) || o.closest("[contenteditable]") || o.closest("[data-selectable]") || o.closest("[data-draggable]") || o.closest("[data-clickable]") || o.closest("[data-panzoom-change]") || o.closest("[data-panzoom-action]")) return !1; null === (s = window.getSelection()) || void 0 === s || s.removeAllRanges() } if ("mousedown" === e.type) ["A", "BUTTON"].includes(o.nodeName) || e.preventDefault(); else if (Math.abs(this.velocity.a) > .3) return !1; return this.target.e = this.current.e, this.target.f = this.current.f, this.stop(), this.isDragging || (this.isDragging = !0, this.addTrackingPoint(t), this.emit("touchStart", e)), !0 } onPointerMove(e, t, i) { if (!1 === this.option("touch", e)) return; if (!this.isDragging) return; if (t.length < 2 && this.panOnlyZoomed && I(this.targetScale) <= I(this.minScale)) return; if (this.emit("touchMove", e), e.defaultPrevented) return; this.addTrackingPoint(t[0]); const { content: s } = this, n = W(i[0], i[1]), o = W(t[0], t[1]); let a = 0, r = 0; if (t.length > 1) { const e = s.getBoundingClientRect(); a = n.clientX - e.left - .5 * e.width, r = n.clientY - e.top - .5 * e.height } const l = q(i[0], i[1]), c = q(t[0], t[1]); let u = l ? c / l : 1, d = o.clientX - n.clientX, h = o.clientY - n.clientY; this.dragOffset.x += d, this.dragOffset.y += h, this.dragOffset.time = Date.now() - this.dragStart.time; let p = I(this.targetScale) === I(this.minScale) && this.option("lockAxis"); if (p && !this.lockedAxis) if ("xy" === p || "y" === p || "touchmove" === e.type) { if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) return void e.preventDefault(); const t = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI); this.lockedAxis = t > 45 && t < 135 ? "y" : "x", this.dragOffset.x = 0, this.dragOffset.y = 0, d = 0, h = 0 } else this.lockedAxis = p; if (z(e.target, this.content) && (p = "x", this.dragOffset.y = 0), p && "xy" !== p && this.lockedAxis !== p && I(this.targetScale) === I(this.minScale)) return; e.cancelable && e.preventDefault(), this.container.classList.add(this.cn("isDragging")); const f = this.checkBounds(d, h); this.option("rubberband") ? ("x" !== this.isInfinite && (f.xDiff > 0 && d < 0 || f.xDiff < 0 && d > 0) && (d *= Math.max(0, .5 - Math.abs(.75 / this.contentRect.fitWidth * f.xDiff))), "y" !== this.isInfinite && (f.yDiff > 0 && h < 0 || f.yDiff < 0 && h > 0) && (h *= Math.max(0, .5 - Math.abs(.75 / this.contentRect.fitHeight * f.yDiff)))) : (f.xDiff && (d = 0), f.yDiff && (h = 0)); const m = this.targetScale, g = this.minScale, v = this.maxScale; m < .5 * g && (u = Math.max(u, g)), m > 1.5 * v && (u = Math.min(u, v)), "y" === this.lockedAxis && I(m) === I(g) && (d = 0), "x" === this.lockedAxis && I(m) === I(g) && (h = 0), this.applyChange({ originX: a, originY: r, panX: d, panY: h, scale: u, friction: this.option("dragFriction"), ignoreBounds: !0 }) } onPointerUp(e, t, i) { if (i.length) return this.dragOffset.x = 0, this.dragOffset.y = 0, void (this.trackingPoints = []); this.container.classList.remove(this.cn("isDragging")), this.isDragging && (this.addTrackingPoint(t), this.panOnlyZoomed && this.contentRect.width - this.contentRect.fitWidth < 1 && this.contentRect.height - this.contentRect.fitHeight < 1 && (this.trackingPoints = []), z(e.target, this.content) && "y" === this.lockedAxis && (this.trackingPoints = []), this.emit("touchEnd", e), this.isDragging = !1, this.lockedAxis = !1, this.state !== K.Destroy && (e.defaultPrevented || this.startDecelAnim())) } startDecelAnim() { var e; const t = this.isScaling; this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = !1, this.isBouncingY = !1; for (const e of J) this.velocity[e] = 0; this.target.e = this.current.e, this.target.f = this.current.f, se(this.container, "is-scaling"), se(this.container, "is-animating"), this.isTicking = !1; const { trackingPoints: i } = this, s = i[0], n = i[i.length - 1]; let o = 0, a = 0, r = 0; n && s && (o = n.clientX - s.clientX, a = n.clientY - s.clientY, r = n.time - s.time); const l = (null === (e = window.visualViewport) || void 0 === e ? void 0 : e.scale) || 1; 1 !== l && (o *= l, a *= l); let c = 0, u = 0, d = 0, h = 0, p = this.option("decelFriction"); const f = this.targetScale; if (r > 0) { d = Math.abs(o) > 3 ? o / (r / 30) : 0, h = Math.abs(a) > 3 ? a / (r / 30) : 0; const e = this.option("maxVelocity"); e && (d = Math.max(Math.min(d, e), -1 * e), h = Math.max(Math.min(h, e), -1 * e)) } d && (c = d / (1 / (1 - p) - 1)), h && (u = h / (1 / (1 - p) - 1)), ("y" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "y" === this.lockedAxis && I(f) === this.minScale) && (c = d = 0), ("x" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "x" === this.lockedAxis && I(f) === this.minScale) && (u = h = 0); const m = this.dragOffset.x, g = this.dragOffset.y, v = this.option("dragMinThreshold") || 0; Math.abs(m) < v && Math.abs(g) < v && (c = u = 0, d = h = 0), (f < this.minScale - 1e-5 || f > this.maxScale + 1e-5 || t && !c && !u) && (p = .35), this.applyChange({ panX: c, panY: u, friction: p }), this.emit("decel", d, h, m, g) } onWheel(e) { var t = [-e.deltaX || 0, -e.deltaY || 0, -e.detail || 0].reduce((function (e, t) { return Math.abs(t) > Math.abs(e) ? t : e })); const i = Math.max(-1, Math.min(1, t)); if (this.emit("wheel", e, i), this.panMode === re) return; if (e.defaultPrevented) return; const s = this.option("wheel"); "pan" === s ? (e.preventDefault(), this.panOnlyZoomed && !this.canZoomOut() || this.applyChange({ panX: 2 * -e.deltaX, panY: 2 * -e.deltaY, bounce: !1 })) : "zoom" === s && !1 !== this.option("zoom") && this.zoomWithWheel(e) } onMouseMove(e) { this.panWithMouse(e) } onKeydown(e) { "Escape" === e.key && this.toggleFS() } onResize() { this.updateMetrics(), this.checkBounds().inBounds || this.requestTick() } setTransform() { this.emit("beforeTransform"); const { current: e, target: t, content: i, contentRect: s } = this, n = Object.assign({}, oe); for (const i of J) { const s = "e" == i || "f" === i ? ae : 1e5; n[i] = I(e[i], s), Math.abs(t[i] - e[i]) < ("e" == i || "f" === i ? .51 : .001) && (e[i] = t[i]) } let { a: o, b: a, c: r, d: l, e: c, f: u } = n, d = `matrix(${o}, ${a}, ${r}, ${l}, ${c}, ${u})`, h = i.parentElement instanceof HTMLPictureElement ? i.parentElement : i; if (this.option("transformParent") && (h = h.parentElement || h), h.style.transform === d) return; h.style.transform = d; const { contentWidth: p, contentHeight: f } = this.calculateContentDim(); s.width = p, s.height = f, this.emit("afterTransform") } updateMetrics(e = !1) { var t; if (!this || this.state === K.Destroy) return; if (this.isContentLoading) return; const i = Math.max(1, (null === (t = window.visualViewport) || void 0 === t ? void 0 : t.scale) || 1), { container: s, content: n } = this, o = n instanceof HTMLImageElement, a = s.getBoundingClientRect(), r = getComputedStyle(this.container); let l = a.width * i, c = a.height * i; const u = parseFloat(r.paddingTop) + parseFloat(r.paddingBottom), d = l - (parseFloat(r.paddingLeft) + parseFloat(r.paddingRight)), h = c - u; this.containerRect = { width: l, height: c, innerWidth: d, innerHeight: h }; let p = this.option("width") || "auto", f = this.option("height") || "auto"; "auto" === p && (p = parseFloat(n.dataset.width || "") || (e => { let t = 0; return t = e instanceof HTMLImageElement ? e.naturalWidth : e instanceof SVGElement ? e.width.baseVal.value : Math.max(e.offsetWidth, e.scrollWidth), t || 0 })(n)), "auto" === f && (f = parseFloat(n.dataset.height || "") || (e => { let t = 0; return t = e instanceof HTMLImageElement ? e.naturalHeight : e instanceof SVGElement ? e.height.baseVal.value : Math.max(e.offsetHeight, e.scrollHeight), t || 0 })(n)); let m = n.parentElement instanceof HTMLPictureElement ? n.parentElement : n; this.option("transformParent") && (m = m.parentElement || m); const g = m.getAttribute("style") || ""; m.style.setProperty("transform", "none", "important"), o && (m.style.width = "", m.style.height = ""), m.offsetHeight; const v = n.getBoundingClientRect(); let b = v.width * i, y = v.height * i, w = 0, E = 0; o && (Math.abs(p - b) > 1 || Math.abs(f - y) > 1) && ({ width: b, height: y, top: w, left: E } = ((e, t, i, s) => { const n = i / s; return n > e / t ? (i = e, s = e / n) : (i = t * n, s = t), { width: i, height: s, top: .5 * (t - s), left: .5 * (e - i) } })(b, y, p, f)), this.contentRect = Object.assign(Object.assign({}, this.contentRect), { top: v.top - a.top + w, bottom: a.bottom - v.bottom + w, left: v.left - a.left + E, right: a.right - v.right + E, fitWidth: b, fitHeight: y, width: b, height: y, fullWidth: p, fullHeight: f }), m.style.cssText = g, o && (m.style.width = `${b}px`, m.style.height = `${y}px`), this.setTransform(), !0 !== e && this.emit("refresh"), this.ignoreBounds || (I(this.targetScale) < I(this.minScale) ? this.zoomTo(this.minScale, { friction: 0 }) : this.targetScale > this.maxScale ? this.zoomTo(this.maxScale, { friction: 0 }) : this.state === K.Init || this.checkBounds().inBounds || this.requestTick()), this.updateControls() } getBounds() { const e = this.option("bounds"); if ("auto" !== e) return e; const { contentWidth: t, contentHeight: i } = this.calculateContentDim(this.target); let s = 0, n = 0, o = 0, a = 0; const r = this.option("infinite"); if (!0 === r || this.lockedAxis && r === this.lockedAxis) s = -1 / 0, o = 1 / 0, n = -1 / 0, a = 1 / 0; else { let { containerRect: e, contentRect: r } = this, l = I(this.contentRect.fitWidth * this.targetScale, ae), c = I(this.contentRect.fitHeight * this.targetScale, ae), { innerWidth: u, innerHeight: d } = e; if (this.containerRect.width === l && (u = e.width), this.containerRect.width === c && (d = e.height), t > u) { o = .5 * (t - u), s = -1 * o; let e = .5 * (r.right - r.left); s += e, o += e } if (this.contentRect.fitWidth > u && t < u && (s -= .5 * (this.contentRect.fitWidth - u), o -= .5 * (this.contentRect.fitWidth - u)), i > d) { a = .5 * (i - d), n = -1 * a; let e = .5 * (r.bottom - r.top); n += e, a += e } this.contentRect.fitHeight > d && i < d && (s -= .5 * (this.contentRect.fitHeight - d), o -= .5 * (this.contentRect.fitHeight - d)) } return { x: { min: s, max: o }, y: { min: n, max: a } } } updateControls() { const e = this, t = e.container, { panMode: i, contentRect: s, fullScale: n, targetScale: o, coverScale: a, maxScale: r, minScale: l } = e; let c = { toggleMax: o - l < .5 * (r - l) ? r : l, toggleCover: o - l < .5 * (a - l) ? a : l, toggleZoom: o - l < .5 * (n - l) ? n : l }[e.option("click") || ""] || l, u = e.canZoomIn(), d = e.canZoomOut(), h = i === le && !!this.option("touch"), p = d && h; h && (I(o) < I(l) && !this.panOnlyZoomed && (p = !0), (I(s.width, 1) > I(s.fitWidth, 1) || I(s.height, 1) > I(s.fitHeight, 1)) && (p = !0)), I(s.width * o, 1) < I(s.fitWidth, 1) && (p = !1), i === re && (p = !1); let f = u && I(c) > I(o), m = !f && !p && d && I(c) < I(o); V(t, this.cn("canZoomIn"), f), V(t, this.cn("canZoomOut"), m), V(t, this.cn("isDraggable"), p); for (const e of t.querySelectorAll('[data-panzoom-action="zoomIn"]')) u ? (e.removeAttribute("disabled"), e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", "-1")); for (const e of t.querySelectorAll('[data-panzoom-action="zoomOut"]')) d ? (e.removeAttribute("disabled"), e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", "-1")); for (const e of t.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) { u || d ? (e.removeAttribute("disabled"), e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", "-1")); const t = e.querySelector("g"); t && (t.style.display = u ? "" : "none") } } panTo({ x: e = this.target.e, y: t = this.target.f, scale: i = this.targetScale, friction: s = this.option("friction"), angle: n = 0, originX: o = 0, originY: a = 0, flipX: r = !1, flipY: l = !1, ignoreBounds: c = !1 }) { this.state !== K.Destroy && this.applyChange({ panX: e - this.target.e, panY: t - this.target.f, scale: i / this.targetScale, angle: n, originX: o, originY: a, friction: s, flipX: r, flipY: l, ignoreBounds: c }) } applyChange({ panX: e = 0, panY: t = 0, scale: i = 1, angle: s = 0, originX: n = -this.current.e, originY: o = -this.current.f, friction: a = this.option("friction"), flipX: r = !1, flipY: l = !1, ignoreBounds: c = !1, bounce: u = this.option("bounce") }) { if (this.state === K.Destroy) return; this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.friction = a || 0, this.ignoreBounds = c; const { current: d } = this, h = d.e, p = d.f, f = this.getMatrix(this.target); let m = (new DOMMatrix).translate(h, p).translate(n, o).translate(e, t); if (this.option("zoom")) { if (!c) { const e = this.targetScale, t = this.minScale, s = this.maxScale; e * i < t && (i = t / e), e * i > s && (i = s / e) } m = m.scale(i) } m = m.translate(-n, -o).translate(-h, -p).multiply(f), s && (m = m.rotate(s)), r && (m = m.scale(-1, 1)), l && (m = m.scale(1, -1)); for (const e of J) "e" !== e && "f" !== e && (m[e] > this.minScale + 1e-5 || m[e] < this.minScale - 1e-5) ? this.target[e] = m[e] : this.target[e] = I(m[e], ae); (this.targetScale < this.scale || Math.abs(i - 1) > .1 || this.panMode === re || !1 === u) && !c && this.clampTargetBounds(), this.isResting || (this.state = K.Panning, this.requestTick()) } stop(e = !1) { if (this.state === K.Init || this.state === K.Destroy) return; const t = this.isTicking; this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = !1, this.isBouncingY = !1; for (const t of J) this.velocity[t] = 0, "current" === e ? this.current[t] = this.target[t] : "target" === e && (this.target[t] = this.current[t]); this.setTransform(), se(this.container, "is-scaling"), se(this.container, "is-animating"), this.isTicking = !1, this.state = K.Ready, t && (this.emit("endAnimation"), this.updateControls()) } requestTick() { this.isTicking || (this.emit("startAnimation"), this.updateControls(), ne(this.container, "is-animating"), this.isScaling && ne(this.container, "is-scaling")), this.isTicking = !0, this.rAF || (this.rAF = requestAnimationFrame((() => this.animate()))) } panWithMouse(e, t = this.option("mouseMoveFriction")) { if (this.pmme = e, this.panMode !== re || !e) return; if (I(this.targetScale) <= I(this.minScale)) return; this.emit("mouseMove", e); const { container: i, containerRect: s, contentRect: n } = this, o = s.width, a = s.height, r = i.getBoundingClientRect(), l = (e.clientX || 0) - r.left, c = (e.clientY || 0) - r.top; let { contentWidth: u, contentHeight: d } = this.calculateContentDim(this.target); const h = this.option("mouseMoveFactor"); h > 1 && (u !== o && (u *= h), d !== a && (d *= h)); let p = .5 * (u - o) - l / o * 100 / 100 * (u - o); p += .5 * (n.right - n.left); let f = .5 * (d - a) - c / a * 100 / 100 * (d - a); f += .5 * (n.bottom - n.top), this.applyChange({ panX: p - this.target.e, panY: f - this.target.f, friction: t }) } zoomWithWheel(e) { if (this.state === K.Destroy || this.state === K.Init) return; const t = Date.now(); if (t - this.pwt < 45) return void e.preventDefault(); this.pwt = t; var i = [-e.deltaX || 0, -e.deltaY || 0, -e.detail || 0].reduce((function (e, t) { return Math.abs(t) > Math.abs(e) ? t : e })); const s = Math.max(-1, Math.min(1, i)), { targetScale: n, maxScale: o, minScale: a } = this; let r = n * (100 + 45 * s) / 100; I(r) < I(a) && I(n) <= I(a) ? (this.cwd += Math.abs(s), r = a) : I(r) > I(o) && I(n) >= I(o) ? (this.cwd += Math.abs(s), r = o) : (this.cwd = 0, r = Math.max(Math.min(r, o), a)), this.cwd > this.option("wheelLimit") || (e.preventDefault(), I(r) !== I(n) && this.zoomTo(r, { event: e })) } canZoomIn() { return this.option("zoom") && (I(this.contentRect.width, 1) < I(this.contentRect.fitWidth, 1) || I(this.targetScale) < I(this.maxScale)) } canZoomOut() { return this.option("zoom") && I(this.targetScale) > I(this.minScale) } zoomIn(e = 1.25, t) { this.zoomTo(this.targetScale * e, t) } zoomOut(e = .8, t) { this.zoomTo(this.targetScale * e, t) } zoomToFit(e) { this.zoomTo("fit", e) } zoomToCover(e) { this.zoomTo("cover", e) } zoomToFull(e) { this.zoomTo("full", e) } zoomToMax(e) { this.zoomTo("max", e) } toggleZoom(e) { this.zoomTo(this.targetScale - this.minScale < .5 * (this.fullScale - this.minScale) ? "full" : "fit", e) } toggleMax(e) { this.zoomTo(this.targetScale - this.minScale < .5 * (this.maxScale - this.minScale) ? "max" : "fit", e) } toggleCover(e) { this.zoomTo(this.targetScale - this.minScale < .5 * (this.coverScale - this.minScale) ? "cover" : "fit", e) } iterateZoom(e) { this.zoomTo("next", e) } zoomTo(e = 1, { friction: t = "auto", originX: i = "auto", originY: s = "auto", event: n } = {}) { if (this.isContentLoading || this.state === K.Destroy) return; const { targetScale: o } = this; this.stop(); let a = 1; if (this.panMode === re && (n = this.pmme || n), n || "auto" === i || "auto" === s) { const e = this.content.getBoundingClientRect(), t = this.container.getBoundingClientRect(), o = n ? n.clientX : t.left + .5 * t.width, a = n ? n.clientY : t.top + .5 * t.height; i = o - e.left - .5 * e.width, s = a - e.top - .5 * e.height } const r = this.fullScale, l = this.maxScale; let c = this.coverScale; "number" == typeof e ? a = e / o : ("next" === e && (r - c < .2 && (c = r), e = o < r - 1e-5 ? "full" : o < l - 1e-5 ? "max" : "fit"), a = "full" === e ? r / o || 1 : "cover" === e ? c / o || 1 : "max" === e ? l / o || 1 : 1 / o || 1), t = "auto" === t ? a > 1 ? .15 : .25 : t, this.applyChange({ scale: a, originX: i, originY: s, friction: t }), n && this.panMode === re && this.panWithMouse(n, t) } rotateCCW() { this.applyChange({ angle: -90 }) } rotateCW() { this.applyChange({ angle: 90 }) } flipX() { this.applyChange({ flipX: !0 }) } flipY() { this.applyChange({ flipY: !0 }) } fitX() { this.stop("target"); const { containerRect: e, contentRect: t, target: i } = this; this.applyChange({ panX: .5 * e.width - (t.left + .5 * t.fitWidth) - i.e, panY: .5 * e.height - (t.top + .5 * t.fitHeight) - i.f, scale: e.width / t.fitWidth / this.targetScale, originX: 0, originY: 0, ignoreBounds: !0 }) } fitY() { this.stop("target"); const { containerRect: e, contentRect: t, target: i } = this; this.applyChange({ panX: .5 * e.width - (t.left + .5 * t.fitWidth) - i.e, panY: .5 * e.innerHeight - (t.top + .5 * t.fitHeight) - i.f, scale: e.height / t.fitHeight / this.targetScale, originX: 0, originY: 0, ignoreBounds: !0 }) } toggleFS() { const { container: e } = this, t = this.cn("inFullscreen"), i = this.cn("htmlHasFullscreen"); e.classList.toggle(t); const s = e.classList.contains(t); s ? (document.documentElement.classList.add(i), document.addEventListener("keydown", this.onKeydown, !0)) : (document.documentElement.classList.remove(i), document.removeEventListener("keydown", this.onKeydown, !0)), this.updateMetrics(), this.emit(s ? "enterFS" : "exitFS") } getMatrix(e = this.current) { const { a: t, b: i, c: s, d: n, e: o, f: a } = e; return new DOMMatrix([t, i, s, n, o, a]) } reset(e) { if (this.state !== K.Init && this.state !== K.Destroy) { this.stop("current"); for (const e of J) this.target[e] = oe[e]; this.target.a = this.minScale, this.target.d = this.minScale, this.clampTargetBounds(), this.isResting || (this.friction = void 0 === e ? this.option("friction") : e, this.state = K.Panning, this.requestTick()) } } destroy() { this.stop(), this.state = K.Destroy, this.detachEvents(), this.detachObserver(); const { container: e, content: t } = this, i = this.option("classes") || {}; for (const t of Object.values(i)) e.classList.remove(t + ""); t && (t.removeEventListener("load", this.onLoad), t.removeEventListener("error", this.onError)), this.detachPlugins() } } Object.defineProperty(he, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: ee }), Object.defineProperty(he, "Plugins", { enumerable: !0, configurable: !0, writable: !0, value: {} }); const pe = function (e, t) { let i = !0; return (...s) => { i && (i = !1, e(...s), setTimeout((() => { i = !0 }), t)) } }, fe = (e, t) => { let i = []; return e.childNodes.forEach((e => { e.nodeType !== Node.ELEMENT_NODE || t && !e.matches(t) || i.push(e) })), i }; var me; !function (e) { e[e.Init = 0] = "Init", e[e.Ready = 1] = "Ready", e[e.Destroy = 2] = "Destroy" }(me || (me = {})); const ge = e => { if ("string" == typeof e || e instanceof HTMLElement) e = { html: e }; else { const t = e.thumb; void 0 !== t && ("string" == typeof t && (e.thumbSrc = t), t instanceof HTMLImageElement && (e.thumbEl = t, e.thumbElSrc = t.src, e.thumbSrc = t.src), delete e.thumb) } return Object.assign({ html: "", el: null, isDom: !1, class: "", customClass: "", index: -1, dim: 0, gap: 0, pos: 0, transition: !1 }, e) }, ve = (e = {}) => Object.assign({ index: -1, slides: [], dim: 0, pos: -1 }, e); class be extends U { constructor(e, t) { super(t), Object.defineProperty(this, "instance", { enumerable: !0, configurable: !0, writable: !0, value: e }) } attach() { } detach() { } } class ye extends be { constructor() { super(...arguments), Object.defineProperty(this, "isDynamic", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "list", { enumerable: !0, configurable: !0, writable: !0, value: null }) } onRefresh() { this.refresh() } build() { let e = this.list; return e || (e = document.createElement("ul"), ne(e, this.cn("list")), e.setAttribute("role", "tablist"), this.instance.container.appendChild(e), ne(this.instance.container, this.cn("hasDots")), this.list = e), e } refresh() { var e; const t = this.instance.pages.length, i = Math.min(2, this.option("minCount")), s = Math.max(2e3, this.option("maxCount")), n = this.option("dynamicFrom"); if (t < i || t > s) return void this.cleanup(); const o = "number" == typeof n && t > 5 && t >= n, a = !this.list || this.isDynamic !== o || this.list.children.length !== t; a && this.cleanup(); const r = this.build(); if (V(r, this.cn("isDynamic"), !!o), a) for (let e = 0; e < t; e++)r.append(this.createItem(e)); let l, c = 0; for (const t of [...r.children]) { const i = c === this.instance.page; i && (l = t), V(t, this.cn("isCurrent"), i), null === (e = t.children[0]) || void 0 === e || e.setAttribute("aria-selected", i ? "true" : "false"); for (const e of ["isBeforePrev", "isPrev", "isNext", "isAfterNext"]) se(t, this.cn(e)); c++ } if (l = l || r.firstChild, o && l) { const e = l.previousElementSibling, t = e && e.previousElementSibling; ne(e, this.cn("isPrev")), ne(t, this.cn("isBeforePrev")); const i = l.nextElementSibling, s = i && i.nextElementSibling; ne(i, this.cn("isNext")), ne(s, this.cn("isAfterNext")) } this.isDynamic = o } createItem(e = 0) { var t; const i = document.createElement("li"); i.setAttribute("role", "presentation"); const s = R(this.instance.localize(this.option("dotTpl"), [["%d", e + 1]]).replace(/\%i/g, e + "")); return i.appendChild(s), null === (t = i.children[0]) || void 0 === t || t.setAttribute("role", "tab"), i } cleanup() { this.list && (this.list.remove(), this.list = null), this.isDynamic = !1, se(this.instance.container, this.cn("hasDots")) } attach() { this.instance.on(["refresh", "change"], this.onRefresh) } detach() { this.instance.off(["refresh", "change"], this.onRefresh), this.cleanup() } } Object.defineProperty(ye, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: { classes: { list: "f-carousel__dots", isDynamic: "is-dynamic", hasDots: "has-dots", dot: "f-carousel__dot", isBeforePrev: "is-before-prev", isPrev: "is-prev", isCurrent: "is-current", isNext: "is-next", isAfterNext: "is-after-next" }, dotTpl: '<button type="button" data-carousel-page="%i" aria-label="{{GOTO}}"><span class="f-carousel__dot" aria-hidden="true"></span></button>', dynamicFrom: 11, maxCount: 1 / 0, minCount: 2 } }); const we = "disabled", Ee = "next", Se = "prev"; class Ce extends be { constructor() { super(...arguments), Object.defineProperty(this, "container", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "prev", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "next", { enumerable: !0, configurable: !0, writable: !0, value: null }) } onRefresh() { const e = this.instance, t = e.pages.length, i = e.page; if (t < 2) return void this.cleanup(); this.build(); let s = this.prev, n = this.next; s && n && (s.removeAttribute(we), n.removeAttribute(we), e.isInfinite || (i <= 0 && s.setAttribute(we, ""), i >= t - 1 && n.setAttribute(we, ""))) } createButton(e) { const t = this.instance, i = document.createElement("button"); i.setAttribute("tabindex", "0"), i.setAttribute("title", t.localize(`{{${e.toUpperCase()}}}`)), ne(i, this.cn("button") + " " + this.cn(e === Ee ? "isNext" : "isPrev")); const s = t.isRTL ? e === Ee ? Se : Ee : e; var n; return i.innerHTML = t.localize(this.option(`${s}Tpl`)), i.dataset[`carousel${n = e, n ? n.match("^[a-z]") ? n.charAt(0).toUpperCase() + n.substring(1) : n : ""}`] = "true", i } build() { let e = this.container; e || (this.container = e = document.createElement("div"), ne(e, this.cn("container")), this.instance.container.appendChild(e)), this.next || (this.next = e.appendChild(this.createButton(Ee))), this.prev || (this.prev = e.appendChild(this.createButton(Se))) } cleanup() { this.prev && this.prev.remove(), this.next && this.next.remove(), this.container && this.container.remove(), this.prev = null, this.next = null, this.container = null } attach() { this.instance.on(["refresh", "change"], this.onRefresh) } detach() { this.instance.off(["refresh", "change"], this.onRefresh), this.cleanup() } } Object.defineProperty(Ce, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: { classes: { container: "f-carousel__nav", button: "f-button", isNext: "is-next", isPrev: "is-prev" }, nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>', prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>' } }); class xe extends be { constructor() { super(...arguments), Object.defineProperty(this, "selectedIndex", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "target", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "nav", { enumerable: !0, configurable: !0, writable: !0, value: null }) } addAsTargetFor(e) { this.target = this.instance, this.nav = e, this.attachEvents() } addAsNavFor(e) { this.nav = this.instance, this.target = e, this.attachEvents() } attachEvents() { this.nav && this.target && (this.nav.options.initialSlide = this.target.options.initialPage, this.nav.on("ready", this.onNavReady), this.nav.state === me.Ready && this.onNavReady(this.nav), this.target.on("ready", this.onTargetReady), this.target.state === me.Ready && this.onTargetReady(this.target)) } onNavReady(e) { e.on("createSlide", this.onNavCreateSlide), e.on("Panzoom.click", this.onNavClick), e.on("Panzoom.touchEnd", this.onNavTouch), this.onTargetChange() } onTargetReady(e) { e.on("change", this.onTargetChange), e.on("Panzoom.refresh", this.onTargetChange), this.onTargetChange() } onNavClick(e, t, i) { this.onNavTouch(e, e.panzoom, i) } onNavTouch(e, t, i) { var s, n; if (Math.abs(t.dragOffset.x) > 3 || Math.abs(t.dragOffset.y) > 3) return; const o = i.target, { nav: a, target: r } = this; if (!a || !r || !o) return; const l = o.closest("[data-index]"); if (i.stopPropagation(), i.preventDefault(), !l) return; const c = parseInt(l.dataset.index || "", 10) || 0, u = r.getPageForSlide(c), d = a.getPageForSlide(c); a.slideTo(d), r.slideTo(u, { friction: (null === (n = null === (s = this.nav) || void 0 === s ? void 0 : s.plugins) || void 0 === n ? void 0 : n.Sync.option("friction")) || 0 }), this.markSelectedSlide(c) } onNavCreateSlide(e, t) { t.index === this.selectedIndex && this.markSelectedSlide(t.index) } onTargetChange() { const { target: e, nav: t } = this; if (!e || !t) return; if (t.state !== me.Ready || e.state !== me.Ready) return; const i = e.pages[e.page].slides[0].index, s = t.getPageForSlide(i); this.markSelectedSlide(i), t.slideTo(s) } markSelectedSlide(e) { const t = this.nav; t && t.state === me.Ready && (this.selectedIndex = e, [...t.slides].map((t => { t.el && t.el.classList[t.index === e ? "add" : "remove"]("is-nav-selected") }))) } attach() { const e = this; let t = e.options.target, i = e.options.nav; t ? e.addAsNavFor(t) : i && e.addAsTargetFor(i) } detach() { const e = this, t = e.nav, i = e.target; t && (t.off("ready", e.onNavReady), t.off("createSlide", e.onNavCreateSlide), t.off("Panzoom.click", e.onNavClick), t.off("Panzoom.touchEnd", e.onNavTouch)), e.nav = null, i && (i.off("ready", e.onTargetReady), i.off("refresh", e.onTargetChange), i.off("change", e.onTargetChange)), e.target = null } } Object.defineProperty(xe, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: { friction: .35 } }); const ke = { Navigation: Ce, Dots: ye, Sync: xe }; class Te extends Z { get axis() { return this.isHorizontal ? "e" : "f" } get isEnabled() { return this.state === me.Ready } get isInfinite() { let e = !1; const { contentDim: t, viewportDim: i, pages: s, slides: n } = this; return s.length >= 2 && t + n[0].dim >= i && (e = this.option("infinite")), e } get isRTL() { return "rtl" === this.option("direction") } get isHorizontal() { return "x" === this.option("axis") } constructor(e, t = {}, i = {}) { if (super(), Object.defineProperty(this, "userOptions", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "userPlugins", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "bp", { enumerable: !0, configurable: !0, writable: !0, value: "" }), Object.defineProperty(this, "lp", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "state", { enumerable: !0, configurable: !0, writable: !0, value: me.Init }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "prevPage", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "container", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "viewport", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "track", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "slides", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "pages", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "panzoom", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "inTransition", { enumerable: !0, configurable: !0, writable: !0, value: new Set }), Object.defineProperty(this, "contentDim", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "viewportDim", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), "string" == typeof e && (e = document.querySelector(e)), !e || !ie(e)) throw new Error("No Element found"); this.container = e, this.slideNext = pe(this.slideNext.bind(this), 150), this.slidePrev = pe(this.slidePrev.bind(this), 150), this.userOptions = t, this.userPlugins = i, queueMicrotask((() => { this.processOptions() })) } processOptions() { const e = X({}, Te.defaults, this.userOptions); let t = ""; const i = e.breakpoints; if (i && G(i)) for (const [s, n] of Object.entries(i)) window.matchMedia(s).matches && G(n) && (t += s, X(e, n)); t === this.bp && this.state !== me.Init || (this.bp = t, this.state === me.Ready && (e.initialSlide = this.pages[this.page].slides[0].index), this.state !== me.Init && this.destroy(), super.setOptions(e), !1 === this.option("enabled") ? this.attachEvents() : setTimeout((() => { this.init() }), 0)) } init() { this.state = me.Init, this.emit("init"), this.attachPlugins(Object.assign(Object.assign({}, Te.Plugins), this.userPlugins)), this.initLayout(), this.initSlides(), this.updateMetrics(), this.setInitialPosition(), this.initPanzoom(), this.attachEvents(), this.state = me.Ready, this.emit("ready") } initLayout() { const { container: e } = this, t = this.option("classes"); ne(e, this.cn("container")), V(e, t.isLTR, !this.isRTL), V(e, t.isRTL, this.isRTL), V(e, t.isVertical, !this.isHorizontal), V(e, t.isHorizontal, this.isHorizontal); let i = this.option("viewport") || e.querySelector(`.${t.viewport}`); i || (i = document.createElement("div"), ne(i, t.viewport), i.append(...fe(e, `.${t.slide}`)), e.prepend(i)); let s = this.option("track") || e.querySelector(`.${t.track}`); s || (s = document.createElement("div"), ne(s, t.track), s.append(...Array.from(i.childNodes))), s.setAttribute("aria-live", "polite"), i.contains(s) || i.prepend(s), this.viewport = i, this.track = s, this.emit("initLayout") } initSlides() { const { track: e } = this; if (e) { this.slides = [], [...fe(e, `.${this.cn("slide")}`)].forEach((e => { if (ie(e)) { const t = ge({ el: e, isDom: !0, index: this.slides.length }); this.slides.push(t), this.emit("initSlide", t, this.slides.length) } })); for (let e of this.option("slides", [])) { const t = ge(e); t.index = this.slides.length, this.slides.push(t), this.emit("initSlide", t, this.slides.length) } this.emit("initSlides") } } setInitialPage() { let e = 0; const t = this.option("initialSlide"); e = "number" == typeof t ? this.getPageForSlide(t) : parseInt(this.option("initialPage", 0) + "", 10) || 0, this.page = e } setInitialPosition() { if (!this.track || !this.pages.length) return; const e = this.isHorizontal; let t = this.page; this.pages[t] || (this.page = t = 0); const i = this.pages[t].pos * (this.isRTL && e ? 1 : -1), s = e ? `${i}px` : "0", n = e ? "0" : `${i}px`; this.track.style.transform = `translate3d(${s}, ${n}, 0) scale(1)`, this.option("adaptiveHeight") && this.setViewportHeight() } initPanzoom() { this.panzoom && (this.panzoom.destroy(), this.panzoom = null); const e = this.option("Panzoom") || {}; this.panzoom = new he(this.viewport, X({}, { content: this.track, zoom: !1, panOnlyZoomed: !1, lockAxis: this.isHorizontal ? "x" : "y", infinite: this.isInfinite, click: !1, dblClick: !1, touch: e => !(this.pages.length < 2 && !e.options.infinite), bounds: () => this.getBounds(), maxVelocity: e => Math.abs(e.target[this.axis] - e.current[this.axis]) < 2 * this.viewportDim ? 100 : 0 }, e)), this.panzoom.on("*", ((e, t, ...i) => { this.emit(`Panzoom.${t}`, e, ...i) })), this.panzoom.on("decel", this.onDecel), this.panzoom.on("refresh", this.onRefresh), this.panzoom.on("beforeTransform", this.onBeforeTransform), this.panzoom.on("endAnimation", this.onEndAnimation) } attachEvents() { const e = this.container; e && (e.addEventListener("click", this.onClick, { passive: !1, capture: !1 }), e.addEventListener("slideTo", this.onSlideTo)), window.addEventListener("resize", this.onResize) } createPages() { let e = []; const { contentDim: t, viewportDim: i } = this; let s = this.option("slidesPerPage"); ("number" != typeof s || t <= i) && (s = 1 / 0); let n = 0, o = 0, a = 0; for (const t of this.slides) (!e.length || o + t.dim > i || a === s) && (e.push(ve()), n = e.length - 1, o = 0, a = 0), e[n].slides.push(t), o += t.dim + t.gap, a++; return e } processPages() { const e = this.pages, { contentDim: t, viewportDim: i } = this, s = this.option("center"), n = this.option("fill"), o = n && s && t > i && !this.isInfinite; if (e.forEach(((e, n) => { e.index = n, e.pos = e.slides[0].pos, e.dim = 0; for (const [t, i] of e.slides.entries()) e.dim += i.dim, t < e.slides.length - 1 && (e.dim += i.gap); o && e.pos + .5 * e.dim < .5 * i ? e.pos = 0 : o && e.pos + .5 * e.dim >= t - .5 * i ? e.pos = t - i : s && (e.pos += -.5 * (i - e.dim)) })), e.forEach(((e, s) => { n && !this.isInfinite && t > i && (e.pos = Math.max(e.pos, 0), e.pos = Math.min(e.pos, t - i)), e.pos = I(e.pos, 1e3), e.dim = I(e.dim, 1e3), Math.abs(e.pos) <= .1 && (e.pos = 0) })), this.isInfinite) return e; const a = []; let r; return e.forEach((e => { const t = Object.assign({}, e); r && t.pos === r.pos ? (r.dim += t.dim, r.slides = [...r.slides, ...t.slides]) : (t.index = a.length, r = t, a.push(t)) })), a } getPageFromIndex(e = 0) { const t = this.pages.length; let i; return e = parseInt((e || 0).toString()) || 0, i = this.isInfinite ? (e % t + t) % t : Math.max(Math.min(e, t - 1), 0), i } getSlideMetrics(e) { var t, i; const s = this.isHorizontal ? "width" : "height"; let n = 0, o = 0, a = e.el; const r = a && !a.parentNode; if (a ? n = parseFloat(a.dataset[s] || "") || 0 : (a = document.createElement("div"), a.style.visibility = "hidden", (this.track || document.body).prepend(a)), ne(a, this.cn("slide") + " " + e.class + " " + e.customClass), n) a.style[s] = `${n}px`, a.style["width" === s ? "height" : "width"] = ""; else { r && (this.track || document.body).prepend(a); const e = Math.max(1, (null === (t = window.visualViewport) || void 0 === t ? void 0 : t.scale) || 1); n = a.getBoundingClientRect()[s] * e } const l = getComputedStyle(a); return "content-box" === l.boxSizing && (this.isHorizontal ? (n += parseFloat(l.paddingLeft) || 0, n += parseFloat(l.paddingRight) || 0) : (n += parseFloat(l.paddingTop) || 0, n += parseFloat(l.paddingBottom) || 0)), o = parseFloat(l[this.isHorizontal ? "marginRight" : "marginBottom"]) || 0, r ? null === (i = a.parentElement) || void 0 === i || i.removeChild(a) : e.el || a.remove(), { dim: I(n, 1e3), gap: I(o, 1e3) } } getBounds() { const { isInfinite: e, isRTL: t, isHorizontal: i, pages: s } = this; let n = { min: 0, max: 0 }; if (e) n = { min: -1 / 0, max: 1 / 0 }; else if (s.length) { const e = s[0].pos, o = s[s.length - 1].pos; n = t && i ? { min: e, max: o } : { min: -1 * o, max: -1 * e } } return { x: i ? n : { min: 0, max: 0 }, y: i ? { min: 0, max: 0 } : n } } repositionSlides() { let e, { isHorizontal: t, isRTL: i, isInfinite: s, viewport: n, viewportDim: o, contentDim: a, page: r, pages: l, slides: c, panzoom: u } = this, d = 0, h = 0, p = 0, f = 0; u ? f = -1 * u.current[this.axis] : l[r] && (f = l[r].pos || 0), e = t ? i ? "right" : "left" : "top", i && t && (f *= -1); for (const t of c) t.el ? ("top" === e ? (t.el.style.right = "", t.el.style.left = "") : t.el.style.top = "", t.index !== d ? t.el.style[e] = 0 === h ? "" : `${I(h, 1e3)}px` : t.el.style[e] = "", p += t.dim + t.gap, d++) : h += t.dim + t.gap; if (s && p && n) { let i = getComputedStyle(n), s = "padding", r = t ? "Right" : "Bottom", l = parseFloat(i[s + (t ? "Left" : "Top")]); f -= l, o += l, o += parseFloat(i[s + r]); for (const t of c) t.el && (I(t.pos) < I(o) && I(t.pos + t.dim + t.gap) < I(f) && I(f) > I(a - o) && (t.el.style[e] = `${I(h + p, 1e3)}px`), I(t.pos + t.gap) >= I(a - o) && I(t.pos) > I(f + o) && I(f) < I(o) && (t.el.style[e] = `-${I(p, 1e3)}px`)) } let m, g, v = [...this.inTransition]; if (v.length > 1 && (m = l[v[0]], g = l[v[1]]), m && g) { let t = 0; for (const i of c) i.el ? this.inTransition.has(i.index) && m.slides.indexOf(i) < 0 && (i.el.style[e] = `${I(t + (m.pos - g.pos), 1e3)}px`) : t += i.dim + i.gap } } createSlideEl(e) { const { track: t, slides: i } = this; if (!t || !e) return; if (e.el && e.el.parentNode) return; const s = e.el || document.createElement("div"); ne(s, this.cn("slide")), ne(s, e.class), ne(s, e.customClass); const n = e.html; n && (n instanceof HTMLElement ? s.appendChild(n) : s.innerHTML = e.html + ""); const o = []; i.forEach(((e, t) => { e.el && o.push(t) })); const a = e.index; let r = null; o.length && (r = i[o.reduce(((e, t) => Math.abs(t - a) < Math.abs(e - a) ? t : e))]); const l = r && r.el && r.el.parentNode ? r.index < e.index ? r.el.nextSibling : r.el : null; t.insertBefore(s, t.contains(l) ? l : null), e.el = s, this.emit("createSlide", e) } removeSlideEl(e, t = !1) { const i = e.el; if (!i || !i.parentNode) return; if (se(i, this.cn("isSelected")), e.isDom && !t) return i.removeAttribute("aria-hidden"), i.removeAttribute("data-index"), se(i, this.cn("isSelected")), void (i.style.left = ""); this.emit("removeSlide", e); const s = new CustomEvent("animationend"); i.dispatchEvent(s), e.el && (e.el.remove(), e.el = null) } transitionTo(e = 0, t = this.option("transition")) { if (!t) return !1; const { pages: i, panzoom: s } = this; e = parseInt((e || 0).toString()) || 0; const n = this.getPageFromIndex(e); if (!s || !i[n] || i.length < 2 || Math.abs(i[this.page].slides[0].dim - this.viewportDim) > 1) return !1; const o = e > this.page ? 1 : -1, a = this.pages[n].pos * (this.isRTL ? 1 : -1); if (this.page === n && Math.abs(a - s.target[this.axis]) < 1) return !1; this.clearTransitions(); const r = s.isResting; ne(this.container, this.cn("inTransition")); const l = this.pages[this.page].slides[0], c = this.pages[n].slides[0]; this.inTransition.add(c.index), this.createSlideEl(c); let u = l.el, d = c.el; r || "slide" === t || (t = "fadeFast", u = null); const h = this.isRTL ? "next" : "prev", p = this.isRTL ? "prev" : "next"; return u && (this.inTransition.add(l.index), l.transition = t, u.addEventListener("animationend", this.onAnimationEnd), u.classList.add(`f-${t}Out`, `to-${o > 0 ? p : h}`)), d && (c.transition = t, d.addEventListener("animationend", this.onAnimationEnd), d.classList.add(`f-${t}In`, `from-${o > 0 ? h : p}`)), s.panTo({ x: this.isHorizontal ? a : 0, y: this.isHorizontal ? 0 : a, friction: 0 }), this.onChange(n), !0 } manageSlideVisiblity() { const e = new Set, t = new Set, i = this.getVisibleSlides(parseFloat(this.option("preload", 0) + "") || 0); for (const s of this.slides) i.has(s) ? e.add(s) : t.add(s); for (const t of this.inTransition) e.add(this.slides[t]); for (const t of e) this.createSlideEl(t), this.lazyLoadSlide(t); for (const i of t) e.has(i) || this.removeSlideEl(i); this.markSelectedSlides(), this.repositionSlides() } markSelectedSlides() { if (!this.pages[this.page] || !this.pages[this.page].slides) return; const e = "aria-hidden"; let t = this.cn("isSelected"); if (t) for (const i of this.slides) i.el && (i.el.dataset.index = `${i.index}`, this.pages[this.page].slides.includes(i) ? (i.el.classList.contains(t) || (ne(i.el, t), this.emit("selectSlide", i)), i.el.removeAttribute(e)) : (i.el.classList.contains(t) && (se(i.el, t), this.emit("unselectSlide", i)), i.el.setAttribute(e, "true"))) } flipInfiniteTrack() { const e = this.panzoom; if (!e || !this.isInfinite) return; const t = "x" === this.option("axis") ? "e" : "f", { viewportDim: i, contentDim: s } = this; let n = e.current[t], o = e.target[t] - n, a = 0, r = .5 * i, l = s; this.isRTL && this.isHorizontal ? (n < -r && (a = -1, n += l), n > l - r && (a = 1, n -= l)) : (n > r && (a = 1, n -= l), n < -l + r && (a = -1, n += l)), a && (e.current[t] = n, e.target[t] = n + o) } lazyLoadSlide(e) { const t = this, i = e && e.el; if (!i) return; const s = new Set, n = "f-fadeIn"; i.querySelectorAll("[data-lazy-srcset]").forEach((e => { e instanceof HTMLImageElement && s.add(e) })); let o = Array.from(i.querySelectorAll("[data-lazy-src]")); i.dataset.lazySrc && o.push(i), o.map((e => { e instanceof HTMLImageElement ? s.add(e) : ie(e) && (e.style.backgroundImage = `url('${e.dataset.lazySrc || ""}')`, delete e.dataset.lazySrc) })); const a = (e, i, s) => { s && (s.remove(), s = null), i.complete && (i.classList.add(n), setTimeout((() => { i.classList.remove(n) }), 350), i.style.display = ""), this.option("adaptiveHeight") && e.el && this.pages[this.page].slides.indexOf(e) > -1 && (t.updateMetrics(), t.setViewportHeight()), this.emit("load", e) }; for (const t of s) { let i = null; t.src = t.dataset.lazySrcset || t.dataset.lazySrc || "", delete t.dataset.lazySrc, delete t.dataset.lazySrcset, t.style.display = "none", t.addEventListener("error", (() => { a(e, t, i) })), t.addEventListener("load", (() => { a(e, t, i) })), setTimeout((() => { t.parentNode && e.el && (t.complete ? a(e, t, i) : (i = R(te), t.parentNode.insertBefore(i, t))) }), 300) } } onAnimationEnd(e) { var t; const i = e.target, s = i ? parseInt(i.dataset.index || "", 10) || 0 : -1, n = this.slides[s], o = e.animationName; if (!i || !n || !o) return; const a = !!this.inTransition.has(s) && n.transition; a && o.substring(0, a.length + 2) === `f-${a}` && this.inTransition.delete(s), this.inTransition.size || this.clearTransitions(), s === this.page && (null === (t = this.panzoom) || void 0 === t ? void 0 : t.isResting) && this.emit("settle") } onDecel(e, t = 0, i = 0, s = 0, n = 0) { const { isRTL: o, isHorizontal: a, axis: r, pages: l } = this, c = l.length, u = Math.abs(Math.atan2(i, t) / (Math.PI / 180)); let d = 0; if (d = u > 45 && u < 135 ? a ? 0 : i : a ? t : 0, !c) return; const h = this.option("dragFree"); let p = this.page, f = o && a ? 1 : -1; const m = e.target[r] * f, g = e.current[r] * f; let { pageIndex: v } = this.getPageFromPosition(m), { pageIndex: b } = this.getPageFromPosition(g); h ? this.onChange(v) : (Math.abs(d) > 5 ? (l[p].dim < document.documentElement["client" + (this.isHorizontal ? "Width" : "Height")] - 1 && (p = b), p = o && a ? d < 0 ? p - 1 : p + 1 : d < 0 ? p + 1 : p - 1) : p = 0 === s && 0 === n ? p : b, this.slideTo(p, { transition: !1, friction: e.option("decelFriction") })) } onClick(e) { const t = e.target, i = t && ie(t) ? t.dataset : null; let s, n; i && (void 0 !== i.carouselPage ? (n = "slideTo", s = i.carouselPage) : void 0 !== i.carouselNext ? n = "slideNext" : void 0 !== i.carouselPrev && (n = "slidePrev")), n ? (e.preventDefault(), e.stopPropagation(), t && !t.hasAttribute("disabled") && this[n](s)) : this.emit("click", e) } onSlideTo(e) { const t = e.detail || 0; this.slideTo(this.getPageForSlide(t), { friction: 0 }) } onChange(e, t = 0) { const i = this.page; this.prevPage = i, this.page = e, this.option("adaptiveHeight") && this.setViewportHeight(), e !== i && (this.markSelectedSlides(), this.emit("change", e, i, t)) } onRefresh() { let e = this.contentDim, t = this.viewportDim; this.updateMetrics(), this.contentDim === e && this.viewportDim === t || this.slideTo(this.page, { friction: 0, transition: !1 }) } onResize() { this.option("breakpoints") && this.processOptions() } onBeforeTransform(e) { this.lp !== e.current[this.axis] && (this.flipInfiniteTrack(), this.manageSlideVisiblity()), this.lp = e.current.e } onEndAnimation() { this.inTransition.size || this.emit("settle") } reInit(e = null, t = null) { this.destroy(), this.state = me.Init, this.userOptions = e || this.userOptions, this.userPlugins = t || this.userPlugins, this.processOptions() } slideTo(e = 0, { friction: t = this.option("friction"), transition: i = this.option("transition") } = {}) { if (this.state === me.Destroy) return; const { axis: s, isHorizontal: n, isRTL: o, pages: a, panzoom: r } = this, l = a.length, c = o && n ? 1 : -1; if (!r || !l) return; if (this.transitionTo(e, i)) return; const u = this.getPageFromIndex(e); let d = a[u].pos; if (this.isInfinite) { const t = this.contentDim, i = r.target[s] * c; if (2 === l) d += t * Math.floor(parseFloat(e + "") / 2); else { const e = i; d = [d, d - t, d + t].reduce((function (t, i) { return Math.abs(i - e) < Math.abs(t - e) ? i : t })) } } d *= c, Math.abs(r.target[s] - d) < .1 || (r.panTo({ x: n ? d : 0, y: n ? 0 : d, friction: t }), this.onChange(u)) } slideToClosest(e) { if (this.panzoom) { const { pageIndex: t } = this.getPageFromPosition(this.panzoom.current[this.isHorizontal ? "e" : "f"]); this.slideTo(t, e) } } slideNext() { this.slideTo(this.page + 1) } slidePrev() { this.slideTo(this.page - 1) } clearTransitions() { this.inTransition.clear(), se(this.container, this.cn("inTransition")); const e = ["to-prev", "to-next", "from-prev", "from-next"]; for (const t of this.slides) { const i = t.el; if (i) { i.removeEventListener("animationend", this.onAnimationEnd), i.classList.remove(...e); const s = t.transition; s && i.classList.remove(`f-${s}Out`, `f-${s}In`) } } this.manageSlideVisiblity() } prependSlide(e) { var t, i; let s = Array.isArray(e) ? e : [e]; for (const e of s.reverse()) this.slides.unshift(ge(e)); for (let e = 0; e < this.slides.length; e++)this.slides[e].index = e; const n = (null === (t = this.pages[this.page]) || void 0 === t ? void 0 : t.pos) || 0; this.page += s.length, this.updateMetrics(); const o = (null === (i = this.pages[this.page]) || void 0 === i ? void 0 : i.pos) || 0; if (this.panzoom) { const e = this.isRTL ? n - o : o - n; this.panzoom.target.e -= e, this.panzoom.current.e -= e, this.panzoom.requestTick() } } appendSlide(e) { let t = Array.isArray(e) ? e : [e]; for (const e of t) { const t = ge(e); t.index = this.slides.length, this.slides.push(t), this.emit("initSlide", t, this.slides.length) } this.updateMetrics() } removeSlide(e) { const t = this.slides.length; e = (e % t + t) % t, this.removeSlideEl(this.slides[e], !0), this.slides.splice(e, 1); for (let e = 0; e < this.slides.length; e++)this.slides[e].index = e; this.updateMetrics(), this.slideTo(this.page, { friction: 0, transition: !1 }) } updateMetrics() { const { panzoom: e, viewport: t, track: i, isHorizontal: s } = this; if (!i) return; const n = s ? "width" : "height", o = s ? "offsetWidth" : "offsetHeight"; if (t) { let e = Math.max(t[o], I(t.getBoundingClientRect()[n], 1e3)), i = getComputedStyle(t), a = "padding", r = s ? "Right" : "Bottom"; e -= parseFloat(i[a + (s ? "Left" : "Top")]) + parseFloat(i[a + r]), this.viewportDim = e } let a, r = this.pages.length, l = 0; for (const [e, t] of this.slides.entries()) { let i = 0, s = 0; !t.el && a ? (i = a.dim, s = a.gap) : (({ dim: i, gap: s } = this.getSlideMetrics(t)), a = t), i = I(i, 1e3), s = I(s, 1e3), t.dim = i, t.gap = s, t.pos = l, l += i, (this.isInfinite || e < this.slides.length - 1) && (l += s) } const c = this.contentDim; l = I(l, 1e3), this.contentDim = l, e && (e.contentRect[n] = l, e.contentRect["e" === this.axis ? "fullWidth" : "fullHeight"] = l), this.pages = this.createPages(), this.pages = this.processPages(), this.state === me.Init && this.setInitialPage(), this.page = Math.max(0, Math.min(this.page, this.pages.length - 1)), e && r === this.pages.length && Math.abs(l - c) > .5 && (e.target[this.axis] = -1 * this.pages[this.page].pos, e.current[this.axis] = -1 * this.pages[this.page].pos, e.stop()), this.manageSlideVisiblity(), this.emit("refresh") } getProgress(e, t = !1) { void 0 === e && (e = this.page); const i = this, s = i.panzoom, n = i.pages[e] || 0; if (!n || !s) return 0; let o = -1 * s.current.e, a = i.contentDim; var r = [I((o - n.pos) / (1 * n.dim), 1e3), I((o + a - n.pos) / (1 * n.dim), 1e3), I((o - a - n.pos) / (1 * n.dim), 1e3)].reduce((function (e, t) { return Math.abs(t) < Math.abs(e) ? t : e })); return t ? r : Math.max(-1, Math.min(1, r)) } setViewportHeight() { const { page: e, pages: t, viewport: i, isHorizontal: s } = this; if (!i || !t[e]) return; let n = 0; s && this.track && (this.track.style.height = "auto", t[e].slides.forEach((e => { e.el && (n = Math.max(n, e.el.offsetHeight)) }))), i.style.height = n ? `${n}px` : "" } getPageForSlide(e) { for (const t of this.pages) for (const i of t.slides) if (i.index === e) return t.index; return -1 } getVisibleSlides(e = 0) { var t; const i = new Set; let { contentDim: s, viewportDim: n, pages: o, page: a } = this; s = s + (null === (t = this.slides[this.slides.length - 1]) || void 0 === t ? void 0 : t.gap) || 0; let r = 0; r = this.panzoom ? -1 * this.panzoom.current[this.axis] : o[a] && o[a].pos || 0, this.isInfinite && (r -= Math.floor(r / s) * s), this.isRTL && this.isHorizontal && (r *= -1); const l = r - n * e, c = r + n * (e + 1), u = this.isInfinite ? [-1, 0, 1] : [0]; for (const e of this.slides) for (const t of u) { const n = e.pos + t * s, o = e.pos + e.dim + e.gap + t * s; n < c && o > l && i.add(e) } return i } getPageFromPosition(e) { const { viewportDim: t, contentDim: i } = this, s = this.pages.length, n = this.slides.length, o = this.slides[n - 1]; let a = 0, r = 0, l = 0; const c = this.option("center"); c && (e += .5 * t), this.isInfinite || (e = Math.max(this.slides[0].pos, Math.min(e, o.pos))); const u = i + o.gap; l = Math.floor(e / u) || 0, e -= l * u; let d = o, h = this.slides.find((t => { const i = e + (d && !c ? .5 * d.dim : 0); return d = t, t.pos <= i && t.pos + t.dim + t.gap > i })); return h || (h = o), r = this.getPageForSlide(h.index), a = r + l * s, { page: a, pageIndex: r } } destroy() { if ([me.Destroy].includes(this.state)) return; this.state = me.Destroy; const { container: e, viewport: t, track: i, slides: s, panzoom: n } = this, o = this.option("classes"); e.removeEventListener("click", this.onClick, { passive: !1, capture: !1 }), e.removeEventListener("slideTo", this.onSlideTo), window.removeEventListener("resize", this.onResize), n && (n.destroy(), this.panzoom = null), s && s.forEach((e => { this.removeSlideEl(e) })), this.detachPlugins(), t && t.offsetParent && i && i.offsetParent && t.replaceWith(...i.childNodes); for (const [t, i] of Object.entries(o)) "container" !== t && i && e.classList.remove(i); this.track = null, this.viewport = null, this.page = 0, this.slides = []; const a = this.events.get("ready"); this.events = new Map, a && this.events.set("ready", a) } } Object.defineProperty(Te, "Panzoom", { enumerable: !0, configurable: !0, writable: !0, value: he }), Object.defineProperty(Te, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: { viewport: null, track: null, enabled: !0, slides: [], axis: "x", transition: "fade", preload: 1, slidesPerPage: "auto", initialPage: 0, friction: .12, Panzoom: { decelFriction: .12 }, center: !0, infinite: !0, fill: !0, dragFree: !1, adaptiveHeight: !1, direction: "ltr", classes: { container: "f-carousel", viewport: "f-carousel__viewport", track: "f-carousel__track", slide: "f-carousel__slide", isLTR: "is-ltr", isRTL: "is-rtl", isHorizontal: "is-horizontal", isVertical: "is-vertical", inTransition: "in-transition", isSelected: "is-selected" }, l10n: { NEXT: "Next slide", PREV: "Previous slide", GOTO: "Go to slide #%d" } } }), Object.defineProperty(Te, "Plugins", { enumerable: !0, configurable: !0, writable: !0, value: ke }); const Ae = function (e) { const t = window.pageYOffset, i = window.pageYOffset + window.innerHeight; if (!ie(e)) return 0; const s = e.getBoundingClientRect(), n = s.y + window.pageYOffset, o = s.y + s.height + window.pageYOffset; if (t > o || i < n) return 0; if (t < n && i > o) return 100; if (n < t && o > i) return 100; let a = s.height; n < t && (a -= window.pageYOffset - n), o > i && (a -= o - i); const r = a / window.innerHeight * 100; return Math.round(r) }, Me = !("undefined" == typeof window || !window.document || !window.document.createElement); let Pe; const Oe = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden]):not(.fancybox-focus-guard)", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])'].join(","), _e = e => { if (e && Me) { void 0 === Pe && document.createElement("div").focus({ get preventScroll() { return Pe = !0, !1 } }); try { if (Pe) e.focus({ preventScroll: !0 }); else { const t = window.pageXOffset || document.body.scrollTop, i = window.pageYOffset || document.body.scrollLeft; e.focus(), document.body.scrollTo({ top: t, left: i, behavior: "auto" }) } } catch (e) { } } }, Le = { dragToClose: !0, hideScrollbar: !0, Carousel: { classes: { container: "fancybox__carousel", viewport: "fancybox__viewport", track: "fancybox__track", slide: "fancybox__slide" } }, contentClick: "toggleZoom", contentDblClick: !1, backdropClick: "close", animated: !0, idle: 3500, showClass: "f-zoomInUp", hideClass: "f-fadeOut", commonCaption: !1, parentEl: null, startIndex: 0, l10n: Object.assign(Object.assign({}, Q), { CLOSE: "Close", NEXT: "Next", PREV: "Previous", MODAL: "You can close this modal content with the ESC key", ERROR: "Something Went Wrong, Please Try Again Later", IMAGE_ERROR: "Image Not Found", ELEMENT_NOT_FOUND: "HTML Element Not Found", AJAX_NOT_FOUND: "Error Loading AJAX : Not Found", AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden", IFRAME_ERROR: "Error Loading Page", TOGGLE_ZOOM: "Toggle zoom level", TOGGLE_THUMBS: "Toggle thumbnails", TOGGLE_SLIDESHOW: "Toggle slideshow", TOGGLE_FULLSCREEN: "Toggle full-screen mode", DOWNLOAD: "Download" }), tpl: { closeButton: '<button data-fancybox-close class="f-button is-close-btn" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg></button>', main: '<div class="fancybox__container" role="dialog" aria-modal="true" aria-label="{{MODAL}}" tabindex="-1">\n    <div class="fancybox__backdrop"></div>\n    <div class="fancybox__carousel"></div>\n    <div class="fancybox__footer"></div>\n  </div>' }, groupAll: !1, groupAttr: "data-fancybox", defaultType: "image", defaultDisplay: "block", autoFocus: !0, trapFocus: !0, placeFocusBack: !0, closeButton: "auto", keyboard: { Escape: "close", Delete: "close", Backspace: "close", PageUp: "next", PageDown: "prev", ArrowUp: "prev", ArrowDown: "next", ArrowRight: "next", ArrowLeft: "prev" }, Fullscreen: { autoStart: !1 }, compact: () => window.matchMedia("(max-width: 578px), (max-height: 578px)").matches, wheel: "zoom" }; var De, Fe; !function (e) { e[e.Init = 0] = "Init", e[e.Ready = 1] = "Ready", e[e.Closing = 2] = "Closing", e[e.CustomClosing = 3] = "CustomClosing", e[e.Destroy = 4] = "Destroy" }(De || (De = {})), function (e) { e[e.Loading = 0] = "Loading", e[e.Opening = 1] = "Opening", e[e.Ready = 2] = "Ready", e[e.Closing = 3] = "Closing" }(Fe || (Fe = {})); const Ie = () => { queueMicrotask((() => { (() => { const { slug: e, index: t } = Be.parseURL(), i = vt.getInstance(); if (i && !1 !== i.option("Hash")) { const s = i.carousel; if (e && s) { for (let t of s.slides) if (t.slug && t.slug === e) return s.slideTo(t.index); if (e === i.option("slug")) return s.slideTo(t - 1); const n = i.getSlide(), o = n && n.triggerEl && n.triggerEl.dataset; if (o && o.fancybox === e) return s.slideTo(t - 1) } Be.hasSilentClose = !0, i.close() } Be.startFromUrl() })() })) }; class Be extends be { constructor() { super(...arguments), Object.defineProperty(this, "origHash", { enumerable: !0, configurable: !0, writable: !0, value: "" }), Object.defineProperty(this, "timer", { enumerable: !0, configurable: !0, writable: !0, value: null }) } onChange() { const e = this.instance, t = e.carousel; this.timer && clearTimeout(this.timer); const i = e.getSlide(); if (!t || !i) return; const s = e.isOpeningSlide(i), n = new URL(document.URL).hash; let o, a = i.slug || void 0, r = i.triggerEl || void 0; o = a || this.instance.option("slug"), !o && r && r.dataset && (o = r.dataset.fancybox); let l = ""; o && "true" !== o && (l = "#" + o + (!a && t.slides.length > 1 ? "-" + (i.index + 1) : "")), s && (this.origHash = n !== l ? n : ""), l && n !== l && (this.timer = setTimeout((() => { try { e.state === De.Ready && window.history[s ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + l) } catch (e) { } }), 300)) } onClose() { if (this.timer && clearTimeout(this.timer), !0 !== Be.hasSilentClose) try { window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash || "")) } catch (e) { } } attach() { const e = this.instance; e.on("Carousel.ready", this.onChange), e.on("Carousel.change", this.onChange), e.on("close", this.onClose) } detach() { const e = this.instance; e.off("Carousel.ready", this.onChange), e.off("Carousel.change", this.onChange), e.off("close", this.onClose) } static parseURL() { const e = window.location.hash.slice(1), t = e.split("-"), i = t[t.length - 1], s = i && /^\+?\d+$/.test(i) && parseInt(t.pop() || "1", 10) || 1; return { hash: e, slug: t.join("-"), index: s } } static startFromUrl() { if (Be.hasSilentClose = !1, vt.getInstance() || !1 === vt.defaults.Hash) return; const { hash: e, slug: t, index: i } = Be.parseURL(); if (!t) return; let s = document.querySelector(`[data-slug="${e}"]`); if (s && s.dispatchEvent(new CustomEvent("click", { bubbles: !0, cancelable: !0 })), vt.getInstance()) return; const n = document.querySelectorAll(`[data-fancybox="${t}"]`); n.length && (s = n[i - 1], s && s.dispatchEvent(new CustomEvent("click", { bubbles: !0, cancelable: !0 }))) } static destroy() { window.removeEventListener("hashchange", Ie, !1) } } function ze() { window.addEventListener("hashchange", Ie, !1), setTimeout((() => { Be.startFromUrl() }), 500) } Object.defineProperty(Be, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(Be, "hasSilentClose", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Me && (/complete|interactive|loaded/.test(document.readyState) ? ze() : document.addEventListener("DOMContentLoaded", ze)); class Re extends be { onCreateSlide(e, t, i) { const s = this.instance.optionFor(i, "src") || ""; i.el && "image" === i.type && "string" == typeof s && this.setImage(i, s) } onRemoveSlide(e, t, i) { i.panzoom && i.panzoom.destroy(), i.panzoom = void 0, i.imageEl = void 0 } onChange(e, t, i, s) { for (const e of t.slides) { const t = e.panzoom; t && e.index !== i && t.reset(.35) } } onClose() { var e; const t = this.instance, i = t.container, s = t.getSlide(); if (!i || !i.parentElement || !s) return; const { el: n, contentEl: o, panzoom: a } = s, r = s.thumbElSrc; if (!n || !r || !o || !a || a.isContentLoading || a.state === K.Init || a.state === K.Destroy) return; a.updateMetrics(); let l = this.getZoomInfo(s); if (!l) return; this.instance.state = De.CustomClosing, i.classList.remove("is-zooming-in"), i.classList.add("is-zooming-out"), o.style.backgroundImage = `url('${r}')`; const c = i.getBoundingClientRect(); 1 === ((null === (e = window.visualViewport) || void 0 === e ? void 0 : e.scale) || 1) && Object.assign(i.style, { position: "absolute", top: `${window.pageYOffset}px`, left: `${window.pageXOffset}px`, bottom: "auto", right: "auto", width: `${c.width}px`, height: `${c.height}px`, overflow: "hidden" }); const { x: u, y: d, scale: h, opacity: p } = l; if (p) { const e = ((e, t, i, s) => { const n = t - e; return t => 1 + ((t - e) / n * -1 || 0) })(a.scale, h); a.on("afterTransform", (() => { o.style.opacity = e(a.scale) + "" })) } a.on("endAnimation", (() => { t.destroy() })), a.target.a = h, a.target.b = 0, a.target.c = 0, a.target.d = h, a.panTo({ x: u, y: d, scale: h, friction: p ? .2 : .33, ignoreBounds: !0 }), a.isResting && t.destroy() } setImage(e, t) { const i = this.instance; e.src = t, this.process(e, t).then((t => { var s; const n = e.contentEl, o = e.imageEl, a = e.thumbElSrc; if (i.isClosing() || !n || !o) return; n.offsetHeight; const r = !!i.isOpeningSlide(e) && this.getZoomInfo(e); if (this.option("protected")) { null === (s = e.el) || void 0 === s || s.addEventListener("contextmenu", (e => { e.preventDefault() })); const t = document.createElement("div"); ne(t, "fancybox-protected"), n.appendChild(t) } if (a && r) { const s = t.contentRect, o = Math.max(s.fullWidth, s.fullHeight); let c = null; !r.opacity && o > 1200 && (c = document.createElement("img"), ne(c, "fancybox-ghost"), c.src = a, n.appendChild(c)); const u = () => { c && (ne(c, "f-fadeFastOut"), setTimeout((() => { c && (c.remove(), c = null) }), 200)) }; (l = a, new Promise(((e, t) => { const i = new Image; i.onload = e, i.onerror = t, i.src = l }))).then((() => { e.state = Fe.Opening, this.instance.emit("reveal", e), this.zoomIn(e).then((() => { u(), this.instance.done(e) }), (() => { i.hideLoading(e) })), c && setTimeout((() => { u() }), o > 2500 ? 800 : 200) }), (() => { i.hideLoading(e), i.revealContent(e) })) } else { const s = this.optionFor(e, "initialSize"), n = this.optionFor(e, "zoom"), o = { event: i.prevMouseMoveEvent || i.options.event, friction: n ? .12 : 0 }; let a = i.optionFor(e, "showClass") || void 0, r = !0; i.isOpeningSlide(e) && ("full" === s ? t.zoomToFull(o) : "cover" === s ? t.zoomToCover(o) : "max" === s ? t.zoomToMax(o) : r = !1, t.stop("current")), r && a && (a = t.isDragging ? "f-fadeIn" : ""), i.revealContent(e, a) } var l }), (() => { i.setError(e, "{{IMAGE_ERROR}}") })) } process(e, t) { return new Promise(((i, s) => { var n; const o = this.instance, a = e.el; o.clearContent(e), o.showLoading(e); let r = this.optionFor(e, "content"); if ("string" == typeof r && (r = R(r)), !r || !ie(r)) { if (r = document.createElement("img"), r instanceof HTMLImageElement) { let i = "", s = e.caption; i = "string" == typeof s && s ? s.replace(/<[^>]+>/gi, "").substring(0, 1e3) : `Image ${e.index + 1} of ${null === (n = o.carousel) || void 0 === n ? void 0 : n.pages.length}`, r.src = t || "", r.alt = i, r.draggable = !1, e.srcset && r.setAttribute("srcset", e.srcset) } e.sizes && r.setAttribute("sizes", e.sizes) } r.classList.add("fancybox-image"), e.imageEl = r, o.setContent(e, r, !1), e.panzoom = new he(a, X({ transformParent: !0 }, this.option("Panzoom") || {}, { content: r, width: o.optionFor(e, "width", "auto"), height: o.optionFor(e, "height", "auto"), wheel: () => { const e = o.option("wheel"); return ("zoom" === e || "pan" == e) && e }, click: (t, i) => { var s, n; if (o.isCompact || o.isClosing()) return !1; if (e.index !== (null === (s = o.getSlide()) || void 0 === s ? void 0 : s.index)) return !1; if (i) { const e = i.composedPath()[0]; if (["A", "BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].includes(e.nodeName)) return !1 } let a = !i || i.target && (null === (n = e.contentEl) || void 0 === n ? void 0 : n.contains(i.target)); return o.option(a ? "contentClick" : "backdropClick") || !1 }, dblClick: () => o.isCompact ? "toggleZoom" : o.option("contentDblClick") || !1, spinner: !1, panOnlyZoomed: !0, wheelLimit: 1 / 0, on: { ready: e => { i(e) }, error: () => { s() }, destroy: () => { s() } } })) })) } zoomIn(e) { return new Promise(((t, i) => { const s = this.instance, n = s.container, { panzoom: o, contentEl: a, el: r } = e; o && o.updateMetrics(); const l = this.getZoomInfo(e); if (!(l && r && a && o && n)) return void i(); const { x: c, y: u, scale: d, opacity: h } = l, p = () => { e.state !== Fe.Closing && (h && (a.style.opacity = Math.max(Math.min(1, 1 - (1 - o.scale) / (1 - d)), 0) + ""), o.scale >= 1 && o.scale > o.targetScale - .1 && t(o)) }, f = e => { se(n, "is-zooming-in"), e.scale < .99 || e.scale > 1.01 || (a.style.opacity = "", e.off("endAnimation", f), e.off("touchStart", f), e.off("afterTransform", p), t(e)) }; o.on("endAnimation", f), o.on("touchStart", f), o.on("afterTransform", p), o.on(["error", "destroy"], (() => { i() })), o.panTo({ x: c, y: u, scale: d, friction: 0, ignoreBounds: !0 }), o.stop("current"); const m = { event: "mousemove" === o.panMode ? s.prevMouseMoveEvent || s.options.event : void 0 }, g = this.optionFor(e, "initialSize"); ne(n, "is-zooming-in"), s.hideLoading(e), "full" === g ? o.zoomToFull(m) : "cover" === g ? o.zoomToCover(m) : "max" === g ? o.zoomToMax(m) : o.reset(.172) })) } getZoomInfo(e) { var t; const { el: i, imageEl: s, thumbEl: n, panzoom: o } = e; if (!i || !s || !n || !o || Ae(n) < 3 || !this.optionFor(e, "zoom") || this.instance.state === De.Destroy) return !1; if (1 !== ((null === (t = window.visualViewport) || void 0 === t ? void 0 : t.scale) || 1)) return !1; let { top: a, left: r, width: l, height: c } = n.getBoundingClientRect(), { top: u, left: d, fitWidth: h, fitHeight: p } = o.contentRect; if (!(l && c && h && p)) return !1; const f = o.container.getBoundingClientRect(); d += f.left, u += f.top; const m = -1 * (d + .5 * h - (r + .5 * l)), g = -1 * (u + .5 * p - (a + .5 * c)), v = l / h; let b = this.option("zoomOpacity") || !1; return "auto" === b && (b = Math.abs(l / c - h / p) > .1), { x: m, y: g, scale: v, opacity: b } } attach() { const e = this, t = e.instance; t.on("Carousel.change", e.onChange), t.on("Carousel.createSlide", e.onCreateSlide), t.on("Carousel.removeSlide", e.onRemoveSlide), t.on("close", e.onClose) } detach() { const e = this, t = e.instance; t.off("Carousel.change", e.onChange), t.off("Carousel.createSlide", e.onCreateSlide), t.off("Carousel.removeSlide", e.onRemoveSlide), t.off("close", e.onClose) } } Object.defineProperty(Re, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: { initialSize: "fit", Panzoom: { maxScale: 1 }, protected: !1, zoom: !0, zoomOpacity: "auto" } }), "function" == typeof SuppressedError && SuppressedError; const je = (e, t = {}) => { const i = new URL(e), s = new URLSearchParams(i.search), n = new URLSearchParams; for (const [e, i] of [...s, ...Object.entries(t)]) { let t = i.toString(); "t" === e ? n.set("start", parseInt(t).toString()) : n.set(e, t) } let o = n.toString(), a = e.match(/#t=((.*)?\d+s)/); return a && (o += `#t=${a[1]}`), o }, Ve = ["image", "html", "ajax", "inline", "clone", "iframe", "map", "pdf", "html5video", "youtube", "vimeo", "video"]; class $e extends be { onInitSlide(e, t, i) { this.processType(i) } onCreateSlide(e, t, i) { this.setContent(i) } onRemoveSlide(e, t, i) { i.xhr && (i.xhr.abort(), i.xhr = null); const s = i.iframeEl; s && (s.onload = s.onerror = null, s.src = "//about:blank", i.iframeEl = null); const n = i.contentEl, o = i.placeholderEl; if ("inline" === i.type && n && o) n.classList.remove("fancybox__content"), "none" !== n.style.display && (n.style.display = "none"), o.parentNode && o.parentNode.insertBefore(n, o), o.remove(), i.contentEl = void 0, i.placeholderEl = void 0; else for (; i.el && i.el.firstChild;)i.el.removeChild(i.el.firstChild) } onSelectSlide(e, t, i) { i.state === Fe.Ready && this.playVideo() } onUnselectSlide(e, t, i) { var s, n; if ("html5video" === i.type) { try { null === (n = null === (s = i.el) || void 0 === s ? void 0 : s.querySelector("video")) || void 0 === n || n.pause() } catch (e) { } return } let o; "vimeo" === i.type ? o = { method: "pause", value: "true" } : "youtube" === i.type && (o = { event: "command", func: "pauseVideo" }), o && i.iframeEl && i.iframeEl.contentWindow && i.iframeEl.contentWindow.postMessage(JSON.stringify(o), "*"), i.poller && clearTimeout(i.poller) } onDone(e, t) { e.isCurrentSlide(t) && !e.isClosing() && this.playVideo() } onRefresh(e, t) { t.slides.forEach((e => { e.el && (this.setAspectRatio(e), this.resizeIframe(e)) })) } onMessage(e) { try { let t = JSON.parse(e.data); if ("https://player.vimeo.com" === e.origin) { if ("ready" === t.event) for (let t of Array.from(document.getElementsByClassName("fancybox__iframe"))) t instanceof HTMLIFrameElement && t.contentWindow === e.source && (t.dataset.ready = "true") } else if (e.origin.match(/^https:\/\/(www.)?youtube(-nocookie)?.com$/) && "onReady" === t.event) { const e = document.getElementById(t.id); e && (e.dataset.ready = "true") } } catch (e) { } } loadAjaxContent(e) { const t = this.instance.optionFor(e, "src") || ""; this.instance.showLoading(e); const i = this.instance, s = new XMLHttpRequest; i.showLoading(e), s.onreadystatechange = function () { s.readyState === XMLHttpRequest.DONE && i.state === De.Ready && (i.hideLoading(e), 200 === s.status ? i.setContent(e, s.responseText) : i.setError(e, 404 === s.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}")) }; const n = e.ajax || null; s.open(n ? "POST" : "GET", t + ""), s.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), s.setRequestHeader("X-Requested-With", "XMLHttpRequest"), s.send(n), e.xhr = s } setInlineContent(e) { let t = null; if (ie(e.src)) t = e.src; else if ("string" == typeof e.src) { const i = e.src.split("#", 2).pop(); t = i ? document.getElementById(i) : null } if (t) { if ("clone" === e.type || t.closest(".fancybox__slide")) { t = t.cloneNode(!0); const i = t.dataset.animationName; i && (t.classList.remove(i), delete t.dataset.animationName); let s = t.getAttribute("id"); s = s ? `${s}--clone` : `clone-${this.instance.id}-${e.index}`, t.setAttribute("id", s) } else if (t.parentNode) { const i = document.createElement("div"); i.classList.add("fancybox-placeholder"), t.parentNode.insertBefore(i, t), e.placeholderEl = i } this.instance.setContent(e, t) } else this.instance.setError(e, "{{ELEMENT_NOT_FOUND}}") } setIframeContent(e) { const { src: t, el: i } = e; if (!t || "string" != typeof t || !i) return; i.classList.add("is-loading"); const s = this.instance, n = document.createElement("iframe"); n.className = "fancybox__iframe", n.setAttribute("id", `fancybox__iframe_${s.id}_${e.index}`); for (const [t, i] of Object.entries(this.optionFor(e, "iframeAttr") || {})) n.setAttribute(t, i); n.onerror = () => { s.setError(e, "{{IFRAME_ERROR}}") }, e.iframeEl = n; const o = this.optionFor(e, "preload"); if ("iframe" !== e.type || !1 === o) return n.setAttribute("src", e.src + ""), s.setContent(e, n, !1), this.resizeIframe(e), void s.revealContent(e); s.showLoading(e), n.onload = () => { if (!n.src.length) return; const t = "true" !== n.dataset.ready; n.dataset.ready = "true", this.resizeIframe(e), t ? s.revealContent(e) : s.hideLoading(e) }, n.setAttribute("src", t), s.setContent(e, n, !1) } resizeIframe(e) { const t = e.iframeEl, i = null == t ? void 0 : t.parentElement; if (!t || !i) return; let s = e.autoSize, n = e.width || 0, o = e.height || 0; n && o && (s = !1); const a = i && i.style; if (!1 !== e.preload && !1 !== s && a) try { const e = window.getComputedStyle(i), s = parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), r = parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), l = t.contentWindow; if (l) { const e = l.document, t = e.getElementsByTagName("html")[0], i = e.body; a.width = "", i.style.overflow = "hidden", n = n || t.scrollWidth + s, a.width = `${n}px`, i.style.overflow = "", a.flex = "0 0 auto", a.height = `${i.scrollHeight}px`, o = t.scrollHeight + r } } catch (e) { } if (n || o) { const e = { flex: "0 1 auto", width: "", height: "" }; n && (e.width = `${n}px`), o && (e.height = `${o}px`), Object.assign(a, e) } } playVideo() { const e = this.instance.getSlide(); if (!e) return; const { el: t } = e; if (!t || !t.offsetParent) return; if (!this.optionFor(e, "videoAutoplay")) return; if ("html5video" === e.type) try { const e = t.querySelector("video"); if (e) { const t = e.play(); void 0 !== t && t.then((() => { })).catch((t => { e.muted = !0, e.play() })) } } catch (e) { } if ("youtube" !== e.type && "vimeo" !== e.type) return; const i = () => { if (e.iframeEl && e.iframeEl.contentWindow) { let t; if ("true" === e.iframeEl.dataset.ready) return t = "youtube" === e.type ? { event: "command", func: "playVideo" } : { method: "play", value: "true" }, t && e.iframeEl.contentWindow.postMessage(JSON.stringify(t), "*"), void (e.poller = void 0); "youtube" === e.type && (t = { event: "listening", id: e.iframeEl.getAttribute("id") }, e.iframeEl.contentWindow.postMessage(JSON.stringify(t), "*")) } e.poller = setTimeout(i, 250) }; i() } processType(e) { if (e.html) return e.type = "html", e.src = e.html, void (e.html = ""); const t = this.instance.optionFor(e, "src", ""); if (!t || "string" != typeof t) return; let i = e.type, s = null; if (s = t.match(/(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|shorts\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) { const n = this.optionFor(e, "youtube"), { nocookie: o } = n, a = function (e, t) { var i = {}; for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (i[s] = e[s]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) { var n = 0; for (s = Object.getOwnPropertySymbols(e); n < s.length; n++)t.indexOf(s[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[n]) && (i[s[n]] = e[s[n]]) } return i }(n, ["nocookie"]), r = `www.youtube${o ? "-nocookie" : ""}.com`, l = je(t, a), c = encodeURIComponent(s[2]); e.videoId = c, e.src = `https://${r}/embed/${c}?${l}`, e.thumbSrc = e.thumbSrc || `https://i.ytimg.com/vi/${c}/mqdefault.jpg`, i = "youtube" } else if (s = t.match(/^.+vimeo.com\/(?:\/)?([\d]+)((\/|\?h=)([a-z0-9]+))?(.*)?/)) { const n = je(t, this.optionFor(e, "vimeo")), o = encodeURIComponent(s[1]), a = s[4] || ""; e.videoId = o, e.src = `https://player.vimeo.com/video/${o}?${a ? `h=${a}${n ? "&" : ""}` : ""}${n}`, i = "vimeo" } if (!i && e.triggerEl) { const t = e.triggerEl.dataset.type; Ve.includes(t) && (i = t) } i || "string" == typeof t && ("#" === t.charAt(0) ? i = "inline" : (s = t.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (i = "html5video", e.videoFormat = e.videoFormat || "video/" + ("ogv" === s[1] ? "ogg" : s[1])) : t.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? i = "image" : t.match(/\.(pdf)((\?|#).*)?$/i) ? i = "pdf" : (s = t.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (e.src = `https://maps.google.${s[1]}/?ll=${(s[2] ? s[2] + "&z=" + Math.floor(parseFloat(s[3])) + (s[4] ? s[4].replace(/^\//, "&") : "") : s[4] + "").replace(/\?/, "&")}&output=${s[4] && s[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, i = "map") : (s = t.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (e.src = `https://maps.google.${s[1]}/maps?q=${s[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, i = "map")), i = i || this.instance.option("defaultType"), e.type = i, "image" === i && (e.thumbSrc = e.thumbSrc || e.src) } setContent(e) { const t = this.instance.optionFor(e, "src") || ""; if (e && e.type && t) { switch (e.type) { case "html": this.instance.setContent(e, t); break; case "html5video": const i = this.option("videoTpl"); i && this.instance.setContent(e, i.replace(/\{\{src\}\}/gi, t + "").replace(/\{\{format\}\}/gi, this.optionFor(e, "videoFormat") || "").replace(/\{\{poster\}\}/gi, e.poster || e.thumbSrc || "")); break; case "inline": case "clone": this.setInlineContent(e); break; case "ajax": this.loadAjaxContent(e); break; case "pdf": case "map": case "youtube": case "vimeo": e.preload = !1; case "iframe": this.setIframeContent(e) }this.setAspectRatio(e) } } setAspectRatio(e) { var t; const i = e.width || 0, s = e.height || 0; if (i && s) return; const n = e.contentEl, o = this.optionFor(e, "videoRatio"), a = null === (t = e.el) || void 0 === t ? void 0 : t.getBoundingClientRect(); if (!(n && a && o && 1 !== o && e.type && ["video", "youtube", "vimeo", "html5video"].includes(e.type))) return; const r = a.width, l = a.height; n.style.aspectRatio = o + "", n.style.width = r / l > o ? "auto" : "", n.style.height = r / l > o ? "" : "auto" } attach() { const e = this, t = e.instance; t.on("Carousel.initSlide", e.onInitSlide), t.on("Carousel.createSlide", e.onCreateSlide), t.on("Carousel.removeSlide", e.onRemoveSlide), t.on("Carousel.selectSlide", e.onSelectSlide), t.on("Carousel.unselectSlide", e.onUnselectSlide), t.on("Carousel.Panzoom.refresh", e.onRefresh), t.on("done", e.onDone), window.addEventListener("message", e.onMessage) } detach() { const e = this, t = e.instance; t.off("Carousel.initSlide", e.onInitSlide), t.off("Carousel.createSlide", e.onCreateSlide), t.off("Carousel.removeSlide", e.onRemoveSlide), t.off("Carousel.selectSlide", e.onSelectSlide), t.off("Carousel.unselectSlide", e.onUnselectSlide), t.off("Carousel.Panzoom.refresh", e.onRefresh), t.off("done", e.onDone), window.removeEventListener("message", e.onMessage) } } Object.defineProperty($e, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: { ajax: null, autoSize: !0, iframeAttr: { allow: "autoplay; fullscreen", scrolling: "auto" }, preload: !0, videoAutoplay: !0, videoRatio: 16 / 9, videoTpl: '<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos.</video>', videoFormat: "", vimeo: { byline: 1, color: "00adef", controls: 1, dnt: 1, muted: 0 }, youtube: { controls: 1, enablejsapi: 1, nocookie: 1, rel: 0, fs: 1 } } }); const Ne = "play", He = "pause", qe = "ready"; class We extends be { constructor() { super(...arguments), Object.defineProperty(this, "state", { enumerable: !0, configurable: !0, writable: !0, value: qe }), Object.defineProperty(this, "inHover", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "timer", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "progressBar", { enumerable: !0, configurable: !0, writable: !0, value: null }) } get isActive() { return this.state !== qe } onReady(e) { this.option("autoStart") && (e.isInfinite || e.page < e.pages.length - 1) && this.start() } onChange() { var e; (null === (e = this.instance.panzoom) || void 0 === e ? void 0 : e.isResting) || (this.removeProgressBar(), this.pause()) } onSettle() { this.resume() } onVisibilityChange() { "visible" === document.visibilityState ? this.resume() : this.pause() } onMouseEnter() { this.inHover = !0, this.pause() } onMouseLeave() { var e; this.inHover = !1, (null === (e = this.instance.panzoom) || void 0 === e ? void 0 : e.isResting) && this.resume() } onTimerEnd() { const e = this.instance; "play" === this.state && (e.isInfinite || e.page !== e.pages.length - 1 ? e.slideNext() : e.slideTo(0)) } removeProgressBar() { this.progressBar && (this.progressBar.remove(), this.progressBar = null) } createProgressBar() { var e; if (!this.option("showProgress")) return null; this.removeProgressBar(); const t = this.instance, i = (null === (e = t.pages[t.page]) || void 0 === e ? void 0 : e.slides) || []; let s = this.option("progressParentEl"); if (s || (s = (1 === i.length ? i[0].el : null) || t.viewport), !s) return null; const n = document.createElement("div"); return ne(n, "f-progress"), s.prepend(n), this.progressBar = n, n.offsetHeight, n } set() { const e = this, t = e.instance; if (t.pages.length < 2) return; if (e.timer) return; const i = e.option("timeout"); e.state = Ne, ne(t.container, "has-autoplay"); let s = e.createProgressBar(); s && (s.style.transitionDuration = `${i}ms`, s.style.transform = "scaleX(1)"), e.timer = setTimeout((() => { e.timer = null, e.inHover || e.onTimerEnd() }), i), e.emit("set") } clear() { const e = this; e.timer && (clearTimeout(e.timer), e.timer = null), e.removeProgressBar() } start() { const e = this; if (e.set(), e.state !== qe) { if (e.option("pauseOnHover")) { const t = e.instance.container; t.addEventListener("mouseenter", e.onMouseEnter, !1), t.addEventListener("mouseleave", e.onMouseLeave, !1) } document.addEventListener("visibilitychange", e.onVisibilityChange, !1), e.emit("start") } } stop() { const e = this, t = e.state, i = e.instance.container; e.clear(), e.state = qe, i.removeEventListener("mouseenter", e.onMouseEnter, !1), i.removeEventListener("mouseleave", e.onMouseLeave, !1), document.removeEventListener("visibilitychange", e.onVisibilityChange, !1), se(i, "has-autoplay"), t !== qe && e.emit("stop") } pause() { const e = this; e.state === Ne && (e.state = He, e.clear(), e.emit(He)) } resume() { const e = this, t = e.instance; if (t.isInfinite || t.page !== t.pages.length - 1) if (e.state !== Ne) { if (e.state === He && !e.inHover) { const t = new Event("resume", { bubbles: !0, cancelable: !0 }); e.emit("resume", t), t.defaultPrevented || e.set() } } else e.set(); else e.stop() } toggle() { this.state === Ne || this.state === He ? this.stop() : this.start() } attach() { const e = this, t = e.instance; t.on("ready", e.onReady), t.on("Panzoom.startAnimation", e.onChange), t.on("Panzoom.endAnimation", e.onSettle), t.on("Panzoom.touchMove", e.onChange) } detach() { const e = this, t = e.instance; t.off("ready", e.onReady), t.off("Panzoom.startAnimation", e.onChange), t.off("Panzoom.endAnimation", e.onSettle), t.off("Panzoom.touchMove", e.onChange), e.stop() } } Object.defineProperty(We, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: { autoStart: !0, pauseOnHover: !0, progressParentEl: null, showProgress: !0, timeout: 3e3 } }); class Ge extends be { constructor() { super(...arguments), Object.defineProperty(this, "ref", { enumerable: !0, configurable: !0, writable: !0, value: null }) } onPrepare(e) { const t = e.carousel; if (!t) return; const i = e.container; i && (t.options.Autoplay = X({ autoStart: !1 }, this.option("Autoplay") || {}, { pauseOnHover: !1, timeout: this.option("timeout"), progressParentEl: () => this.option("progressParentEl") || null, on: { start: () => { e.emit("startSlideshow") }, set: t => { var s; i.classList.add("has-slideshow"), (null === (s = e.getSlide()) || void 0 === s ? void 0 : s.state) !== Fe.Ready && t.pause() }, stop: () => { i.classList.remove("has-slideshow"), e.isCompact || e.endIdle(), e.emit("endSlideshow") }, resume: (t, i) => { var s, n, o; !i || !i.cancelable || (null === (s = e.getSlide()) || void 0 === s ? void 0 : s.state) === Fe.Ready && (null === (o = null === (n = e.carousel) || void 0 === n ? void 0 : n.panzoom) || void 0 === o ? void 0 : o.isResting) || i.preventDefault() } } }), t.attachPlugins({ Autoplay: We }), this.ref = t.plugins.Autoplay) } onReady(e) { const t = e.carousel, i = this.ref; t && i && this.option("playOnStart") && (t.isInfinite || t.page < t.pages.length - 1) && i.start() } onDone(e, t) { const i = this.ref; if (!i) return; const s = t.panzoom; s && s.on("startAnimation", (() => { e.isCurrentSlide(t) && i.stop() })), e.isCurrentSlide(t) && i.resume() } onKeydown(e, t) { var i; const s = this.ref; s && t === this.option("key") && "BUTTON" !== (null === (i = document.activeElement) || void 0 === i ? void 0 : i.nodeName) && s.toggle() } attach() { const e = this, t = e.instance; t.on("Carousel.init", e.onPrepare), t.on("Carousel.ready", e.onReady), t.on("done", e.onDone), t.on("keydown", e.onKeydown) } detach() { const e = this, t = e.instance; t.off("Carousel.init", e.onPrepare), t.off("Carousel.ready", e.onReady), t.off("done", e.onDone), t.off("keydown", e.onKeydown) } } Object.defineProperty(Ge, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: { key: " ", playOnStart: !1, progressParentEl: e => { var t; return (null === (t = e.instance.container) || void 0 === t ? void 0 : t.querySelector(".fancybox__toolbar [data-fancybox-toggle-slideshow]")) || e.instance.container }, timeout: 3e3 } }); const Xe = { classes: { container: "f-thumbs f-carousel__thumbs", viewport: "f-thumbs__viewport", track: "f-thumbs__track", slide: "f-thumbs__slide", isResting: "is-resting", isSelected: "is-selected", isLoading: "is-loading", hasThumbs: "has-thumbs" }, minCount: 2, parentEl: null, thumbTpl: '<button class="f-thumbs__slide__button" tabindex="0" type="button" aria-label="{{GOTO}}" data-carousel-index="%i"><img class="f-thumbs__slide__img" data-lazy-src="{{%s}}" alt="" /></button>', type: "modern" }; var Ye; !function (e) { e[e.Init = 0] = "Init", e[e.Ready = 1] = "Ready", e[e.Hidden = 2] = "Hidden", e[e.Disabled = 3] = "Disabled" }(Ye || (Ye = {})); let Ue = class extends be { constructor() { super(...arguments), Object.defineProperty(this, "type", { enumerable: !0, configurable: !0, writable: !0, value: "modern" }), Object.defineProperty(this, "container", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "track", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "carousel", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "panzoom", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "thumbWidth", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "thumbClipWidth", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "thumbHeight", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "thumbGap", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "thumbExtraGap", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "shouldCenter", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "state", { enumerable: !0, configurable: !0, writable: !0, value: Ye.Init }) } formatThumb(e, t) { return this.instance.localize(t, [["%i", e.index], ["%d", e.index + 1], ["%s", e.thumbSrc || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"]]) } getSlides() { const e = [], t = this.option("thumbTpl") || ""; if (t) for (const i of this.instance.slides || []) { let s = ""; i.type && (s = `for-${i.type}`, i.type && ["video", "youtube", "vimeo", "html5video"].includes(i.type) && (s += " for-video")), e.push({ html: this.formatThumb(i, t), customClass: s }) } return e } onInitSlide(e, t) { const i = t.el; i && (t.thumbSrc = i.dataset.thumbSrc || t.thumbSrc || "", t.thumbClipWidth = parseFloat(i.dataset.thumbClipWidth || "") || t.thumbClipWidth || 0, t.thumbHeight = parseFloat(i.dataset.thumbHeight || "") || t.thumbHeight || 0) } onInitSlides() { this.state === Ye.Init && this.build() } onRefreshM() { this.refreshModern() } onChangeM() { "modern" === this.type && (this.shouldCenter = !0, this.centerModern()) } onClickModern(e) { e.preventDefault(), e.stopPropagation(); const t = this.instance, i = t.page, s = e => { if (e) { const t = e.closest("[data-carousel-index]"); if (t) return parseInt(t.dataset.carouselIndex || "", 10) || 0 } return -1 }, n = (e, t) => { const i = document.elementFromPoint(e, t); return i ? s(i) : -1 }; let o = s(e.target); o < 0 && (o = n(e.clientX + this.thumbGap, e.clientY), o === i && (o = i - 1)), o < 0 && (o = n(e.clientX - this.thumbGap, e.clientY), o === i && (o = i + 1)), o < 0 && (o = (t => { let s = n(e.clientX - t, e.clientY), a = n(e.clientX + t, e.clientY); return o < 0 && s === i && (o = i + 1), o < 0 && a === i && (o = i - 1), o })(this.thumbExtraGap)), o === i ? this.centerModern() : o > -1 && o < t.pages.length && t.slideTo(o) } onTransformM() { if ("modern" !== this.type) return; const { instance: e, container: t, track: i } = this, s = e.panzoom; if (!(t && i && s && this.panzoom)) return; V(t, this.cn("isResting"), s.state !== K.Init && s.isResting); const n = this.thumbGap, o = this.thumbExtraGap, a = this.thumbClipWidth; let r = 0, l = 0, c = 0; for (const t of e.slides) { let i = t.index, s = t.thumbSlideEl; if (!s) continue; V(s, this.cn("isSelected"), i === e.page), l = 1 - Math.abs(e.getProgress(i)), s.style.setProperty("--progress", l ? l + "" : ""); const u = .5 * ((t.thumbWidth || 0) - a); r += n, r += u, l && (r -= l * (u + o)), s.style.setProperty("--shift", r - n + ""), r += u, l && (r -= l * (u + o)), r -= n, 0 === i && (c = o * l) } i && (i.style.setProperty("--left", c + ""), i.style.setProperty("--width", r + c + n + o * l + "")), this.shouldCenter && this.centerModern() } buildClassic() { const { container: e, track: t } = this, i = this.getSlides(); if (!e || !t || !i) return; const s = new this.instance.constructor(e, X({ track: t, infinite: !1, center: !0, fill: !0, dragFree: !0, slidesPerPage: 1, transition: !1, Dots: !1, Navigation: !1, classes: { container: "f-thumbs", viewport: "f-thumbs__viewport", track: "f-thumbs__track", slide: "f-thumbs__slide" } }, this.option("Carousel") || {}, { Sync: { target: this.instance }, slides: i })); this.carousel = s, this.track = t, s.on("ready", (() => { this.emit("ready") })), s.on("createSlide", ((e, t) => { this.emit("createSlide", t, t.el) })) } buildModern() { if ("modern" !== this.type) return; const { container: e, track: t, instance: i } = this, s = this.option("thumbTpl") || ""; if (!e || !t || !s) return; e.addEventListener("keydown", (() => { se(e, "is-using-mouse") })), ne(e, "is-horizontal"), this.updateModern(); for (const e of i.slides || []) { const i = document.createElement("div"); if (ne(i, this.cn("slide")), e.type) { let t = `for-${e.type}`;["video", "youtube", "vimeo", "html5video"].includes(e.type) && (t += " for-video"), ne(i, t) } i.appendChild(R(this.formatThumb(e, s))), this.emit("createSlide", e, i), e.thumbSlideEl = i, t.appendChild(i), this.resizeModernSlide(e) } const n = new i.constructor.Panzoom(e, { content: t, lockAxis: "x", zoom: !1, panOnlyZoomed: !1, bounds: () => { let e = 0, t = 0, s = i.slides[0], n = i.slides[i.slides.length - 1], o = i.slides[i.page]; return s && n && o && (t = -1 * this.getModernThumbPos(0), 0 !== i.page && (t += .5 * (s.thumbWidth || 0)), e = -1 * this.getModernThumbPos(i.slides.length - 1), i.page !== i.slides.length - 1 && (e += (n.thumbWidth || 0) - (o.thumbWidth || 0) - .5 * (n.thumbWidth || 0))), { x: { min: e, max: t }, y: { min: 0, max: 0 } } } }); n.on("touchStart", ((e, t) => { this.shouldCenter = !1, ne(this.container, "is-using-mouse") })), n.on("click", ((e, t) => this.onClickModern(t))), n.on("ready", (() => { this.centerModern(), this.emit("ready") })), n.on(["afterTransform", "refresh"], (e => { this.lazyLoadModern() })), this.panzoom = n, this.refreshModern() } updateModern() { if ("modern" !== this.type) return; const { container: e } = this; e && (this.thumbGap = parseFloat(getComputedStyle(e).getPropertyValue("--f-thumb-gap")) || 0, this.thumbExtraGap = parseFloat(getComputedStyle(e).getPropertyValue("--f-thumb-extra-gap")) || 0, this.thumbWidth = parseFloat(getComputedStyle(e).getPropertyValue("--f-thumb-width")) || 40, this.thumbClipWidth = parseFloat(getComputedStyle(e).getPropertyValue("--f-thumb-clip-width")) || 40, this.thumbHeight = parseFloat(getComputedStyle(e).getPropertyValue("--f-thumb-height")) || 40) } refreshModern() { var e; if ("modern" === this.type) { this.updateModern(); for (const e of this.instance.slides || []) this.resizeModernSlide(e); this.onTransformM(), null === (e = this.panzoom) || void 0 === e || e.updateMetrics(!0), this.centerModern(0) } } centerModern(e) { const t = this.instance, { container: i, panzoom: s } = this; if (!i || !s || s.state === K.Init) return; const n = t.page; let o = this.getModernThumbPos(n), a = o; for (let e = t.page - 3; e < t.page + 3; e++) { if (e < 0 || e > t.pages.length - 1 || e === t.page) continue; const i = 1 - Math.abs(t.getProgress(e)); i > 0 && i < 1 && (a += i * (this.getModernThumbPos(e) - o)) } let r = 100; void 0 === e && (e = .2, t.inTransition.size > 0 && (e = .12), Math.abs(-1 * s.current.e - a) > s.containerRect.width && (e = .5, r = 0)), s.options.maxVelocity = r, s.applyChange({ panX: I(-1 * a - s.target.e, 1e3), friction: null === t.prevPage ? 0 : e }) } lazyLoadModern() { const { instance: e, panzoom: t } = this; if (!t) return; const i = -1 * t.current.e || 0; let s = this.getModernThumbPos(e.page); if (t.state !== K.Init || 0 === s) for (const s of e.slides || []) { const e = s.thumbSlideEl; if (!e) continue; const n = e.querySelector("img[data-lazy-src]"), o = s.index, a = this.getModernThumbPos(o), r = i - .5 * t.containerRect.innerWidth, l = r + t.containerRect.innerWidth; if (!n || a < r || a > l) continue; let c = n.dataset.lazySrc; if (!c || !c.length) continue; if (delete n.dataset.lazySrc, n.src = c, n.complete) continue; ne(e, this.cn("isLoading")); const u = R(te); e.appendChild(u), n.addEventListener("load", (() => { e.offsetParent && (e.classList.remove(this.cn("isLoading")), u.remove()) }), !1) } } resizeModernSlide(e) { if ("modern" !== this.type) return; if (!e.thumbSlideEl) return; const t = e.thumbClipWidth && e.thumbHeight ? Math.round(this.thumbHeight * (e.thumbClipWidth / e.thumbHeight)) : this.thumbWidth; e.thumbWidth = t } getModernThumbPos(e) { const t = this.instance.slides[e], i = this.panzoom; if (!i || !i.contentRect.fitWidth) return 0; let s = i.containerRect.innerWidth, n = i.contentRect.width; 2 === this.instance.slides.length && (e -= 1, n = 2 * this.thumbClipWidth); let o = e * (this.thumbClipWidth + this.thumbGap) + this.thumbExtraGap + .5 * (t.thumbWidth || 0); return o -= n > s ? .5 * s : .5 * n, I(o || 0, 1) } build() { const e = this.instance, t = e.container, i = this.option("minCount") || 0; if (i) { let t = 0; for (const i of e.slides || []) i.thumbSrc && t++; if (t < i) return this.cleanup(), void (this.state = Ye.Disabled) } const s = this.option("type"); if (["modern", "classic"].indexOf(s) < 0) return void (this.state = Ye.Disabled); this.type = s; const n = document.createElement("div"); ne(n, this.cn("container")), ne(n, `is-${s}`); const o = this.option("parentEl"); o ? o.appendChild(n) : t.after(n), this.container = n, ne(t, this.cn("hasThumbs")); const a = document.createElement("div"); ne(a, this.cn("track")), n.appendChild(a), this.track = a, "classic" === s ? this.buildClassic() : this.buildModern(), this.state = Ye.Ready } cleanup() { this.carousel && this.carousel.destroy(), this.carousel = null, this.panzoom && this.panzoom.destroy(), this.panzoom = null, this.container && this.container.remove(), this.container = null, this.track = null, this.state = Ye.Init, se(this.instance.container, this.cn("hasThumbs")) } attach() { const e = this, t = e.instance; t.on("initSlide", e.onInitSlide), t.state === me.Init ? t.on("initSlides", e.onInitSlides) : e.onInitSlides(), t.on("Panzoom.afterTransform", e.onTransformM), t.on("Panzoom.refresh", e.onRefreshM), t.on("change", e.onChangeM) } detach() { const e = this, t = e.instance; t.off("initSlide", e.onInitSlide), t.off("initSlides", e.onInitSlides), t.off("Panzoom.afterTransform", e.onTransformM), t.off("Panzoom.refresh", e.onRefreshM), t.off("change", e.onChangeM), e.cleanup() } }; Object.defineProperty(Ue, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: Xe }); const Ze = Object.assign(Object.assign({}, Xe), { key: "t", showOnStart: !0, parentEl: null }), Ke = "is-masked", Je = "aria-hidden"; class Qe extends be { constructor() { super(...arguments), Object.defineProperty(this, "ref", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "hidden", { enumerable: !0, configurable: !0, writable: !0, value: !1 }) } get isEnabled() { const e = this.ref; return e && e.state !== Ye.Disabled } get isHidden() { return this.hidden } onInit() { var e; const t = this, i = t.instance, s = i.carousel; if (t.ref || !s) return; const n = t.option("parentEl") || i.footer || i.container; if (!n) return; const o = X({}, t.options, { parentEl: n, classes: { container: "f-thumbs fancybox__thumbs" }, Carousel: { Sync: { friction: i.option("Carousel.friction") || 0 } }, on: { ready: e => { const i = e.container; i && this.hidden && (t.refresh(), i.style.transition = "none", t.hide(), i.offsetHeight, queueMicrotask((() => { i.style.transition = "", t.show() }))) } } }); o.Carousel = o.Carousel || {}, o.Carousel.on = X((null === (e = t.options.Carousel) || void 0 === e ? void 0 : e.on) || {}, { click: (e, t) => { t.stopPropagation() } }), s.options.Thumbs = o, s.attachPlugins({ Thumbs: Ue }), t.ref = s.plugins.Thumbs, t.option("showOnStart") || (t.ref.state = Ye.Hidden, t.hidden = !0) } onResize() { var e; const t = null === (e = this.ref) || void 0 === e ? void 0 : e.container; t && (t.style.maxHeight = "") } onKeydown(e, t) { const i = this.option("key"); i && i === t && this.toggle() } toggle() { const e = this.ref; e && e.state !== Ye.Disabled && (e.state !== Ye.Hidden ? this.hidden ? this.show() : this.hide() : e.build()) } show() { const e = this.ref, t = e && e.state !== Ye.Disabled && e.container; t && (this.refresh(), t.offsetHeight, t.removeAttribute(Je), t.classList.remove(Ke), this.hidden = !1) } hide() { const e = this.ref, t = e && e.container; t && (this.refresh(), t.offsetHeight, t.classList.add(Ke), t.setAttribute(Je, "true")), this.hidden = !0 } refresh() { const e = this.ref; if (!e || e.state === Ye.Disabled) return; const t = e.container, i = (null == t ? void 0 : t.firstChild) || null; t && i && i.childNodes.length && (t.style.maxHeight = `${i.getBoundingClientRect().height}px`) } attach() { const e = this, t = e.instance; t.state === De.Init ? t.on("Carousel.init", e.onInit) : e.onInit(), t.on("resize", e.onResize), t.on("keydown", e.onKeydown) } detach() { var e; const t = this, i = t.instance; i.off("Carousel.init", t.onInit), i.off("resize", t.onResize), i.off("keydown", t.onKeydown), null === (e = i.carousel) || void 0 === e || e.detachPlugins(["Thumbs"]), t.ref = null } } Object.defineProperty(Qe, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: Ze }); const et = { panLeft: { icon: '<svg><path d="M5 12h14M5 12l6 6M5 12l6-6"/></svg>', change: { panX: -100 } }, panRight: { icon: '<svg><path d="M5 12h14M13 18l6-6M13 6l6 6"/></svg>', change: { panX: 100 } }, panUp: { icon: '<svg><path d="M12 5v14M18 11l-6-6M6 11l6-6"/></svg>', change: { panY: -100 } }, panDown: { icon: '<svg><path d="M12 5v14M18 13l-6 6M6 13l6 6"/></svg>', change: { panY: 100 } }, zoomIn: { icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M11 8v6M8 11h6"/></svg>', action: "zoomIn" }, zoomOut: { icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "zoomOut" }, toggle1to1: { icon: '<svg><path d="M3.51 3.07c5.74.02 11.48-.02 17.22.02 1.37.1 2.34 1.64 2.18 3.13 0 4.08.02 8.16 0 12.23-.1 1.54-1.47 2.64-2.79 2.46-5.61-.01-11.24.02-16.86-.01-1.36-.12-2.33-1.65-2.17-3.14 0-4.07-.02-8.16 0-12.23.1-1.36 1.22-2.48 2.42-2.46Z"/><path d="M5.65 8.54h1.49v6.92m8.94-6.92h1.49v6.92M11.5 9.4v.02m0 5.18v0"/></svg>', action: "toggleZoom" }, toggleZoom: { icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "toggleZoom" }, iterateZoom: { icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "iterateZoom" }, rotateCCW: { icon: '<svg><path d="M15 4.55a8 8 0 0 0-6 14.9M9 15v5H4M18.37 7.16v.01M13 19.94v.01M16.84 18.37v.01M19.37 15.1v.01M19.94 11v.01"/></svg>', action: "rotateCCW" }, rotateCW: { icon: '<svg><path d="M9 4.55a8 8 0 0 1 6 14.9M15 15v5h5M5.63 7.16v.01M4.06 11v.01M4.63 15.1v.01M7.16 18.37v.01M11 19.94v.01"/></svg>', action: "rotateCW" }, flipX: { icon: '<svg style="stroke-width: 1.3"><path d="M12 3v18M16 7v10h5L16 7M8 7v10H3L8 7"/></svg>', action: "flipX" }, flipY: { icon: '<svg style="stroke-width: 1.3"><path d="M3 12h18M7 16h10L7 21v-5M7 8h10L7 3v5"/></svg>', action: "flipY" }, fitX: { icon: '<svg><path d="M4 12V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6M10 18H3M21 18h-7M6 15l-3 3 3 3M18 15l3 3-3 3"/></svg>', action: "fitX" }, fitY: { icon: '<svg><path d="M12 20H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6M18 14v7M18 3v7M15 18l3 3 3-3M15 6l3-3 3 3"/></svg>', action: "fitY" }, reset: { icon: '<svg><path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"/></svg>', action: "reset" }, toggleFS: { icon: '<svg><g><path d="M14.5 9.5 21 3m0 0h-6m6 0v6M3 21l6.5-6.5M3 21v-6m0 6h6"/></g><g><path d="m14 10 7-7m-7 7h6m-6 0V4M3 21l7-7m0 0v6m0-6H4"/></g></svg>', action: "toggleFS" } }; var tt; !function (e) { e[e.Init = 0] = "Init", e[e.Ready = 1] = "Ready", e[e.Disabled = 2] = "Disabled" }(tt || (tt = {})); const it = { tabindex: "-1", width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }; class st extends be { constructor() { super(...arguments), Object.defineProperty(this, "state", { enumerable: !0, configurable: !0, writable: !0, value: tt.Init }), Object.defineProperty(this, "container", { enumerable: !0, configurable: !0, writable: !0, value: null }) } onReady(e) { var t; if (!e.carousel) return; let i = this.option("display"), s = this.option("absolute"), n = this.option("enabled"); if ("auto" === n) { const e = this.instance.carousel; let t = 0; if (e) for (const i of e.slides) (i.panzoom || "image" === i.type) && t++; t || (n = !1) } n || (i = void 0); let o = 0; const a = { left: [], middle: [], right: [] }; if (i) for (const e of ["left", "middle", "right"]) for (const s of i[e]) { const i = this.createEl(s); i && (null === (t = a[e]) || void 0 === t || t.push(i), o++) } let r = null; if (o && (r = this.createContainer()), r) { for (const [e, t] of Object.entries(a)) { const i = document.createElement("div"); ne(i, "fancybox__toolbar__column is-" + e); for (const e of t) i.appendChild(e); "auto" !== s || "middle" !== e || t.length || (s = !0), r.appendChild(i) } !0 === s && ne(r, "is-absolute"), this.state = tt.Ready, this.onRefresh() } else this.state = tt.Disabled } onClick(e) { var t, i; const s = this.instance, n = s.getSlide(), o = null == n ? void 0 : n.panzoom, a = e.target, r = a && ie(a) ? a.dataset : null; if (!r) return; if (void 0 !== r.fancyboxToggleThumbs) return e.preventDefault(), e.stopPropagation(), void (null === (t = s.plugins.Thumbs) || void 0 === t || t.toggle()); if (void 0 !== r.fancyboxToggleFullscreen) return e.preventDefault(), e.stopPropagation(), void this.instance.toggleFullscreen(); if (void 0 !== r.fancyboxToggleSlideshow) { e.preventDefault(), e.stopPropagation(); const t = null === (i = s.carousel) || void 0 === i ? void 0 : i.plugins.Autoplay; let n = t.isActive; return o && "mousemove" === o.panMode && !n && o.reset(), void (n ? t.stop() : t.start()) } const l = r.panzoomAction, c = r.panzoomChange; if ((c || l) && (e.preventDefault(), e.stopPropagation()), c) { let t = {}; try { t = JSON.parse(c) } catch (e) { } o && o.applyChange(t) } else l && o && o[l] && o[l]() } onChange() { this.onRefresh() } onRefresh() { if (this.instance.isClosing()) return; const e = this.container; if (!e) return; const t = this.instance.getSlide(); if (!t || t.state !== Fe.Ready) return; const i = t && !t.error && t.panzoom; for (const t of e.querySelectorAll("[data-panzoom-action]")) i ? (t.removeAttribute("disabled"), t.removeAttribute("tabindex")) : (t.setAttribute("disabled", ""), t.setAttribute("tabindex", "-1")); let s = i && i.canZoomIn(), n = i && i.canZoomOut(); for (const t of e.querySelectorAll('[data-panzoom-action="zoomIn"]')) s ? (t.removeAttribute("disabled"), t.removeAttribute("tabindex")) : (t.setAttribute("disabled", ""), t.setAttribute("tabindex", "-1")); for (const t of e.querySelectorAll('[data-panzoom-action="zoomOut"]')) n ? (t.removeAttribute("disabled"), t.removeAttribute("tabindex")) : (t.setAttribute("disabled", ""), t.setAttribute("tabindex", "-1")); for (const t of e.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) { n || s ? (t.removeAttribute("disabled"), t.removeAttribute("tabindex")) : (t.setAttribute("disabled", ""), t.setAttribute("tabindex", "-1")); const e = t.querySelector("g"); e && (e.style.display = s ? "" : "none") } } onDone(e, t) { var i; null === (i = t.panzoom) || void 0 === i || i.on("afterTransform", (() => { this.instance.isCurrentSlide(t) && this.onRefresh() })), this.instance.isCurrentSlide(t) && this.onRefresh() } createContainer() { const e = this.instance.container; if (!e) return null; const t = this.option("parentEl") || e, i = document.createElement("div"); return ne(i, "fancybox__toolbar"), t.prepend(i), i.addEventListener("click", this.onClick, { passive: !1, capture: !0 }), e && ne(e, "has-toolbar"), this.container = i, i } createEl(e) { const t = this.instance, i = t.carousel; if (!i) return null; if ("toggleFS" === e) return null; if ("fullscreen" === e && !t.fsAPI) return null; let s = null; const n = i.slides.length || 0; let o = 0, a = 0; for (const e of i.slides) (e.panzoom || "image" === e.type) && o++, ("image" === e.type || e.downloadSrc) && a++; if (n < 2 && ["infobar", "prev", "next"].includes(e)) return s; if (void 0 !== et[e] && !o) return null; if ("download" === e && !a) return null; if ("thumbs" === e) { const e = t.plugins.Thumbs; if (!e || !e.isEnabled) return null } if ("slideshow" === e && (!i.plugins.Autoplay || n < 2)) return null; if (void 0 !== et[e]) { const t = et[e]; s = document.createElement("button"), s.setAttribute("title", this.instance.localize(`{{${e.toUpperCase()}}}`)), ne(s, "f-button"), t.action && (s.dataset.panzoomAction = t.action), t.change && (s.dataset.panzoomChange = JSON.stringify(t.change)), s.appendChild(R(this.instance.localize(t.icon))) } else { const t = (this.option("items") || [])[e]; t && (s = R(this.instance.localize(t.tpl)), "function" == typeof t.click && s.addEventListener("click", (e => { e.preventDefault(), e.stopPropagation(), "function" == typeof t.click && t.click.call(this, this, e) }))) } const r = null == s ? void 0 : s.querySelector("svg"); if (r) for (const [e, t] of Object.entries(it)) r.getAttribute(e) || r.setAttribute(e, String(t)); return s } removeContainer() { const e = this.container; e && e.remove(), this.container = null, this.state = tt.Disabled; const t = this.instance.container; t && se(t, "has-toolbar") } attach() { const e = this, t = e.instance; t.on("Carousel.initSlides", e.onReady), t.on("done", e.onDone), t.on("reveal", e.onChange), t.on("Carousel.change", e.onChange), e.onReady(e.instance) } detach() { const e = this, t = e.instance; t.off("Carousel.initSlides", e.onReady), t.off("done", e.onDone), t.off("reveal", e.onChange), t.off("Carousel.change", e.onChange), e.removeContainer() } } Object.defineProperty(st, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: { absolute: "auto", display: { left: ["infobar"], middle: [], right: ["iterateZoom", "slideshow", "fullscreen", "thumbs", "close"] }, enabled: "auto", items: { infobar: { tpl: '<div class="fancybox__infobar" tabindex="-1"><span data-fancybox-current-index></span>/<span data-fancybox-count></span></div>' }, download: { tpl: '<a class="f-button" title="{{DOWNLOAD}}" data-fancybox-download href="javasript:;"><svg><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5 5-5M12 4v12"/></svg></a>' }, prev: { tpl: '<button class="f-button" title="{{PREV}}" data-fancybox-prev><svg><path d="m15 6-6 6 6 6"/></svg></button>' }, next: { tpl: '<button class="f-button" title="{{NEXT}}" data-fancybox-next><svg><path d="m9 6 6 6-6 6"/></svg></button>' }, slideshow: { tpl: '<button class="f-button" title="{{TOGGLE_SLIDESHOW}}" data-fancybox-toggle-slideshow><svg><g><path d="M8 4v16l13 -8z"></path></g><g><path d="M8 4v15M17 4v15"/></g></svg></button>' }, fullscreen: { tpl: '<button class="f-button" title="{{TOGGLE_FULLSCREEN}}" data-fancybox-toggle-fullscreen><svg><g><path d="M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2M16 4h2a2 2 0 0 1 2 2v2M16 20h2a2 2 0 0 0 2-2v-2"/></g><g><path d="M15 19v-2a2 2 0 0 1 2-2h2M15 5v2a2 2 0 0 0 2 2h2M5 15h2a2 2 0 0 1 2 2v2M5 9h2a2 2 0 0 0 2-2V5"/></g></svg></button>' }, thumbs: { tpl: '<button class="f-button" title="{{TOGGLE_THUMBS}}" data-fancybox-toggle-thumbs><svg><circle cx="5.5" cy="5.5" r="1"/><circle cx="12" cy="5.5" r="1"/><circle cx="18.5" cy="5.5" r="1"/><circle cx="5.5" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="18.5" cy="12" r="1"/><circle cx="5.5" cy="18.5" r="1"/><circle cx="12" cy="18.5" r="1"/><circle cx="18.5" cy="18.5" r="1"/></svg></button>' }, close: { tpl: '<button class="f-button" title="{{CLOSE}}" data-fancybox-close><svg><path d="m19.5 4.5-15 15M4.5 4.5l15 15"/></svg></button>' } }, parentEl: null } }); const nt = { Hash: Be, Html: $e, Images: Re, Slideshow: Ge, Thumbs: Qe, Toolbar: st }, ot = "with-fancybox", at = "hide-scrollbar", rt = "--fancybox-scrollbar-compensate", lt = "--fancybox-body-margin", ct = "is-animated", ut = "is-compact", dt = "is-loading", ht = function () { var e = window.getSelection(); return e && "Range" === e.type }; let pt = null, ft = null; const mt = new Map; let gt = 0; class vt extends Z { get isIdle() { return this.idle } get isCompact() { return this.option("compact") } constructor(e = [], t = {}, i = {}) { super(t), Object.defineProperty(this, "userSlides", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "userPlugins", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "idle", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "idleTimer", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "clickTimer", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "pwt", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "ignoreFocusChange", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "state", { enumerable: !0, configurable: !0, writable: !0, value: De.Init }), Object.defineProperty(this, "id", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "container", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "footer", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "carousel", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "lastFocus", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "prevMouseMoveEvent", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "fsAPI", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.fsAPI = (() => { let e, t = "", i = "", s = ""; return document.fullscreenEnabled ? (t = "requestFullscreen", i = "exitFullscreen", s = "fullscreenElement") : document.webkitFullscreenEnabled && (t = "webkitRequestFullscreen", i = "webkitExitFullscreen", s = "webkitFullscreenElement"), t && (e = { request: function (e) { return "webkitRequestFullscreen" === t ? e[t](Element.ALLOW_KEYBOARD_INPUT) : e[t]() }, exit: function () { return document[s] && document[i]() }, isFullscreen: function () { return document[s] } }), e })(), this.id = t.id || ++gt, mt.set(this.id, this), this.userSlides = e, this.userPlugins = i, queueMicrotask((() => { this.init() })) } init() { if (this.state === De.Destroy) return; this.state = De.Init, this.attachPlugins(Object.assign(Object.assign({}, vt.Plugins), this.userPlugins)), this.emit("init"), !0 === this.option("hideScrollbar") && (() => { if (!Me) return; const e = document.body; if (e.classList.contains(at)) return; let t = window.innerWidth - document.documentElement.getBoundingClientRect().width; t < 0 && (t = 0); const i = e.currentStyle || window.getComputedStyle(e), s = parseFloat(i.marginRight); document.documentElement.style.setProperty(rt, `${t}px`), s && e.style.setProperty(lt, `${s}px`), e.classList.add(at) })(), this.initLayout(), this.scale(); const e = () => { this.initCarousel(this.userSlides), this.state = De.Ready, this.attachEvents(), this.emit("ready"), setTimeout((() => { this.container && this.container.setAttribute("aria-hidden", "false") }), 16) }, t = this.fsAPI; this.option("Fullscreen.autoStart") && t && !t.isFullscreen() ? t.request(this.container).then((() => e())).catch((() => e())) : e() } initLayout() { var e, t; const i = this.option("parentEl") || document.body, s = R(this.localize(this.option("tpl.main") || "")); s && (s.setAttribute("id", `fancybox-${this.id}`), s.setAttribute("aria-label", this.localize("{{MODAL}}")), s.classList.toggle(ut, this.isCompact), ne(s, this.option("mainClass") || ""), this.container = s, this.footer = s.querySelector(".fancybox__footer"), i.appendChild(s), ne(document.documentElement, ot), pt && ft || (pt = document.createElement("span"), ne(pt, "fancybox-focus-guard"), pt.setAttribute("tabindex", "0"), pt.setAttribute("aria-hidden", "true"), pt.setAttribute("aria-label", "Focus guard"), ft = pt.cloneNode(), null === (e = s.parentElement) || void 0 === e || e.insertBefore(pt, s), null === (t = s.parentElement) || void 0 === t || t.append(ft)), this.option("animated") && (ne(s, ct), setTimeout((() => { this.isClosing() || se(s, ct) }), 350)), this.emit("initLayout")) } initCarousel(e) { const t = this.container; if (!t) return; const i = t.querySelector(".fancybox__carousel"); if (!i) return; const s = this.carousel = new Te(i, X({}, { slides: e, transition: "fade", Panzoom: { lockAxis: this.option("dragToClose") ? "xy" : "x", infinite: !!this.option("dragToClose") && "y" }, Dots: !1, Navigation: { classes: { container: "fancybox__nav", button: "f-button", isNext: "is-next", isPrev: "is-prev" } }, initialPage: this.option("startIndex"), l10n: this.option("l10n") }, this.option("Carousel") || {})); s.on("*", ((e, t, ...i) => { this.emit(`Carousel.${t}`, e, ...i) })), s.on(["ready", "change"], (() => { var e; const t = this.getSlide(); t && (null === (e = t.panzoom) || void 0 === e || e.updateControls()), this.manageCaption(t) })), this.on("Carousel.removeSlide", ((e, t, i) => { i.contentEl && (i.contentEl.remove(), i.contentEl = void 0); const s = i.el; s && (se(s, "has-error"), se(s, "has-unknown"), se(s, `has-${i.type || "unknown"}`)), i.closeBtnEl && i.closeBtnEl.remove(), i.closeBtnEl = void 0, i.captionEl && i.captionEl.remove(), i.captionEl = void 0, i.spinnerEl && i.spinnerEl.remove(), i.spinnerEl = void 0, i.state = void 0 })), s.on("Panzoom.touchStart", (() => { var e, t; this.isCompact || this.endIdle(), (null === (e = document.activeElement) || void 0 === e ? void 0 : e.closest(".f-thumbs")) && (null === (t = this.container) || void 0 === t || t.focus()) })), s.on("settle", (() => { this.idleTimer || this.isCompact || !this.option("idle") || this.setIdle(), this.option("autoFocus") && !this.isClosing && this.checkFocus() })), this.option("dragToClose") && (s.on("Panzoom.afterTransform", ((e, t) => { const i = this.getSlide(); if (i && B(i.el)) return; const s = this.container; if (s) { const e = Math.abs(t.current.f), i = e < 1 ? "" : Math.max(.5, Math.min(1, 1 - e / t.contentRect.fitHeight * 1.5)); s.style.setProperty("--fancybox-ts", i ? "0s" : ""), s.style.setProperty("--fancybox-opacity", i + "") } })), s.on("Panzoom.touchEnd", ((e, t, i) => { var s; const n = this.getSlide(); if (n && B(n.el)) return; if (t.isMobile && document.activeElement && -1 !== ["TEXTAREA", "INPUT"].indexOf(null === (s = document.activeElement) || void 0 === s ? void 0 : s.nodeName)) return; const o = Math.abs(t.dragOffset.y); "y" === t.lockedAxis && (o >= 200 || o >= 50 && t.dragOffset.time < 300) && (i && i.cancelable && i.preventDefault(), this.close(i, "f-throwOut" + (t.current.f < 0 ? "Up" : "Down"))) }))), s.on("change", (e => { var t; let i = null === (t = this.getSlide()) || void 0 === t ? void 0 : t.triggerEl; if (i) { const t = new CustomEvent("slideTo", { bubbles: !0, cancelable: !0, detail: e.page }); i.dispatchEvent(t) } })), s.on(["refresh", "change"], (e => { const t = this.container; if (!t) return; for (const i of t.querySelectorAll("[data-fancybox-current-index]")) i.innerHTML = e.page + 1; for (const i of t.querySelectorAll("[data-fancybox-count]")) i.innerHTML = e.pages.length; if (!e.isInfinite) { for (const i of t.querySelectorAll("[data-fancybox-next]")) e.page < e.pages.length - 1 ? (i.removeAttribute("disabled"), i.removeAttribute("tabindex")) : (i.setAttribute("disabled", ""), i.setAttribute("tabindex", "-1")); for (const i of t.querySelectorAll("[data-fancybox-prev]")) e.page > 0 ? (i.removeAttribute("disabled"), i.removeAttribute("tabindex")) : (i.setAttribute("disabled", ""), i.setAttribute("tabindex", "-1")) } const i = this.getSlide(); if (!i) return; let s = i.downloadSrc || ""; s || "image" !== i.type || i.error || "string" != typeof i.src || (s = i.src); const n = "disabled", o = "tabindex", a = "download", r = "href"; for (const e of t.querySelectorAll("[data-fancybox-download]")) { const t = i.downloadFilename; s ? (e.removeAttribute(n), e.removeAttribute(o), e.setAttribute(r, s), e.setAttribute(a, t || s), e.setAttribute("target", "_blank")) : (e.setAttribute(n, ""), e.setAttribute(o, "-1"), e.removeAttribute(r), e.removeAttribute(a)) } })), this.emit("initCarousel") } attachEvents() { const e = this, t = e.container; if (!t) return; t.addEventListener("click", e.onClick, { passive: !1, capture: !1 }), t.addEventListener("wheel", e.onWheel, { passive: !1, capture: !1 }), document.addEventListener("keydown", e.onKeydown, { passive: !1, capture: !0 }), document.addEventListener("visibilitychange", e.onVisibilityChange, !1), document.addEventListener("mousemove", e.onMousemove), e.option("trapFocus") && document.addEventListener("focus", e.onFocus, !0), window.addEventListener("resize", e.onResize); const i = window.visualViewport; i && (i.addEventListener("scroll", e.onResize), i.addEventListener("resize", e.onResize)) } detachEvents() { const e = this, t = e.container; if (!t) return; document.removeEventListener("keydown", e.onKeydown, { passive: !1, capture: !0 }), t.removeEventListener("wheel", e.onWheel, { passive: !1, capture: !1 }), t.removeEventListener("click", e.onClick, { passive: !1, capture: !1 }), document.removeEventListener("mousemove", e.onMousemove), window.removeEventListener("resize", e.onResize); const i = window.visualViewport; i && (i.removeEventListener("resize", e.onResize), i.removeEventListener("scroll", e.onResize)), document.removeEventListener("visibilitychange", e.onVisibilityChange, !1), document.removeEventListener("focus", e.onFocus, !0) } scale() { const e = this.container; if (!e) return; const t = window.visualViewport, i = Math.max(1, (null == t ? void 0 : t.scale) || 1); let s = "", n = "", o = ""; if (t && i > 1) { let e = `${t.offsetLeft}px`, a = `${t.offsetTop}px`; s = t.width * i + "px", n = t.height * i + "px", o = `translate3d(${e}, ${a}, 0) scale(${1 / i})` } e.style.transform = o, e.style.width = s, e.style.height = n } onClick(e) { var t, i; const { container: s, isCompact: n } = this; if (!s || this.isClosing()) return; !n && this.option("idle") && this.resetIdle(); const o = document.activeElement; if (ht() && o && s.contains(o)) return; const a = e.composedPath()[0]; if (a === (null === (t = this.carousel) || void 0 === t ? void 0 : t.container)) return; if (a.closest(".f-spinner") || a.closest("[data-fancybox-close]")) return e.preventDefault(), void this.close(e); if (a.closest("[data-fancybox-prev]")) return e.preventDefault(), void this.prev(); if (a.closest("[data-fancybox-next]")) return e.preventDefault(), void this.next(); if (n && "image" === (null === (i = this.getSlide()) || void 0 === i ? void 0 : i.type)) return void (this.clickTimer ? (clearTimeout(this.clickTimer), this.clickTimer = null) : this.clickTimer = setTimeout((() => { this.toggleIdle(), this.clickTimer = null }), 350)); if (this.emit("click", e), e.defaultPrevented) return; let r = !1; if (a.closest(".fancybox__content")) { if (o) { if (o.closest("[contenteditable]")) return; a.matches(Oe) || o.blur() } if (ht()) return; r = this.option("contentClick") } else a.closest(".fancybox__carousel") && !a.matches(Oe) && (r = this.option("backdropClick")); "close" === r ? (e.preventDefault(), this.close(e)) : "next" === r ? (e.preventDefault(), this.next()) : "prev" === r && (e.preventDefault(), this.prev()) } onWheel(e) { var t; let i = this.option("wheel", e); (null === (t = e.target) || void 0 === t ? void 0 : t.closest(".fancybox__thumbs")) && (i = "slide"); const s = "slide" === i, n = [-e.deltaX || 0, -e.deltaY || 0, -e.detail || 0].reduce((function (e, t) { return Math.abs(t) > Math.abs(e) ? t : e })), o = Math.max(-1, Math.min(1, n)), a = Date.now(); this.pwt && a - this.pwt < 300 ? s && e.preventDefault() : (this.pwt = a, this.emit("wheel", e), e.defaultPrevented || ("close" === i ? (e.preventDefault(), this.close(e)) : "slide" === i && (e.preventDefault(), this[o > 0 ? "prev" : "next"]()))) } onKeydown(e) { if (!this.isTopmost()) return; this.isCompact || !this.option("idle") || this.isClosing() || this.resetIdle(); const t = e.key, i = this.option("keyboard"); if (!i || e.ctrlKey || e.altKey || e.shiftKey) return; const s = e.composedPath()[0], n = document.activeElement && document.activeElement.classList, o = n && n.contains("f-button") || s.dataset.carouselPage || s.dataset.carouselIndex; if ("Escape" !== t && !o && ie(s) && (s.isContentEditable || -1 !== ["TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(s.nodeName))) return; this.emit("keydown", t, e); const a = i[t]; "function" == typeof this[a] && (e.preventDefault(), this[a]()) } onResize() { const e = ut, t = this.container; if (!t) return; const i = this.isCompact; t.classList.toggle(e, i), this.manageCaption(this.getSlide()), this.isCompact ? this.clearIdle() : this.endIdle(), this.scale(), this.emit("resize") } onFocus(e) { this.isTopmost() && this.checkFocus(e) } onMousemove(e) { this.prevMouseMoveEvent = e, !this.isCompact && this.option("idle") && this.resetIdle() } onVisibilityChange() { "visible" === document.visibilityState ? this.checkFocus() : this.endIdle() } manageCloseBtn(e) { const t = this.optionFor(e, "closeButton") || !1; if ("auto" === t) { const e = this.plugins.Toolbar; if (e && e.state === tt.Ready) return } if (!t) return; if (!e.contentEl || e.closeBtnEl) return; const i = this.option("tpl.closeButton"); if (i) { const t = R(this.localize(i)); e.closeBtnEl = e.contentEl.appendChild(t), e.el && ne(e.el, "has-close-btn") } } manageCaption(e = void 0) { var t, i; const s = "fancybox__caption", n = "has-caption", o = this.container; if (!o) return; const a = this.isCompact || this.option("commonCaption"), r = !a; if (this.caption && this.stop(this.caption), r && this.caption && (this.caption.remove(), this.caption = null), a && !this.caption) for (const e of (null === (t = this.carousel) || void 0 === t ? void 0 : t.slides) || []) e.captionEl && (e.captionEl.remove(), e.captionEl = void 0, se(e.el, n), null === (i = e.el) || void 0 === i || i.removeAttribute("aria-labelledby")); if (e || (e = this.getSlide()), !e || a && !this.isCurrentSlide(e)) return; const l = e.el; let c = this.optionFor(e, "caption", ""); if (!c) return void (a && this.caption && this.animate(this.caption, "f-fadeOut", (() => { this.caption && (this.caption.innerHTML = "") }))); let u = null; if (r) { if (u = e.captionEl || null, l && !u) { const t = s + `_${this.id}_${e.index}`; u = document.createElement("div"), ne(u, s), u.setAttribute("id", t), e.captionEl = l.appendChild(u), ne(l, n), l.setAttribute("aria-labelledby", t) } } else u = this.caption, u || (u = o.querySelector("." + s)), u || (u = document.createElement("div"), u.dataset.fancyboxCaption = "", ne(u, s), (this.footer || o).prepend(u)), ne(o, n), this.caption = u; u && (u.innerHTML = "", "string" == typeof c ? u.innerHTML = c : c instanceof HTMLElement && u.appendChild(c)) } checkFocus(e) { var t; const i = document.activeElement || null; i && (null === (t = this.container) || void 0 === t ? void 0 : t.contains(i)) || this.focus(e) } focus(e) { var t; if (this.ignoreFocusChange) return; const i = document.activeElement || null, s = (null == e ? void 0 : e.target) || null, n = this.container, o = this.getSlide(); if (!n || !(null === (t = this.carousel) || void 0 === t ? void 0 : t.viewport)) return; if (!e && i && n.contains(i)) return; const a = o && o.state === Fe.Ready ? o.el : null; if (!a || a.contains(i) || n === i) return; e && e.cancelable && e.preventDefault(), this.ignoreFocusChange = !0; const r = Array.from(n.querySelectorAll(Oe)); let l = [], c = null; for (let e of r) { const t = !e.offsetParent || e.closest('[aria-hidden="true"]'), i = a && a.contains(e), s = !this.carousel.viewport.contains(e); if (e === n || (i || s) && !t) { l.push(e); const t = e.dataset.origTabindex; void 0 !== t && t && (e.tabIndex = parseFloat(t)), e.removeAttribute("data-orig-tabindex"), !e.hasAttribute("autoFocus") && c || (c = e) } else { const t = void 0 === e.dataset.origTabindex ? e.getAttribute("tabindex") || "" : e.dataset.origTabindex; t && (e.dataset.origTabindex = t), e.tabIndex = -1 } } let u = null; e ? (!s || l.indexOf(s) < 0) && (u = c || n, l.length && (i === ft ? u = l[0] : this.lastFocus !== n && i !== pt || (u = l[l.length - 1]))) : u = o && "image" === o.type ? n : c || n, u && _e(u), this.lastFocus = document.activeElement, this.ignoreFocusChange = !1 } next() { const e = this.carousel; e && e.pages.length > 1 && e.slideNext() } prev() { const e = this.carousel; e && e.pages.length > 1 && e.slidePrev() } jumpTo(...e) { this.carousel && this.carousel.slideTo(...e) } isTopmost() { var e; return (null === (e = vt.getInstance()) || void 0 === e ? void 0 : e.id) == this.id } animate(e = null, t = "", i) { if (!e || !t) return void (i && i()); this.stop(e); const s = n => { n.target === e && e.dataset.animationName && (e.removeEventListener("animationend", s), delete e.dataset.animationName, i && i(), se(e, t)) }; e.dataset.animationName = t, e.addEventListener("animationend", s), ne(e, t) } stop(e) { e && e.dispatchEvent(new CustomEvent("animationend", { bubbles: !1, cancelable: !0, currentTarget: e })) } setContent(e, t = "", i = !0) { if (this.isClosing()) return; const s = e.el; if (!s) return; let n = null; if (ie(t) ? n = t : (n = R(t + ""), ie(n) || (n = document.createElement("div"), n.innerHTML = t + "")), ["img", "picture", "iframe", "video", "audio"].includes(n.nodeName.toLowerCase())) { const e = document.createElement("div"); e.appendChild(n), n = e } ie(n) && e.filter && !e.error && (n = n.querySelector(e.filter)), n && ie(n) ? (ne(n, "fancybox__content"), e.id && n.setAttribute("id", e.id), "none" !== n.style.display && "none" !== getComputedStyle(n).getPropertyValue("display") || (n.style.display = e.display || this.option("defaultDisplay") || "flex"), s.classList.add(`has-${e.error ? "error" : e.type || "unknown"}`), s.prepend(n), e.contentEl = n, i && this.revealContent(e), this.manageCloseBtn(e), this.manageCaption(e)) : this.setError(e, "{{ELEMENT_NOT_FOUND}}") } revealContent(e, t) { const i = e.el, s = e.contentEl; i && s && (this.emit("reveal", e), this.hideLoading(e), e.state = Fe.Opening, (t = this.isOpeningSlide(e) ? void 0 === t ? this.optionFor(e, "showClass") : t : "f-fadeIn") ? this.animate(s, t, (() => { this.done(e) })) : this.done(e)) } done(e) { this.isClosing() || (e.state = Fe.Ready, this.emit("done", e), ne(e.el, "is-done"), this.isCurrentSlide(e) && this.option("autoFocus") && queueMicrotask((() => { this.option("autoFocus") && (this.option("autoFocus") ? this.focus() : this.checkFocus()) })), this.isOpeningSlide(e) && !this.isCompact && this.option("idle") && this.setIdle()) } isCurrentSlide(e) { const t = this.getSlide(); return !(!e || !t) && t.index === e.index } isOpeningSlide(e) { var t, i; return null === (null === (t = this.carousel) || void 0 === t ? void 0 : t.prevPage) && e.index === (null === (i = this.getSlide()) || void 0 === i ? void 0 : i.index) } showLoading(e) { e.state = Fe.Loading; const t = e.el; t && (ne(t, dt), this.emit("loading", e), e.spinnerEl || setTimeout((() => { if (!this.isClosing() && !e.spinnerEl && e.state === Fe.Loading) { let i = R(te); e.spinnerEl = i, t.prepend(i), this.animate(i, "f-fadeIn") } }), 250)) } hideLoading(e) { const t = e.el; if (!t) return; const i = e.spinnerEl; this.isClosing() ? null == i || i.remove() : (se(t, dt), i && this.animate(i, "f-fadeOut", (() => { i.remove() })), e.state === Fe.Loading && (this.emit("loaded", e), e.state = Fe.Ready)) } setError(e, t) { if (this.isClosing()) return; const i = new Event("error", { bubbles: !0, cancelable: !0 }); if (this.emit("error", i, e), i.defaultPrevented) return; e.error = t, this.hideLoading(e), this.clearContent(e); const s = document.createElement("div"); s.classList.add("fancybox-error"), s.innerHTML = this.localize(t || "<p>{{ERROR}}</p>"), this.setContent(e, s) } clearContent(e) { var t; null === (t = this.carousel) || void 0 === t || t.emit("removeSlide", e) } getSlide() { var e; const t = this.carousel; return (null === (e = null == t ? void 0 : t.pages[null == t ? void 0 : t.page]) || void 0 === e ? void 0 : e.slides[0]) || void 0 } close(e, t) { if (this.isClosing()) return; const i = new Event("shouldClose", { bubbles: !0, cancelable: !0 }); if (this.emit("shouldClose", i, e), i.defaultPrevented) return; e && e.cancelable && (e.preventDefault(), e.stopPropagation()); const s = this.fsAPI, n = () => { this.proceedClose(e, t) }; s && s.isFullscreen() ? Promise.resolve(s.exit()).then((() => n())) : n() } clearIdle() { this.idleTimer && clearTimeout(this.idleTimer), this.idleTimer = null } setIdle(e = !1) { const t = () => { this.clearIdle(), this.idle = !0, ne(this.container, "is-idle"), this.emit("setIdle") }; if (this.clearIdle(), !this.isClosing()) if (e) t(); else { const e = this.option("idle"); e && (this.idleTimer = setTimeout(t, e)) } } endIdle() { this.clearIdle(), this.idle && !this.isClosing() && (this.idle = !1, se(this.container, "is-idle"), this.emit("endIdle")) } resetIdle() { this.endIdle(), this.setIdle() } toggleIdle() { this.idle ? this.endIdle() : this.setIdle(!0) } toggleFullscreen() { const e = this.fsAPI; e && (e.isFullscreen() ? e.exit() : this.container && e.request(this.container)) } isClosing() { return [De.Closing, De.CustomClosing, De.Destroy].includes(this.state) } proceedClose(e, t) { var i, s; this.state = De.Closing, this.clearIdle(), this.detachEvents(); const n = this.container, o = this.carousel, a = this.getSlide(), r = a && this.option("placeFocusBack") ? a.triggerEl || this.option("triggerEl") : null; if (r && (Ae(r) ? _e(r) : r.focus()), n && (ne(n, "is-closing"), n.setAttribute("aria-hidden", "true"), this.option("animated") && ne(n, ct), n.style.pointerEvents = "none"), o) { o.clearTransitions(), null === (i = o.panzoom) || void 0 === i || i.destroy(), null === (s = o.plugins.Navigation) || void 0 === s || s.detach(); for (const e of o.slides) { e.state = Fe.Closing, this.hideLoading(e); const t = e.contentEl; t && this.stop(t); const i = null == e ? void 0 : e.panzoom; i && (i.stop(), i.detachEvents(), i.detachObserver()), this.isCurrentSlide(e) || o.emit("removeSlide", e) } } this.emit("close", e), this.state !== De.CustomClosing ? (void 0 === t && a && (t = this.optionFor(a, "hideClass")), t && a ? (this.animate(a.contentEl, t, (() => { o && o.emit("removeSlide", a) })), setTimeout((() => { this.destroy() }), 500)) : this.destroy()) : setTimeout((() => { this.destroy() }), 500) } destroy() { var e; if (this.state === De.Destroy) return; this.state = De.Destroy, null === (e = this.carousel) || void 0 === e || e.destroy(); const t = this.container; t && t.remove(), mt.delete(this.id); const i = vt.getInstance(); i ? i.focus() : (pt && (pt.remove(), pt = null), ft && (ft.remove(), ft = null), se(document.documentElement, ot), (() => { if (!Me) return; const e = document, t = e.body; t.classList.remove(at), t.style.setProperty(lt, ""), e.documentElement.style.setProperty(rt, "") })(), this.emit("destroy")) } static bind(e, t, i) { if (!Me) return; let s, n = "", o = {}; if (void 0 === e ? s = document.body : "string" == typeof e ? (s = document.body, n = e, "object" == typeof t && (o = t || {})) : (s = e, "string" == typeof t && (n = t), "object" == typeof i && (o = i || {})), !s || !ie(s)) return; n = n || "[data-fancybox]"; const a = vt.openers.get(s) || new Map; a.set(n, o), vt.openers.set(s, a), 1 === a.size && s.addEventListener("click", vt.fromEvent) } static unbind(e, t) { let i, s = ""; if ("string" == typeof e ? (i = document.body, s = e) : (i = e, "string" == typeof t && (s = t)), !i) return; const n = vt.openers.get(i); n && s && n.delete(s), s && n || (vt.openers.delete(i), i.removeEventListener("click", vt.fromEvent)) } static destroy() { let e; for (; e = vt.getInstance();)e.destroy(); for (const e of vt.openers.keys()) e.removeEventListener("click", vt.fromEvent); vt.openers = new Map } static fromEvent(e) { if (e.defaultPrevented) return; if (e.button && 0 !== e.button) return; if (e.ctrlKey || e.metaKey || e.shiftKey) return; let t = e.composedPath()[0]; const i = t.closest("[data-fancybox-trigger]"); if (i) { const e = i.dataset.fancyboxTrigger || "", s = document.querySelectorAll(`[data-fancybox="${e}"]`), n = parseInt(i.dataset.fancyboxIndex || "", 10) || 0; t = s[n] || t } if (!(t && t instanceof Element)) return; let s, n, o, a; if ([...vt.openers].reverse().find((([e, i]) => !(!e.contains(t) || ![...i].reverse().find((([i, r]) => { let l = t.closest(i); return !!l && (s = e, n = i, o = l, a = r, !0) }))))), !s || !n || !o) return; a = a || {}, e.preventDefault(), t = o; let r = [], l = X({}, Le, a); l.event = e, l.triggerEl = t, l.delegate = i; const c = l.groupAll, u = l.groupAttr, d = u && t ? t.getAttribute(`${u}`) : ""; if ((!t || d || c) && (r = [].slice.call(s.querySelectorAll(n))), t && !c && (r = d ? r.filter((e => e.getAttribute(`${u}`) === d)) : [t]), !r.length) return; const h = vt.getInstance(); return h && h.options.triggerEl && r.indexOf(h.options.triggerEl) > -1 ? void 0 : (t && (l.startIndex = r.indexOf(t)), vt.fromNodes(r, l)) } static fromSelector(e, t) { let i = null, s = ""; if ("string" == typeof e ? (i = document.body, s = e) : e instanceof HTMLElement && "string" == typeof t && (i = e, s = t), !i || !s) return !1; const n = vt.openers.get(i); if (!n) return !1; const o = n.get(s); return !!o && vt.fromNodes(Array.from(i.querySelectorAll(s)), o) } static fromNodes(e, t) { t = X({}, Le, t || {}); const i = []; for (const s of e) { const e = s.dataset || {}, n = e.src || s.getAttribute("href") || s.getAttribute("currentSrc") || s.getAttribute("src") || void 0; let o; const a = t.delegate; let r; a && i.length === t.startIndex && (o = a instanceof HTMLImageElement ? a : a.querySelector("img:not([aria-hidden])")), o || (o = s instanceof HTMLImageElement ? s : s.querySelector("img:not([aria-hidden])")), o && (r = o.currentSrc || o.src || void 0, !r && o.dataset && (r = o.dataset.lazySrc || o.dataset.src || void 0)); const l = { src: n, triggerEl: s, thumbEl: o, thumbElSrc: r, thumbSrc: r }; for (const t in e) l[t] = e[t] + ""; i.push(l) } return new vt(i, t) } static getInstance(e) { return e ? mt.get(e) : Array.from(mt.values()).reverse().find((e => !e.isClosing() && e)) || null } static getSlide() { var e; return (null === (e = vt.getInstance()) || void 0 === e ? void 0 : e.getSlide()) || null } static show(e = [], t = {}) { return new vt(e, t) } static next() { const e = vt.getInstance(); e && e.next() } static prev() { const e = vt.getInstance(); e && e.prev() } static close(e = !0, ...t) { if (e) for (const e of mt.values()) e.close(...t); else { const e = vt.getInstance(); e && e.close(...t) } } } Object.defineProperty(vt, "version", { enumerable: !0, configurable: !0, writable: !0, value: "5.0.22" }), Object.defineProperty(vt, "defaults", { enumerable: !0, configurable: !0, writable: !0, value: Le }), Object.defineProperty(vt, "Plugins", { enumerable: !0, configurable: !0, writable: !0, value: nt }), Object.defineProperty(vt, "openers", { enumerable: !0, configurable: !0, writable: !0, value: new Map }); var bt = i(957); function yt(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function wt(e = {}, t = {}) { Object.keys(t).forEach((i => { void 0 === e[i] ? e[i] = t[i] : yt(t[i]) && yt(e[i]) && Object.keys(t[i]).length > 0 && wt(e[i], t[i]) })) } const Et = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function St() { const e = "undefined" != typeof document ? document : {}; return wt(e, Et), e } const Ct = { document: Et, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function xt() { const e = "undefined" != typeof window ? window : {}; return wt(e, Ct), e } class kt extends Array { constructor(e) { "number" == typeof e ? super(e) : (super(...e || []), function (e) { const t = e.__proto__; Object.defineProperty(e, "__proto__", { get: () => t, set(e) { t.__proto__ = e } }) }(this)) } } function Tt(e = []) { const t = []; return e.forEach((e => { Array.isArray(e) ? t.push(...Tt(e)) : t.push(e) })), t } function At(e, t) { return Array.prototype.filter.call(e, t) } function Mt(e, t) { const i = xt(), s = St(); let n = []; if (!t && e instanceof kt) return e; if (!e) return new kt(n); if ("string" == typeof e) { const i = e.trim(); if (i.indexOf("<") >= 0 && i.indexOf(">") >= 0) { let e = "div"; 0 === i.indexOf("<li") && (e = "ul"), 0 === i.indexOf("<tr") && (e = "tbody"), 0 !== i.indexOf("<td") && 0 !== i.indexOf("<th") || (e = "tr"), 0 === i.indexOf("<tbody") && (e = "table"), 0 === i.indexOf("<option") && (e = "select"); const t = s.createElement(e); t.innerHTML = i; for (let e = 0; e < t.childNodes.length; e += 1)n.push(t.childNodes[e]) } else n = function (e, t) { if ("string" != typeof e) return [e]; const i = [], s = t.querySelectorAll(e); for (let e = 0; e < s.length; e += 1)i.push(s[e]); return i }(e.trim(), t || s) } else if (e.nodeType || e === i || e === s) n.push(e); else if (Array.isArray(e)) { if (e instanceof kt) return e; n = e } return new kt(function (e) { const t = []; for (let i = 0; i < e.length; i += 1)-1 === t.indexOf(e[i]) && t.push(e[i]); return t }(n)) } Mt.fn = kt.prototype; const Pt = "resize scroll".split(" "); function Ot(e) { return function (...t) { if (void 0 === t[0]) { for (let t = 0; t < this.length; t += 1)Pt.indexOf(e) < 0 && (e in this[t] ? this[t][e]() : Mt(this[t]).trigger(e)); return this } return this.on(e, ...t) } } Ot("click"), Ot("blur"), Ot("focus"), Ot("focusin"), Ot("focusout"), Ot("keyup"), Ot("keydown"), Ot("keypress"), Ot("submit"), Ot("change"), Ot("mousedown"), Ot("mousemove"), Ot("mouseup"), Ot("mouseenter"), Ot("mouseleave"), Ot("mouseout"), Ot("mouseover"), Ot("touchstart"), Ot("touchend"), Ot("touchmove"), Ot("resize"), Ot("scroll"); const _t = { addClass: function (...e) { const t = Tt(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.add(...t) })), this }, removeClass: function (...e) { const t = Tt(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.remove(...t) })), this }, hasClass: function (...e) { const t = Tt(e.map((e => e.split(" ")))); return At(this, (e => t.filter((t => e.classList.contains(t))).length > 0)).length > 0 }, toggleClass: function (...e) { const t = Tt(e.map((e => e.split(" ")))); this.forEach((e => { t.forEach((t => { e.classList.toggle(t) })) })) }, attr: function (e, t) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let i = 0; i < this.length; i += 1)if (2 === arguments.length) this[i].setAttribute(e, t); else for (const t in e) this[i][t] = e[t], this[i].setAttribute(t, e[t]); return this }, removeAttr: function (e) { for (let t = 0; t < this.length; t += 1)this[t].removeAttribute(e); return this }, transform: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transform = e; return this }, transition: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e; return this }, on: function (...e) { let [t, i, s, n] = e; function o(e) { const t = e.target; if (!t) return; const n = e.target.dom7EventData || []; if (n.indexOf(e) < 0 && n.unshift(e), Mt(t).is(i)) s.apply(t, n); else { const e = Mt(t).parents(); for (let t = 0; t < e.length; t += 1)Mt(e[t]).is(i) && s.apply(e[t], n) } } function a(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), s.apply(this, t) } "function" == typeof e[1] && ([t, s, n] = e, i = void 0), n || (n = !1); const r = t.split(" "); let l; for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (i) for (l = 0; l < r.length; l += 1) { const e = r[l]; t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({ listener: s, proxyListener: o }), t.addEventListener(e, o, n) } else for (l = 0; l < r.length; l += 1) { const e = r[l]; t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: s, proxyListener: a }), t.addEventListener(e, a, n) } } return this }, off: function (...e) { let [t, i, s, n] = e; "function" == typeof e[1] && ([t, s, n] = e, i = void 0), n || (n = !1); const o = t.split(" "); for (let e = 0; e < o.length; e += 1) { const t = o[e]; for (let e = 0; e < this.length; e += 1) { const o = this[e]; let a; if (!i && o.dom7Listeners ? a = o.dom7Listeners[t] : i && o.dom7LiveListeners && (a = o.dom7LiveListeners[t]), a && a.length) for (let e = a.length - 1; e >= 0; e -= 1) { const i = a[e]; s && i.listener === s || s && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === s ? (o.removeEventListener(t, i.proxyListener, n), a.splice(e, 1)) : s || (o.removeEventListener(t, i.proxyListener, n), a.splice(e, 1)) } } } return this }, trigger: function (...e) { const t = xt(), i = e[0].split(" "), s = e[1]; for (let n = 0; n < i.length; n += 1) { const o = i[n]; for (let i = 0; i < this.length; i += 1) { const n = this[i]; if (t.CustomEvent) { const i = new t.CustomEvent(o, { detail: s, bubbles: !0, cancelable: !0 }); n.dom7EventData = e.filter(((e, t) => t > 0)), n.dispatchEvent(i), n.dom7EventData = [], delete n.dom7EventData } } } return this }, transitionEnd: function (e) { const t = this; return e && t.on("transitionend", (function i(s) { s.target === this && (e.call(this, s), t.off("transitionend", i)) })), this }, outerWidth: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, styles: function () { const e = xt(); return this[0] ? e.getComputedStyle(this[0], null) : {} }, offset: function () { if (this.length > 0) { const e = xt(), t = St(), i = this[0], s = i.getBoundingClientRect(), n = t.body, o = i.clientTop || n.clientTop || 0, a = i.clientLeft || n.clientLeft || 0, r = i === e ? e.scrollY : i.scrollTop, l = i === e ? e.scrollX : i.scrollLeft; return { top: s.top + r - o, left: s.left + l - a } } return null }, css: function (e, t) { const i = xt(); let s; if (1 === arguments.length) { if ("string" != typeof e) { for (s = 0; s < this.length; s += 1)for (const t in e) this[s].style[t] = e[t]; return this } if (this[0]) return i.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (s = 0; s < this.length; s += 1)this[s].style[e] = t; return this } return this }, each: function (e) { return e ? (this.forEach(((t, i) => { e.apply(t, [t, i]) })), this) : this }, html: function (e) { if (void 0 === e) return this[0] ? this[0].innerHTML : null; for (let t = 0; t < this.length; t += 1)this[t].innerHTML = e; return this }, text: function (e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1)this[t].textContent = e; return this }, is: function (e) { const t = xt(), i = St(), s = this[0]; let n, o; if (!s || void 0 === e) return !1; if ("string" == typeof e) { if (s.matches) return s.matches(e); if (s.webkitMatchesSelector) return s.webkitMatchesSelector(e); if (s.msMatchesSelector) return s.msMatchesSelector(e); for (n = Mt(e), o = 0; o < n.length; o += 1)if (n[o] === s) return !0; return !1 } if (e === i) return s === i; if (e === t) return s === t; if (e.nodeType || e instanceof kt) { for (n = e.nodeType ? [e] : e, o = 0; o < n.length; o += 1)if (n[o] === s) return !0; return !1 } return !1 }, index: function () { let e, t = this[0]; if (t) { for (e = 0; null !== (t = t.previousSibling);)1 === t.nodeType && (e += 1); return e } }, eq: function (e) { if (void 0 === e) return this; const t = this.length; if (e > t - 1) return Mt([]); if (e < 0) { const i = t + e; return Mt(i < 0 ? [] : [this[i]]) } return Mt([this[e]]) }, append: function (...e) { let t; const i = St(); for (let s = 0; s < e.length; s += 1) { t = e[s]; for (let e = 0; e < this.length; e += 1)if ("string" == typeof t) { const s = i.createElement("div"); for (s.innerHTML = t; s.firstChild;)this[e].appendChild(s.firstChild) } else if (t instanceof kt) for (let i = 0; i < t.length; i += 1)this[e].appendChild(t[i]); else this[e].appendChild(t) } return this }, prepend: function (e) { const t = St(); let i, s; for (i = 0; i < this.length; i += 1)if ("string" == typeof e) { const n = t.createElement("div"); for (n.innerHTML = e, s = n.childNodes.length - 1; s >= 0; s -= 1)this[i].insertBefore(n.childNodes[s], this[i].childNodes[0]) } else if (e instanceof kt) for (s = 0; s < e.length; s += 1)this[i].insertBefore(e[s], this[i].childNodes[0]); else this[i].insertBefore(e, this[i].childNodes[0]); return this }, next: function (e) { return this.length > 0 ? e ? this[0].nextElementSibling && Mt(this[0].nextElementSibling).is(e) ? Mt([this[0].nextElementSibling]) : Mt([]) : this[0].nextElementSibling ? Mt([this[0].nextElementSibling]) : Mt([]) : Mt([]) }, nextAll: function (e) { const t = []; let i = this[0]; if (!i) return Mt([]); for (; i.nextElementSibling;) { const s = i.nextElementSibling; e ? Mt(s).is(e) && t.push(s) : t.push(s), i = s } return Mt(t) }, prev: function (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && Mt(t.previousElementSibling).is(e) ? Mt([t.previousElementSibling]) : Mt([]) : t.previousElementSibling ? Mt([t.previousElementSibling]) : Mt([]) } return Mt([]) }, prevAll: function (e) { const t = []; let i = this[0]; if (!i) return Mt([]); for (; i.previousElementSibling;) { const s = i.previousElementSibling; e ? Mt(s).is(e) && t.push(s) : t.push(s), i = s } return Mt(t) }, parent: function (e) { const t = []; for (let i = 0; i < this.length; i += 1)null !== this[i].parentNode && (e ? Mt(this[i].parentNode).is(e) && t.push(this[i].parentNode) : t.push(this[i].parentNode)); return Mt(t) }, parents: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { let s = this[i].parentNode; for (; s;)e ? Mt(s).is(e) && t.push(s) : t.push(s), s = s.parentNode } return Mt(t) }, closest: function (e) { let t = this; return void 0 === e ? Mt([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const s = this[i].querySelectorAll(e); for (let e = 0; e < s.length; e += 1)t.push(s[e]) } return Mt(t) }, children: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const s = this[i].children; for (let i = 0; i < s.length; i += 1)e && !Mt(s[i]).is(e) || t.push(s[i]) } return Mt(t) }, filter: function (e) { return Mt(At(this, e)) }, remove: function () { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } }; Object.keys(_t).forEach((e => { Object.defineProperty(Mt.fn, e, { value: _t[e], writable: !0 }) })); const Lt = Mt; function Dt(e, t = 0) { return setTimeout(e, t) } function Ft() { return Date.now() } function It(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function Bt(...e) { const t = Object(e[0]), i = ["__proto__", "constructor", "prototype"]; for (let n = 1; n < e.length; n += 1) { const o = e[n]; if (null != o && (s = o, !("undefined" != typeof window && void 0 !== window.HTMLElement ? s instanceof HTMLElement : s && (1 === s.nodeType || 11 === s.nodeType)))) { const e = Object.keys(Object(o)).filter((e => i.indexOf(e) < 0)); for (let i = 0, s = e.length; i < s; i += 1) { const s = e[i], n = Object.getOwnPropertyDescriptor(o, s); void 0 !== n && n.enumerable && (It(t[s]) && It(o[s]) ? o[s].__swiper__ ? t[s] = o[s] : Bt(t[s], o[s]) : !It(t[s]) && It(o[s]) ? (t[s] = {}, o[s].__swiper__ ? t[s] = o[s] : Bt(t[s], o[s])) : t[s] = o[s]) } } } var s; return t } function zt(e, t, i) { e.style.setProperty(t, i) } function Rt({ swiper: e, targetPosition: t, side: i }) { const s = xt(), n = -e.translate; let o, a = null; const r = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", s.cancelAnimationFrame(e.cssModeFrameID); const l = t > n ? "next" : "prev", c = (e, t) => "next" === l && e >= t || "prev" === l && e <= t, u = () => { o = (new Date).getTime(), null === a && (a = o); const l = Math.max(Math.min((o - a) / r, 1), 0), d = .5 - Math.cos(l * Math.PI) / 2; let h = n + d * (t - n); if (c(h, t) && (h = t), e.wrapperEl.scrollTo({ [i]: h }), c(h, t)) return e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout((() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [i]: h }) })), void s.cancelAnimationFrame(e.cssModeFrameID); e.cssModeFrameID = s.requestAnimationFrame(u) }; u() } let jt, Vt, $t; function Nt() { return jt || (jt = function () { const e = xt(), t = St(); return { smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch), passiveListener: function () { let t = !1; try { const i = Object.defineProperty({}, "passive", { get() { t = !0 } }); e.addEventListener("testPassiveListener", null, i) } catch (e) { } return t }(), gestures: "ongesturestart" in e } }()), jt } const Ht = { on(e, t, i) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if ("function" != typeof t) return s; const n = i ? "unshift" : "push"; return e.split(" ").forEach((e => { s.eventsListeners[e] || (s.eventsListeners[e] = []), s.eventsListeners[e][n](t) })), s }, once(e, t, i) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if ("function" != typeof t) return s; function n(...i) { s.off(e, n), n.__emitterProxy && delete n.__emitterProxy, t.apply(s, i) } return n.__emitterProxy = t, s.on(e, n, i) }, onAny(e, t) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof e) return i; const s = t ? "unshift" : "push"; return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[s](e), i }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const i = t.eventsAnyListeners.indexOf(e); return i >= 0 && t.eventsAnyListeners.splice(i, 1), t }, off(e, t) { const i = this; return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach(((s, n) => { (s === t || s.__emitterProxy && s.__emitterProxy === t) && i.eventsListeners[e].splice(n, 1) })) })), i) : i }, emit(...e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsListeners) return t; let i, s, n; return "string" == typeof e[0] || Array.isArray(e[0]) ? (i = e[0], s = e.slice(1, e.length), n = t) : (i = e[0].events, s = e[0].data, n = e[0].context || t), s.unshift(n), (Array.isArray(i) ? i : i.split(" ")).forEach((e => { t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach((t => { t.apply(n, [e, ...s]) })), t.eventsListeners && t.eventsListeners[e] && t.eventsListeners[e].forEach((e => { e.apply(n, s) })) })), t } }, qt = { updateSize: function () { const e = this; let t, i; const s = e.$el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : s[0].clientWidth, i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : s[0].clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(s.css("padding-left") || 0, 10) - parseInt(s.css("padding-right") || 0, 10), i = i - parseInt(s.css("padding-top") || 0, 10) - parseInt(s.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(i) && (i = 0), Object.assign(e, { width: t, height: i, size: e.isHorizontal() ? t : i })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function i(e, i) { return parseFloat(e.getPropertyValue(t(i)) || 0) } const s = e.params, { $wrapperEl: n, size: o, rtlTranslate: a, wrongRTL: r } = e, l = e.virtual && s.virtual.enabled, c = l ? e.virtual.slides.length : e.slides.length, u = n.children(`.${e.params.slideClass}`), d = l ? e.virtual.slides.length : u.length; let h = []; const p = [], f = []; let m = s.slidesOffsetBefore; "function" == typeof m && (m = s.slidesOffsetBefore.call(e)); let g = s.slidesOffsetAfter; "function" == typeof g && (g = s.slidesOffsetAfter.call(e)); const v = e.snapGrid.length, b = e.slidesGrid.length; let y = s.spaceBetween, w = -m, E = 0, S = 0; if (void 0 === o) return; "string" == typeof y && y.indexOf("%") >= 0 && (y = parseFloat(y.replace("%", "")) / 100 * o), e.virtualSize = -y, a ? u.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : u.css({ marginRight: "", marginBottom: "", marginTop: "" }), s.centeredSlides && s.cssMode && (zt(e.wrapperEl, "--swiper-centered-offset-before", ""), zt(e.wrapperEl, "--swiper-centered-offset-after", "")); const C = s.grid && s.grid.rows > 1 && e.grid; let x; C && e.grid.initSlides(d); const k = "auto" === s.slidesPerView && s.breakpoints && Object.keys(s.breakpoints).filter((e => void 0 !== s.breakpoints[e].slidesPerView)).length > 0; for (let n = 0; n < d; n += 1) { x = 0; const a = u.eq(n); if (C && e.grid.updateSlide(n, a, d, t), "none" !== a.css("display")) { if ("auto" === s.slidesPerView) { k && (u[n].style[t("width")] = ""); const o = getComputedStyle(a[0]), r = a[0].style.transform, l = a[0].style.webkitTransform; if (r && (a[0].style.transform = "none"), l && (a[0].style.webkitTransform = "none"), s.roundLengths) x = e.isHorizontal() ? a.outerWidth(!0) : a.outerHeight(!0); else { const e = i(o, "width"), t = i(o, "padding-left"), s = i(o, "padding-right"), n = i(o, "margin-left"), r = i(o, "margin-right"), l = o.getPropertyValue("box-sizing"); if (l && "border-box" === l) x = e + n + r; else { const { clientWidth: i, offsetWidth: o } = a[0]; x = e + t + s + n + r + (o - i) } } r && (a[0].style.transform = r), l && (a[0].style.webkitTransform = l), s.roundLengths && (x = Math.floor(x)) } else x = (o - (s.slidesPerView - 1) * y) / s.slidesPerView, s.roundLengths && (x = Math.floor(x)), u[n] && (u[n].style[t("width")] = `${x}px`); u[n] && (u[n].swiperSlideSize = x), f.push(x), s.centeredSlides ? (w = w + x / 2 + E / 2 + y, 0 === E && 0 !== n && (w = w - o / 2 - y), 0 === n && (w = w - o / 2 - y), Math.abs(w) < .001 && (w = 0), s.roundLengths && (w = Math.floor(w)), S % s.slidesPerGroup == 0 && h.push(w), p.push(w)) : (s.roundLengths && (w = Math.floor(w)), (S - Math.min(e.params.slidesPerGroupSkip, S)) % e.params.slidesPerGroup == 0 && h.push(w), p.push(w), w = w + x + y), e.virtualSize += x + y, E = x, S += 1 } } if (e.virtualSize = Math.max(e.virtualSize, o) + g, a && r && ("slide" === s.effect || "coverflow" === s.effect) && n.css({ width: `${e.virtualSize + s.spaceBetween}px` }), s.setWrapperSize && n.css({ [t("width")]: `${e.virtualSize + s.spaceBetween}px` }), C && e.grid.updateWrapperSize(x, h, t), !s.centeredSlides) { const t = []; for (let i = 0; i < h.length; i += 1) { let n = h[i]; s.roundLengths && (n = Math.floor(n)), h[i] <= e.virtualSize - o && t.push(n) } h = t, Math.floor(e.virtualSize - o) - Math.floor(h[h.length - 1]) > 1 && h.push(e.virtualSize - o) } if (0 === h.length && (h = [0]), 0 !== s.spaceBetween) { const i = e.isHorizontal() && a ? "marginLeft" : t("marginRight"); u.filter(((e, t) => !s.cssMode || t !== u.length - 1)).css({ [i]: `${y}px` }) } if (s.centeredSlides && s.centeredSlidesBounds) { let e = 0; f.forEach((t => { e += t + (s.spaceBetween ? s.spaceBetween : 0) })), e -= s.spaceBetween; const t = e - o; h = h.map((e => e < 0 ? -m : e > t ? t + g : e)) } if (s.centerInsufficientSlides) { let e = 0; if (f.forEach((t => { e += t + (s.spaceBetween ? s.spaceBetween : 0) })), e -= s.spaceBetween, e < o) { const t = (o - e) / 2; h.forEach(((e, i) => { h[i] = e - t })), p.forEach(((e, i) => { p[i] = e + t })) } } if (Object.assign(e, { slides: u, snapGrid: h, slidesGrid: p, slidesSizesGrid: f }), s.centeredSlides && s.cssMode && !s.centeredSlidesBounds) { zt(e.wrapperEl, "--swiper-centered-offset-before", -h[0] + "px"), zt(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px"); const t = -e.snapGrid[0], i = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + i)) } if (d !== c && e.emit("slidesLengthChange"), h.length !== v && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), p.length !== b && e.emit("slidesGridLengthChange"), s.watchSlidesProgress && e.updateSlidesOffset(), !(l || s.cssMode || "slide" !== s.effect && "fade" !== s.effect)) { const t = `${s.containerModifierClass}backface-hidden`, i = e.$el.hasClass(t); d <= s.maxBackfaceHiddenSlides ? i || e.$el.addClass(t) : i && e.$el.removeClass(t) } }, updateAutoHeight: function (e) { const t = this, i = [], s = t.virtual && t.params.virtual.enabled; let n, o = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const a = e => s ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || Lt([])).each((e => { i.push(e) })); else for (n = 0; n < Math.ceil(t.params.slidesPerView); n += 1) { const e = t.activeIndex + n; if (e > t.slides.length && !s) break; i.push(a(e)) } else i.push(a(t.activeIndex)); for (n = 0; n < i.length; n += 1)if (void 0 !== i[n]) { const e = i[n].offsetHeight; o = e > o ? e : o } (o || 0 === o) && t.$wrapperEl.css("height", `${o}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides; for (let i = 0; i < t.length; i += 1)t[i].swiperSlideOffset = e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop }, updateSlidesProgress: function (e = this && this.translate || 0) { const t = this, i = t.params, { slides: s, rtlTranslate: n, snapGrid: o } = t; if (0 === s.length) return; void 0 === s[0].swiperSlideOffset && t.updateSlidesOffset(); let a = -e; n && (a = e), s.removeClass(i.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let e = 0; e < s.length; e += 1) { const r = s[e]; let l = r.swiperSlideOffset; i.cssMode && i.centeredSlides && (l -= s[0].swiperSlideOffset); const c = (a + (i.centeredSlides ? t.minTranslate() : 0) - l) / (r.swiperSlideSize + i.spaceBetween), u = (a - o[0] + (i.centeredSlides ? t.minTranslate() : 0) - l) / (r.swiperSlideSize + i.spaceBetween), d = -(a - l), h = d + t.slidesSizesGrid[e]; (d >= 0 && d < t.size - 1 || h > 1 && h <= t.size || d <= 0 && h >= t.size) && (t.visibleSlides.push(r), t.visibleSlidesIndexes.push(e), s.eq(e).addClass(i.slideVisibleClass)), r.progress = n ? -c : c, r.originalProgress = n ? -u : u } t.visibleSlides = Lt(t.visibleSlides) }, updateProgress: function (e) { const t = this; if (void 0 === e) { const i = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * i || 0 } const i = t.params, s = t.maxTranslate() - t.minTranslate(); let { progress: n, isBeginning: o, isEnd: a } = t; const r = o, l = a; 0 === s ? (n = 0, o = !0, a = !0) : (n = (e - t.minTranslate()) / s, o = n <= 0, a = n >= 1), Object.assign(t, { progress: n, isBeginning: o, isEnd: a }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), o && !r && t.emit("reachBeginning toEdge"), a && !l && t.emit("reachEnd toEdge"), (r && !o || l && !a) && t.emit("fromEdge"), t.emit("progress", n) }, updateSlidesClasses: function () { const e = this, { slides: t, params: i, $wrapperEl: s, activeIndex: n, realIndex: o } = e, a = e.virtual && i.virtual.enabled; let r; t.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), r = a ? e.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${n}"]`) : t.eq(n), r.addClass(i.slideActiveClass), i.loop && (r.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${o}"]`).addClass(i.slideDuplicateActiveClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${o}"]`).addClass(i.slideDuplicateActiveClass)); let l = r.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass); i.loop && 0 === l.length && (l = t.eq(0), l.addClass(i.slideNextClass)); let c = r.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass); i.loop && 0 === c.length && (c = t.eq(-1), c.addClass(i.slidePrevClass)), i.loop && (l.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass), c.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass)), e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, i = t.rtlTranslate ? t.translate : -t.translate, { slidesGrid: s, snapGrid: n, params: o, activeIndex: a, realIndex: r, snapIndex: l } = t; let c, u = e; if (void 0 === u) { for (let e = 0; e < s.length; e += 1)void 0 !== s[e + 1] ? i >= s[e] && i < s[e + 1] - (s[e + 1] - s[e]) / 2 ? u = e : i >= s[e] && i < s[e + 1] && (u = e + 1) : i >= s[e] && (u = e); o.normalizeSlideIndex && (u < 0 || void 0 === u) && (u = 0) } if (n.indexOf(i) >= 0) c = n.indexOf(i); else { const e = Math.min(o.slidesPerGroupSkip, u); c = e + Math.floor((u - e) / o.slidesPerGroup) } if (c >= n.length && (c = n.length - 1), u === a) return void (c !== l && (t.snapIndex = c, t.emit("snapIndexChange"))); const d = parseInt(t.slides.eq(u).attr("data-swiper-slide-index") || u, 10); Object.assign(t, { snapIndex: c, realIndex: d, previousIndex: a, activeIndex: u }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), r !== d && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, i = t.params, s = Lt(e).closest(`.${i.slideClass}`)[0]; let n, o = !1; if (s) for (let e = 0; e < t.slides.length; e += 1)if (t.slides[e] === s) { o = !0, n = e; break } if (!s || !o) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = s, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(Lt(s).attr("data-swiper-slide-index"), 10) : t.clickedIndex = n, i.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }, Wt = { getTranslate: function (e = (this.isHorizontal() ? "x" : "y")) { const { params: t, rtlTranslate: i, translate: s, $wrapperEl: n } = this; if (t.virtualTranslate) return i ? -s : s; if (t.cssMode) return s; let o = function (e, t = "x") { const i = xt(); let s, n, o; const a = function (e) { const t = xt(); let i; return t.getComputedStyle && (i = t.getComputedStyle(e, null)), !i && e.currentStyle && (i = e.currentStyle), i || (i = e.style), i }(e); return i.WebKitCSSMatrix ? (n = a.transform || a.webkitTransform, n.split(",").length > 6 && (n = n.split(", ").map((e => e.replace(",", "."))).join(", ")), o = new i.WebKitCSSMatrix("none" === n ? "" : n)) : (o = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), s = o.toString().split(",")), "x" === t && (n = i.WebKitCSSMatrix ? o.m41 : 16 === s.length ? parseFloat(s[12]) : parseFloat(s[4])), "y" === t && (n = i.WebKitCSSMatrix ? o.m42 : 16 === s.length ? parseFloat(s[13]) : parseFloat(s[5])), n || 0 }(n[0], e); return i && (o = -o), o || 0 }, setTranslate: function (e, t) { const i = this, { rtlTranslate: s, params: n, $wrapperEl: o, wrapperEl: a, progress: r } = i; let l, c = 0, u = 0; i.isHorizontal() ? c = s ? -e : e : u = e, n.roundLengths && (c = Math.floor(c), u = Math.floor(u)), n.cssMode ? a[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -c : -u : n.virtualTranslate || o.transform(`translate3d(${c}px, ${u}px, 0px)`), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? c : u; const d = i.maxTranslate() - i.minTranslate(); l = 0 === d ? 0 : (e - i.minTranslate()) / d, l !== r && i.updateProgress(e), i.emit("setTranslate", i.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e = 0, t = this.params.speed, i = !0, s = !0, n) { const o = this, { params: a, wrapperEl: r } = o; if (o.animating && a.preventInteractionOnTransition) return !1; const l = o.minTranslate(), c = o.maxTranslate(); let u; if (u = s && e > l ? l : s && e < c ? c : e, o.updateProgress(u), a.cssMode) { const e = o.isHorizontal(); if (0 === t) r[e ? "scrollLeft" : "scrollTop"] = -u; else { if (!o.support.smoothScroll) return Rt({ swiper: o, targetPosition: -u, side: e ? "left" : "top" }), !0; r.scrollTo({ [e ? "left" : "top"]: -u, behavior: "smooth" }) } return !0 } return 0 === t ? (o.setTransition(0), o.setTranslate(u), i && (o.emit("beforeTransitionStart", t, n), o.emit("transitionEnd"))) : (o.setTransition(t), o.setTranslate(u), i && (o.emit("beforeTransitionStart", t, n), o.emit("transitionStart")), o.animating || (o.animating = !0, o.onTranslateToWrapperTransitionEnd || (o.onTranslateToWrapperTransitionEnd = function (e) { o && !o.destroyed && e.target === this && (o.$wrapperEl[0].removeEventListener("transitionend", o.onTranslateToWrapperTransitionEnd), o.$wrapperEl[0].removeEventListener("webkitTransitionEnd", o.onTranslateToWrapperTransitionEnd), o.onTranslateToWrapperTransitionEnd = null, delete o.onTranslateToWrapperTransitionEnd, i && o.emit("transitionEnd")) }), o.$wrapperEl[0].addEventListener("transitionend", o.onTranslateToWrapperTransitionEnd), o.$wrapperEl[0].addEventListener("webkitTransitionEnd", o.onTranslateToWrapperTransitionEnd))), !0 } }; function Gt({ swiper: e, runCallbacks: t, direction: i, step: s }) { const { activeIndex: n, previousIndex: o } = e; let a = i; if (a || (a = n > o ? "next" : n < o ? "prev" : "reset"), e.emit(`transition${s}`), t && n !== o) { if ("reset" === a) return void e.emit(`slideResetTransition${s}`); e.emit(`slideChangeTransition${s}`), "next" === a ? e.emit(`slideNextTransition${s}`) : e.emit(`slidePrevTransition${s}`) } } const Xt = { slideTo: function (e = 0, t = this.params.speed, i = !0, s, n) { if ("number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`); if ("string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = t } const o = this; let a = e; a < 0 && (a = 0); const { params: r, snapGrid: l, slidesGrid: c, previousIndex: u, activeIndex: d, rtlTranslate: h, wrapperEl: p, enabled: f } = o; if (o.animating && r.preventInteractionOnTransition || !f && !s && !n) return !1; const m = Math.min(o.params.slidesPerGroupSkip, a); let g = m + Math.floor((a - m) / o.params.slidesPerGroup); g >= l.length && (g = l.length - 1); const v = -l[g]; if (r.normalizeSlideIndex) for (let e = 0; e < c.length; e += 1) { const t = -Math.floor(100 * v), i = Math.floor(100 * c[e]), s = Math.floor(100 * c[e + 1]); void 0 !== c[e + 1] ? t >= i && t < s - (s - i) / 2 ? a = e : t >= i && t < s && (a = e + 1) : t >= i && (a = e) } if (o.initialized && a !== d) { if (!o.allowSlideNext && v < o.translate && v < o.minTranslate()) return !1; if (!o.allowSlidePrev && v > o.translate && v > o.maxTranslate() && (d || 0) !== a) return !1 } let b; if (a !== (u || 0) && i && o.emit("beforeSlideChangeStart"), o.updateProgress(v), b = a > d ? "next" : a < d ? "prev" : "reset", h && -v === o.translate || !h && v === o.translate) return o.updateActiveIndex(a), r.autoHeight && o.updateAutoHeight(), o.updateSlidesClasses(), "slide" !== r.effect && o.setTranslate(v), "reset" !== b && (o.transitionStart(i, b), o.transitionEnd(i, b)), !1; if (r.cssMode) { const e = o.isHorizontal(), i = h ? v : -v; if (0 === t) { const t = o.virtual && o.params.virtual.enabled; t && (o.wrapperEl.style.scrollSnapType = "none", o._immediateVirtual = !0), p[e ? "scrollLeft" : "scrollTop"] = i, t && requestAnimationFrame((() => { o.wrapperEl.style.scrollSnapType = "", o._swiperImmediateVirtual = !1 })) } else { if (!o.support.smoothScroll) return Rt({ swiper: o, targetPosition: i, side: e ? "left" : "top" }), !0; p.scrollTo({ [e ? "left" : "top"]: i, behavior: "smooth" }) } return !0 } return o.setTransition(t), o.setTranslate(v), o.updateActiveIndex(a), o.updateSlidesClasses(), o.emit("beforeTransitionStart", t, s), o.transitionStart(i, b), 0 === t ? o.transitionEnd(i, b) : o.animating || (o.animating = !0, o.onSlideToWrapperTransitionEnd || (o.onSlideToWrapperTransitionEnd = function (e) { o && !o.destroyed && e.target === this && (o.$wrapperEl[0].removeEventListener("transitionend", o.onSlideToWrapperTransitionEnd), o.$wrapperEl[0].removeEventListener("webkitTransitionEnd", o.onSlideToWrapperTransitionEnd), o.onSlideToWrapperTransitionEnd = null, delete o.onSlideToWrapperTransitionEnd, o.transitionEnd(i, b)) }), o.$wrapperEl[0].addEventListener("transitionend", o.onSlideToWrapperTransitionEnd), o.$wrapperEl[0].addEventListener("webkitTransitionEnd", o.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e = 0, t = this.params.speed, i = !0, s) { if ("string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = t } const n = this; let o = e; return n.params.loop && (o += n.loopedSlides), n.slideTo(o, t, i, s) }, slideNext: function (e = this.params.speed, t = !0, i) { const s = this, { animating: n, enabled: o, params: a } = s; if (!o) return s; let r = a.slidesPerGroup; "auto" === a.slidesPerView && 1 === a.slidesPerGroup && a.slidesPerGroupAuto && (r = Math.max(s.slidesPerViewDynamic("current", !0), 1)); const l = s.activeIndex < a.slidesPerGroupSkip ? 1 : r; if (a.loop) { if (n && a.loopPreventsSlide) return !1; s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft } return a.rewind && s.isEnd ? s.slideTo(0, e, t, i) : s.slideTo(s.activeIndex + l, e, t, i) }, slidePrev: function (e = this.params.speed, t = !0, i) { const s = this, { params: n, animating: o, snapGrid: a, slidesGrid: r, rtlTranslate: l, enabled: c } = s; if (!c) return s; if (n.loop) { if (o && n.loopPreventsSlide) return !1; s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft } function u(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const d = u(l ? s.translate : -s.translate), h = a.map((e => u(e))); let p = a[h.indexOf(d) - 1]; if (void 0 === p && n.cssMode) { let e; a.forEach(((t, i) => { d >= t && (e = i) })), void 0 !== e && (p = a[e > 0 ? e - 1 : e]) } let f = 0; if (void 0 !== p && (f = r.indexOf(p), f < 0 && (f = s.activeIndex - 1), "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (f = f - s.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), n.rewind && s.isBeginning) { const n = s.params.virtual && s.params.virtual.enabled && s.virtual ? s.virtual.slides.length - 1 : s.slides.length - 1; return s.slideTo(n, e, t, i) } return s.slideTo(f, e, t, i) }, slideReset: function (e = this.params.speed, t = !0, i) { return this.slideTo(this.activeIndex, e, t, i) }, slideToClosest: function (e = this.params.speed, t = !0, i, s = .5) { const n = this; let o = n.activeIndex; const a = Math.min(n.params.slidesPerGroupSkip, o), r = a + Math.floor((o - a) / n.params.slidesPerGroup), l = n.rtlTranslate ? n.translate : -n.translate; if (l >= n.snapGrid[r]) { const e = n.snapGrid[r]; l - e > (n.snapGrid[r + 1] - e) * s && (o += n.params.slidesPerGroup) } else { const e = n.snapGrid[r - 1]; l - e <= (n.snapGrid[r] - e) * s && (o -= n.params.slidesPerGroup) } return o = Math.max(o, 0), o = Math.min(o, n.slidesGrid.length - 1), n.slideTo(o, e, t, i) }, slideToClickedSlide: function () { const e = this, { params: t, $wrapperEl: i } = e, s = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let n, o = e.clickedIndex; if (t.loop) { if (e.animating) return; n = parseInt(Lt(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? o < e.loopedSlides - s / 2 || o > e.slides.length - e.loopedSlides + s / 2 ? (e.loopFix(), o = i.children(`.${t.slideClass}[data-swiper-slide-index="${n}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), Dt((() => { e.slideTo(o) }))) : e.slideTo(o) : o > e.slides.length - s ? (e.loopFix(), o = i.children(`.${t.slideClass}[data-swiper-slide-index="${n}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), Dt((() => { e.slideTo(o) }))) : e.slideTo(o) } else e.slideTo(o) } }, Yt = { loopCreate: function () { const e = this, t = St(), { params: i, $wrapperEl: s } = e, n = s.children().length > 0 ? Lt(s.children()[0].parentNode) : s; n.children(`.${i.slideClass}.${i.slideDuplicateClass}`).remove(); let o = n.children(`.${i.slideClass}`); if (i.loopFillGroupWithBlank) { const e = i.slidesPerGroup - o.length % i.slidesPerGroup; if (e !== i.slidesPerGroup) { for (let s = 0; s < e; s += 1) { const e = Lt(t.createElement("div")).addClass(`${i.slideClass} ${i.slideBlankClass}`); n.append(e) } o = n.children(`.${i.slideClass}`) } } "auto" !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = o.length), e.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10)), e.loopedSlides += i.loopAdditionalSlides, e.loopedSlides > o.length && e.params.loopedSlidesLimit && (e.loopedSlides = o.length); const a = [], r = []; o.each(((e, t) => { Lt(e).attr("data-swiper-slide-index", t) })); for (let t = 0; t < e.loopedSlides; t += 1) { const e = t - Math.floor(t / o.length) * o.length; r.push(o.eq(e)[0]), a.unshift(o.eq(o.length - e - 1)[0]) } for (let e = 0; e < r.length; e += 1)n.append(Lt(r[e].cloneNode(!0)).addClass(i.slideDuplicateClass)); for (let e = a.length - 1; e >= 0; e -= 1)n.prepend(Lt(a[e].cloneNode(!0)).addClass(i.slideDuplicateClass)) }, loopFix: function () { const e = this; e.emit("beforeLoopFix"); const { activeIndex: t, slides: i, loopedSlides: s, allowSlidePrev: n, allowSlideNext: o, snapGrid: a, rtlTranslate: r } = e; let l; e.allowSlidePrev = !0, e.allowSlideNext = !0; const c = -a[t] - e.getTranslate(); t < s ? (l = i.length - 3 * s + t, l += s, e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((r ? -e.translate : e.translate) - c)) : t >= i.length - s && (l = -i.length + t + s, l += s, e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((r ? -e.translate : e.translate) - c)), e.allowSlidePrev = n, e.allowSlideNext = o, e.emit("loopFix") }, loopDestroy: function () { const { $wrapperEl: e, params: t, slides: i } = this; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index") } }; function Ut(e) { const t = this, i = St(), s = xt(), n = t.touchEventsData, { params: o, touches: a, enabled: r } = t; if (!r) return; if (t.animating && o.preventInteractionOnTransition) return; !t.animating && o.cssMode && o.loop && t.loopFix(); let l = e; l.originalEvent && (l = l.originalEvent); let c = Lt(l.target); if ("wrapper" === o.touchEventsTarget && !c.closest(t.wrapperEl).length) return; if (n.isTouchEvent = "touchstart" === l.type, !n.isTouchEvent && "which" in l && 3 === l.which) return; if (!n.isTouchEvent && "button" in l && l.button > 0) return; if (n.isTouched && n.isMoved) return; const u = !!o.noSwipingClass && "" !== o.noSwipingClass, d = e.composedPath ? e.composedPath() : e.path; u && l.target && l.target.shadowRoot && d && (c = Lt(d[0])); const h = o.noSwipingSelector ? o.noSwipingSelector : `.${o.noSwipingClass}`, p = !(!l.target || !l.target.shadowRoot); if (o.noSwiping && (p ? function (e, t = this) { return function t(i) { if (!i || i === St() || i === xt()) return null; i.assignedSlot && (i = i.assignedSlot); const s = i.closest(e); return s || i.getRootNode ? s || t(i.getRootNode().host) : null }(t) }(h, c[0]) : c.closest(h)[0])) return void (t.allowClick = !0); if (o.swipeHandler && !c.closest(o.swipeHandler)[0]) return; a.currentX = "touchstart" === l.type ? l.targetTouches[0].pageX : l.pageX, a.currentY = "touchstart" === l.type ? l.targetTouches[0].pageY : l.pageY; const f = a.currentX, m = a.currentY, g = o.edgeSwipeDetection || o.iOSEdgeSwipeDetection, v = o.edgeSwipeThreshold || o.iOSEdgeSwipeThreshold; if (g && (f <= v || f >= s.innerWidth - v)) { if ("prevent" !== g) return; e.preventDefault() } if (Object.assign(n, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), a.startX = f, a.startY = m, n.touchStartTime = Ft(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, o.threshold > 0 && (n.allowThresholdMove = !1), "touchstart" !== l.type) { let e = !0; c.is(n.focusableElements) && (e = !1, "SELECT" === c[0].nodeName && (n.isTouched = !1)), i.activeElement && Lt(i.activeElement).is(n.focusableElements) && i.activeElement !== c[0] && i.activeElement.blur(); const s = e && t.allowTouchMove && o.touchStartPreventDefault; !o.touchStartForcePreventDefault && !s || c[0].isContentEditable || l.preventDefault() } t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !o.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", l) } function Zt(e) { const t = St(), i = this, s = i.touchEventsData, { params: n, touches: o, rtlTranslate: a, enabled: r } = i; if (!r) return; let l = e; if (l.originalEvent && (l = l.originalEvent), !s.isTouched) return void (s.startMoving && s.isScrolling && i.emit("touchMoveOpposite", l)); if (s.isTouchEvent && "touchmove" !== l.type) return; const c = "touchmove" === l.type && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0]), u = "touchmove" === l.type ? c.pageX : l.pageX, d = "touchmove" === l.type ? c.pageY : l.pageY; if (l.preventedByNestedSwiper) return o.startX = u, void (o.startY = d); if (!i.allowTouchMove) return Lt(l.target).is(s.focusableElements) || (i.allowClick = !1), void (s.isTouched && (Object.assign(o, { startX: u, startY: d, currentX: u, currentY: d }), s.touchStartTime = Ft())); if (s.isTouchEvent && n.touchReleaseOnEdges && !n.loop) if (i.isVertical()) { if (d < o.startY && i.translate <= i.maxTranslate() || d > o.startY && i.translate >= i.minTranslate()) return s.isTouched = !1, void (s.isMoved = !1) } else if (u < o.startX && i.translate <= i.maxTranslate() || u > o.startX && i.translate >= i.minTranslate()) return; if (s.isTouchEvent && t.activeElement && l.target === t.activeElement && Lt(l.target).is(s.focusableElements)) return s.isMoved = !0, void (i.allowClick = !1); if (s.allowTouchCallbacks && i.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return; o.currentX = u, o.currentY = d; const h = o.currentX - o.startX, p = o.currentY - o.startY; if (i.params.threshold && Math.sqrt(h ** 2 + p ** 2) < i.params.threshold) return; if (void 0 === s.isScrolling) { let e; i.isHorizontal() && o.currentY === o.startY || i.isVertical() && o.currentX === o.startX ? s.isScrolling = !1 : h * h + p * p >= 25 && (e = 180 * Math.atan2(Math.abs(p), Math.abs(h)) / Math.PI, s.isScrolling = i.isHorizontal() ? e > n.touchAngle : 90 - e > n.touchAngle) } if (s.isScrolling && i.emit("touchMoveOpposite", l), void 0 === s.startMoving && (o.currentX === o.startX && o.currentY === o.startY || (s.startMoving = !0)), s.isScrolling) return void (s.isTouched = !1); if (!s.startMoving) return; i.allowClick = !1, !n.cssMode && l.cancelable && l.preventDefault(), n.touchMoveStopPropagation && !n.nested && l.stopPropagation(), s.isMoved || (n.loop && !n.cssMode && i.loopFix(), s.startTranslate = i.getTranslate(), i.setTransition(0), i.animating && i.$wrapperEl.trigger("webkitTransitionEnd transitionend"), s.allowMomentumBounce = !1, !n.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", l)), i.emit("sliderMove", l), s.isMoved = !0; let f = i.isHorizontal() ? h : p; o.diff = f, f *= n.touchRatio, a && (f = -f), i.swipeDirection = f > 0 ? "prev" : "next", s.currentTranslate = f + s.startTranslate; let m = !0, g = n.resistanceRatio; if (n.touchReleaseOnEdges && (g = 0), f > 0 && s.currentTranslate > i.minTranslate() ? (m = !1, n.resistance && (s.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + s.startTranslate + f) ** g)) : f < 0 && s.currentTranslate < i.maxTranslate() && (m = !1, n.resistance && (s.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - s.startTranslate - f) ** g)), m && (l.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && s.currentTranslate < s.startTranslate && (s.currentTranslate = s.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && s.currentTranslate > s.startTranslate && (s.currentTranslate = s.startTranslate), i.allowSlidePrev || i.allowSlideNext || (s.currentTranslate = s.startTranslate), n.threshold > 0) { if (!(Math.abs(f) > n.threshold || s.allowThresholdMove)) return void (s.currentTranslate = s.startTranslate); if (!s.allowThresholdMove) return s.allowThresholdMove = !0, o.startX = o.currentX, o.startY = o.currentY, s.currentTranslate = s.startTranslate, void (o.diff = i.isHorizontal() ? o.currentX - o.startX : o.currentY - o.startY) } n.followFinger && !n.cssMode && ((n.freeMode && n.freeMode.enabled && i.freeMode || n.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), i.params.freeMode && n.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(s.currentTranslate), i.setTranslate(s.currentTranslate)) } function Kt(e) { const t = this, i = t.touchEventsData, { params: s, touches: n, rtlTranslate: o, slidesGrid: a, enabled: r } = t; if (!r) return; let l = e; if (l.originalEvent && (l = l.originalEvent), i.allowTouchCallbacks && t.emit("touchEnd", l), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && s.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void (i.startMoving = !1); s.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const c = Ft(), u = c - i.touchStartTime; if (t.allowClick) { const e = l.path || l.composedPath && l.composedPath(); t.updateClickedSlide(e && e[0] || l.target), t.emit("tap click", l), u < 300 && c - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", l) } if (i.lastClickTime = Ft(), Dt((() => { t.destroyed || (t.allowClick = !0) })), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === n.diff || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void (i.startMoving = !1); let d; if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, d = s.followFinger ? o ? t.translate : -t.translate : -i.currentTranslate, s.cssMode) return; if (t.params.freeMode && s.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: d }); let h = 0, p = t.slidesSizesGrid[0]; for (let e = 0; e < a.length; e += e < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) { const t = e < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; void 0 !== a[e + t] ? d >= a[e] && d < a[e + t] && (h = e, p = a[e + t] - a[e]) : d >= a[e] && (h = e, p = a[a.length - 1] - a[a.length - 2]) } let f = null, m = null; s.rewind && (t.isBeginning ? m = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (f = 0)); const g = (d - a[h]) / p, v = h < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; if (u > s.longSwipesMs) { if (!s.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (g >= s.longSwipesRatio ? t.slideTo(s.rewind && t.isEnd ? f : h + v) : t.slideTo(h)), "prev" === t.swipeDirection && (g > 1 - s.longSwipesRatio ? t.slideTo(h + v) : null !== m && g < 0 && Math.abs(g) > s.longSwipesRatio ? t.slideTo(m) : t.slideTo(h)) } else { if (!s.shortSwipes) return void t.slideTo(t.activeIndex); !t.navigation || l.target !== t.navigation.nextEl && l.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(null !== f ? f : h + v), "prev" === t.swipeDirection && t.slideTo(null !== m ? m : h)) : l.target === t.navigation.nextEl ? t.slideTo(h + v) : t.slideTo(h) } } function Jt() { const e = this, { params: t, el: i } = e; if (i && 0 === i.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: s, allowSlidePrev: n, snapGrid: o } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = n, e.allowSlideNext = s, e.params.watchOverflow && o !== e.snapGrid && e.checkOverflow() } function Qt(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function ei() { const e = this, { wrapperEl: t, rtlTranslate: i, enabled: s } = e; if (!s) return; let n; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const o = e.maxTranslate() - e.minTranslate(); n = 0 === o ? 0 : (e.translate - e.minTranslate()) / o, n !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let ti = !1; function ii() { } const si = (e, t) => { const i = St(), { params: s, touchEvents: n, el: o, wrapperEl: a, device: r, support: l } = e, c = !!s.nested, u = "on" === t ? "addEventListener" : "removeEventListener", d = t; if (l.touch) { const t = !("touchstart" !== n.start || !l.passiveListener || !s.passiveListeners) && { passive: !0, capture: !1 }; o[u](n.start, e.onTouchStart, t), o[u](n.move, e.onTouchMove, l.passiveListener ? { passive: !1, capture: c } : c), o[u](n.end, e.onTouchEnd, t), n.cancel && o[u](n.cancel, e.onTouchEnd, t) } else o[u](n.start, e.onTouchStart, !1), i[u](n.move, e.onTouchMove, c), i[u](n.end, e.onTouchEnd, !1); (s.preventClicks || s.preventClicksPropagation) && o[u]("click", e.onClick, !0), s.cssMode && a[u]("scroll", e.onScroll), s.updateOnWindowResize ? e[d](r.ios || r.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Jt, !0) : e[d]("observerUpdate", Jt, !0) }, ni = { attachEvents: function () { const e = this, t = St(), { params: i, support: s } = e; e.onTouchStart = Ut.bind(e), e.onTouchMove = Zt.bind(e), e.onTouchEnd = Kt.bind(e), i.cssMode && (e.onScroll = ei.bind(e)), e.onClick = Qt.bind(e), s.touch && !ti && (t.addEventListener("touchstart", ii), ti = !0), si(e, "on") }, detachEvents: function () { si(this, "off") } }, oi = (e, t) => e.grid && t.grid && t.grid.rows > 1, ai = { setBreakpoint: function () { const e = this, { activeIndex: t, initialized: i, loopedSlides: s = 0, params: n, $el: o } = e, a = n.breakpoints; if (!a || a && 0 === Object.keys(a).length) return; const r = e.getBreakpoint(a, e.params.breakpointsBase, e.el); if (!r || e.currentBreakpoint === r) return; const l = (r in a ? a[r] : void 0) || e.originalParams, c = oi(e, n), u = oi(e, l), d = n.enabled; c && !u ? (o.removeClass(`${n.containerModifierClass}grid ${n.containerModifierClass}grid-column`), e.emitContainerClasses()) : !c && u && (o.addClass(`${n.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === n.grid.fill) && o.addClass(`${n.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => { const i = n[t] && n[t].enabled, s = l[t] && l[t].enabled; i && !s && e[t].disable(), !i && s && e[t].enable() })); const h = l.direction && l.direction !== n.direction, p = n.loop && (l.slidesPerView !== n.slidesPerView || h); h && i && e.changeDirection(), Bt(e.params, l); const f = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), d && !f ? e.disable() : !d && f && e.enable(), e.currentBreakpoint = r, e.emit("_beforeBreakpoint", l), p && i && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - s + e.loopedSlides, 0, !1)), e.emit("breakpoint", l) }, getBreakpoint: function (e, t = "window", i) { if (!e || "container" === t && !i) return; let s = !1; const n = xt(), o = "window" === t ? n.innerHeight : i.clientHeight, a = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: o * t, point: e } } return { value: e, point: e } })); a.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < a.length; e += 1) { const { point: o, value: r } = a[e]; "window" === t ? n.matchMedia(`(min-width: ${r}px)`).matches && (s = o) : r <= i.clientWidth && (s = o) } return s || "max" } }, ri = { addClasses: function () { const e = this, { classNames: t, params: i, rtl: s, $el: n, device: o, support: a } = e, r = function (e, t) { const i = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((s => { e[s] && i.push(t + s) })) : "string" == typeof e && i.push(t + e) })), i }(["initialized", i.direction, { "pointer-events": !a.touch }, { "free-mode": e.params.freeMode && i.freeMode.enabled }, { autoheight: i.autoHeight }, { rtl: s }, { grid: i.grid && i.grid.rows > 1 }, { "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill }, { android: o.android }, { ios: o.ios }, { "css-mode": i.cssMode }, { centered: i.cssMode && i.centeredSlides }, { "watch-progress": i.watchSlidesProgress }], i.containerModifierClass); t.push(...r), n.addClass([...t].join(" ")), e.emitContainerClasses() }, removeClasses: function () { const { $el: e, classNames: t } = this; e.removeClass(t.join(" ")), this.emitContainerClasses() } }, li = { loadImage: function (e, t, i, s, n, o) { const a = xt(); let r; function l() { o && o() } Lt(e).parent("picture")[0] || e.complete && n ? l() : t ? (r = new a.Image, r.onload = l, r.onerror = l, s && (r.sizes = s), i && (r.srcset = i), t && (r.src = t)) : l() }, preloadImages: function () { const e = this; function t() { null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) } e.imagesToLoad = e.$el.find("img"); for (let i = 0; i < e.imagesToLoad.length; i += 1) { const s = e.imagesToLoad[i]; e.loadImage(s, s.currentSrc || s.getAttribute("src"), s.srcset || s.getAttribute("srcset"), s.sizes || s.getAttribute("sizes"), !0, t) } } }, ci = { init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopedSlidesLimit: !0, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1 }; function ui(e, t) { return function (i = {}) { const s = Object.keys(i)[0], n = i[s]; "object" == typeof n && null !== n ? (["navigation", "pagination", "scrollbar"].indexOf(s) >= 0 && !0 === e[s] && (e[s] = { auto: !0 }), s in e && "enabled" in n ? (!0 === e[s] && (e[s] = { enabled: !0 }), "object" != typeof e[s] || "enabled" in e[s] || (e[s].enabled = !0), e[s] || (e[s] = { enabled: !1 }), Bt(t, i)) : Bt(t, i)) : Bt(t, i) } } const di = { eventsEmitter: Ht, update: qt, translate: Wt, transition: { setTransition: function (e, t) { const i = this; i.params.cssMode || i.$wrapperEl.transition(e), i.emit("setTransition", e, t) }, transitionStart: function (e = !0, t) { const i = this, { params: s } = i; s.cssMode || (s.autoHeight && i.updateAutoHeight(), Gt({ swiper: i, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e = !0, t) { const i = this, { params: s } = i; i.animating = !1, s.cssMode || (i.setTransition(0), Gt({ swiper: i, runCallbacks: e, direction: t, step: "End" })) } }, slide: Xt, loop: Yt, grabCursor: { setGrabCursor: function (e) { const t = this; if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab" }, unsetGrabCursor: function () { const e = this; e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "") } }, events: ni, breakpoints: ai, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: i } = e, { slidesOffsetBefore: s } = i; if (s) { const t = e.slides.length - 1, i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * s; e.isLocked = e.size > i } else e.isLocked = 1 === e.snapGrid.length; !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: ri, images: li }, hi = {}; class pi { constructor(...e) { let t, i; if (1 === e.length && e[0].constructor && "Object" === Object.prototype.toString.call(e[0]).slice(8, -1) ? i = e[0] : [t, i] = e, i || (i = {}), i = Bt({}, i), t && !i.el && (i.el = t), i.el && Lt(i.el).length > 1) { const e = []; return Lt(i.el).each((t => { const s = Bt({}, i, { el: t }); e.push(new pi(s)) })), e } const s = this; s.__swiper__ = !0, s.support = Nt(), s.device = function (e = {}) { return Vt || (Vt = function ({ userAgent: e } = {}) { const t = Nt(), i = xt(), s = i.navigator.platform, n = e || i.navigator.userAgent, o = { ios: !1, android: !1 }, a = i.screen.width, r = i.screen.height, l = n.match(/(Android);?[\s\/]+([\d.]+)?/); let c = n.match(/(iPad).*OS\s([\d_]+)/); const u = n.match(/(iPod)(.*OS\s([\d_]+))?/), d = !c && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/), h = "Win32" === s; let p = "MacIntel" === s; return !c && p && t.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${a}x${r}`) >= 0 && (c = n.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), p = !1), l && !h && (o.os = "android", o.android = !0), (c || d || u) && (o.os = "ios", o.ios = !0), o }(e)), Vt }({ userAgent: i.userAgent }), s.browser = ($t || ($t = function () { const e = xt(); return { isSafari: function () { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), $t), s.eventsListeners = {}, s.eventsAnyListeners = [], s.modules = [...s.__modules__], i.modules && Array.isArray(i.modules) && s.modules.push(...i.modules); const n = {}; s.modules.forEach((e => { e({ swiper: s, extendParams: ui(i, n), on: s.on.bind(s), once: s.once.bind(s), off: s.off.bind(s), emit: s.emit.bind(s) }) })); const o = Bt({}, ci, n); return s.params = Bt({}, o, hi, i), s.originalParams = Bt({}, s.params), s.passedParams = Bt({}, i), s.params && s.params.on && Object.keys(s.params.on).forEach((e => { s.on(e, s.params.on[e]) })), s.params && s.params.onAny && s.onAny(s.params.onAny), s.$ = Lt, Object.assign(s, { enabled: s.params.enabled, el: t, classNames: [], slides: Lt(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === s.params.direction, isVertical: () => "vertical" === s.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: s.params.allowSlideNext, allowSlidePrev: s.params.allowSlidePrev, touchEvents: function () { const e = ["touchstart", "touchmove", "touchend", "touchcancel"], t = ["pointerdown", "pointermove", "pointerup"]; return s.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, s.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, s.support.touch || !s.params.simulateTouch ? s.touchEventsTouch : s.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: s.params.focusableElements, lastClickTime: Ft(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: s.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), s.emit("_swiper"), s.params.init && s.init(), s } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const i = this; e = Math.min(Math.max(e, 0), 1); const s = i.minTranslate(), n = (i.maxTranslate() - s) * e + s; i.translateTo(n, void 0 === t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.each((i => { const s = e.getSlideClasses(i); t.push({ slideEl: i, classNames: s }), e.emit("_slideClass", i, s) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e = "current", t = !1) { const { params: i, slides: s, slidesGrid: n, slidesSizesGrid: o, size: a, activeIndex: r } = this; let l = 1; if (i.centeredSlides) { let e, t = s[r].swiperSlideSize; for (let i = r + 1; i < s.length; i += 1)s[i] && !e && (t += s[i].swiperSlideSize, l += 1, t > a && (e = !0)); for (let i = r - 1; i >= 0; i -= 1)s[i] && !e && (t += s[i].swiperSlideSize, l += 1, t > a && (e = !0)) } else if ("current" === e) for (let e = r + 1; e < s.length; e += 1)(t ? n[e] + o[e] - n[r] < a : n[e] - n[r] < a) && (l += 1); else for (let e = r - 1; e >= 0; e -= 1)n[r] - n[e] < a && (l += 1); return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: i } = e; function s() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses() } let n; i.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (s(), e.params.autoHeight && e.updateAutoHeight()) : (n = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), n || s()), i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t = !0) { const i = this, s = i.params.direction; return e || (e = "horizontal" === s ? "vertical" : "horizontal"), e === s || "horizontal" !== e && "vertical" !== e || (i.$el.removeClass(`${i.params.containerModifierClass}${s}`).addClass(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.each((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), i.emit("changeDirection"), t && i.update()), i } changeLanguageDirection(e) { const t = this; t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; const i = Lt(e || t.params.el); if (!(e = i[0])) return !1; e.swiper = t; const s = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let n = (() => { if (e && e.shadowRoot && e.shadowRoot.querySelector) { const t = Lt(e.shadowRoot.querySelector(s())); return t.children = e => i.children(e), t } return i.children ? i.children(s()) : Lt(i).children(s()) })(); if (0 === n.length && t.params.createElements) { const e = St().createElement("div"); n = Lt(e), e.className = t.params.wrapperClass, i.append(e), i.children(`.${t.params.slideClass}`).each((e => { n.append(e) })) } return Object.assign(t, { $el: i, el: e, $wrapperEl: n, wrapperEl: n[0], mounted: !0, rtl: "rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction")), wrongRTL: "-webkit-box" === n.css("display") }), !0 } init(e) { const t = this; return t.initialized || !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t } destroy(e = !0, t = !0) { const i = this, { params: s, $el: n, $wrapperEl: o, slides: a } = i; return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), n.removeAttr("style"), o.removeAttr("style"), a && a.length && a.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((e => { i.off(e) })), !1 !== e && (i.$el[0].swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(i)), i.destroyed = !0), null } static extendDefaults(e) { Bt(hi, e) } static get extendedDefaults() { return hi } static get defaults() { return ci } static installModule(e) { pi.prototype.__modules__ || (pi.prototype.__modules__ = []); const t = pi.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => pi.installModule(e))), pi) : (pi.installModule(e), pi) } } Object.keys(di).forEach((e => { Object.keys(di[e]).forEach((t => { pi.prototype[t] = di[e][t] })) })), pi.use([function ({ swiper: e, on: t, emit: i }) { const s = xt(); let n = null, o = null; const a = () => { e && !e.destroyed && e.initialized && (i("beforeResize"), i("resize")) }, r = () => { e && !e.destroyed && e.initialized && i("orientationchange") }; t("init", (() => { e.params.resizeObserver && void 0 !== s.ResizeObserver ? e && !e.destroyed && e.initialized && (n = new ResizeObserver((t => { o = s.requestAnimationFrame((() => { const { width: i, height: s } = e; let n = i, o = s; t.forEach((({ contentBoxSize: t, contentRect: i, target: s }) => { s && s !== e.el || (n = i ? i.width : (t[0] || t).inlineSize, o = i ? i.height : (t[0] || t).blockSize) })), n === i && o === s || a() })) })), n.observe(e.el)) : (s.addEventListener("resize", a), s.addEventListener("orientationchange", r)) })), t("destroy", (() => { o && s.cancelAnimationFrame(o), n && n.unobserve && e.el && (n.unobserve(e.el), n = null), s.removeEventListener("resize", a), s.removeEventListener("orientationchange", r) })) }, function ({ swiper: e, extendParams: t, on: i, emit: s }) { const n = [], o = xt(), a = (e, t = {}) => { const i = new (o.MutationObserver || o.WebkitMutationObserver)((e => { if (1 === e.length) return void s("observerUpdate", e[0]); const t = function () { s("observerUpdate", e[0]) }; o.requestAnimationFrame ? o.requestAnimationFrame(t) : o.setTimeout(t, 0) })); i.observe(e, { attributes: void 0 === t.attributes || t.attributes, childList: void 0 === t.childList || t.childList, characterData: void 0 === t.characterData || t.characterData }), n.push(i) }; t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), i("init", (() => { if (e.params.observer) { if (e.params.observeParents) { const t = e.$el.parents(); for (let e = 0; e < t.length; e += 1)a(t[e]) } a(e.$el[0], { childList: e.params.observeSlideChildren }), a(e.$wrapperEl[0], { attributes: !1 }) } })), i("destroy", (() => { n.forEach((e => { e.disconnect() })), n.splice(0, n.length) })) }]); const fi = pi; function mi(e, t, i, s) { const n = St(); return e.params.createElements && Object.keys(s).forEach((o => { if (!i[o] && !0 === i.auto) { let a = e.$el.children(`.${s[o]}`)[0]; a || (a = n.createElement("div"), a.className = s[o], e.$el.append(a)), i[o] = a, t[o] = a } })), i } function gi({ swiper: e, extendParams: t, on: i, emit: s }) { function n(t) { let i; return t && (i = Lt(t), e.params.uniqueNavElements && "string" == typeof t && i.length > 1 && 1 === e.$el.find(t).length && (i = e.$el.find(t))), i } function o(t, i) { const s = e.params.navigation; t && t.length > 0 && (t[i ? "addClass" : "removeClass"](s.disabledClass), t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = i), e.params.watchOverflow && e.enabled && t[e.isLocked ? "addClass" : "removeClass"](s.lockClass)) } function a() { if (e.params.loop) return; const { $nextEl: t, $prevEl: i } = e.navigation; o(i, e.isBeginning && !e.params.rewind), o(t, e.isEnd && !e.params.rewind) } function r(t) { t.preventDefault(), (!e.isBeginning || e.params.loop || e.params.rewind) && (e.slidePrev(), s("navigationPrev")) } function l(t) { t.preventDefault(), (!e.isEnd || e.params.loop || e.params.rewind) && (e.slideNext(), s("navigationNext")) } function c() { const t = e.params.navigation; if (e.params.navigation = mi(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !t.nextEl && !t.prevEl) return; const i = n(t.nextEl), s = n(t.prevEl); i && i.length > 0 && i.on("click", l), s && s.length > 0 && s.on("click", r), Object.assign(e.navigation, { $nextEl: i, nextEl: i && i[0], $prevEl: s, prevEl: s && s[0] }), e.enabled || (i && i.addClass(t.lockClass), s && s.addClass(t.lockClass)) } function u() { const { $nextEl: t, $prevEl: i } = e.navigation; t && t.length && (t.off("click", l), t.removeClass(e.params.navigation.disabledClass)), i && i.length && (i.off("click", r), i.removeClass(e.params.navigation.disabledClass)) } t({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), e.navigation = { nextEl: null, $nextEl: null, prevEl: null, $prevEl: null }, i("init", (() => { !1 === e.params.navigation.enabled ? d() : (c(), a()) })), i("toEdge fromEdge lock unlock", (() => { a() })), i("destroy", (() => { u() })), i("enable disable", (() => { const { $nextEl: t, $prevEl: i } = e.navigation; t && t[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass), i && i[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass) })), i("click", ((t, i) => { const { $nextEl: n, $prevEl: o } = e.navigation, a = i.target; if (e.params.navigation.hideOnClick && !Lt(a).is(o) && !Lt(a).is(n)) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === a || e.pagination.el.contains(a))) return; let t; n ? t = n.hasClass(e.params.navigation.hiddenClass) : o && (t = o.hasClass(e.params.navigation.hiddenClass)), s(!0 === t ? "navigationShow" : "navigationHide"), n && n.toggleClass(e.params.navigation.hiddenClass), o && o.toggleClass(e.params.navigation.hiddenClass) } })); const d = () => { e.$el.addClass(e.params.navigation.navigationDisabledClass), u() }; Object.assign(e.navigation, { enable: () => { e.$el.removeClass(e.params.navigation.navigationDisabledClass), c(), a() }, disable: d, update: a, init: c, destroy: u }) } function vi(e = "") { return `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}` } let bi = new bootstrap.Offcanvas(document.getElementById("Offcanvas")); new e("#Offcanvas").onSwipeRight((() => { bi.hide() })); const yi = document.querySelectorAll(".input-phone"), wi = document.querySelectorAll(".input-text"), Ei = document.querySelectorAll(".input-date"); yi.length && yi.forEach((function (e) { var t; e.addEventListener("focus", (function () { t = p(e, { mask: "+{7} 000 000 00 00", lazy: !1, placeholderChar: "*" }) })), e.addEventListener("blur", (function () { t.updateOptions({ mask: "+{7} 000 000 00 00", lazy: !0 }) })) })), wi.length && wi.forEach((function (e) { p(e, { mask: /^[a-zа-яё\s]+$/iu }) })), Ei.length && Ei.forEach((function (e) { let t = e.dataset.mindate.split(","), i = e.dataset.maxdate.split(","); var s; e.addEventListener("focus", (function () { s = p(e, { mask: Date, min: new Date(t[0], t[1], t[2]), max: new Date(i[0], i[1], i[2]), lazy: !1 }) })), e.addEventListener("blur", (function () { s.updateOptions({ mask: Date, min: new Date(t[0], t[1], t[2]), max: new Date(i[0], i[1], i[2]), lazy: !0 }) })) })), vt.bind("[data-fancybox]", { Toolbar: { display: { left: ["infobar"], right: ["zoomIn", "thumbs", "close"] } }, l10n: { CLOSE: "Закрыть", NEXT: "Дальше", PREV: "Назад", MODAL: "Вы можете закрыть данное окно, нажав клавишу ESC", ERROR: "Что-то пошло не так. Пожалуйста, повторите попытку позже", IMAGE_ERROR: "Изображение не найдено", ELEMENT_NOT_FOUND: "HTML элемент не найден", AJAX_NOT_FOUND: "Ошибка загрузки AJAX : Не найдено", AJAX_FORBIDDEN: "Ошибка загрузки AJAX : Запрещено", IFRAME_ERROR: "Ошибка загрузки страницы", TOGGLE_ZOOM: "Переключить уровень масштаба", TOGGLE_THUMBS: "Переключить эскиз", TOGGLE_SLIDESHOW: "Переключить презентацию", TOGGLE_FULLSCREEN: "Переключить режим полного экрана", DOWNLOAD: "Скачать", ZOOMIN: "Увеличить", ZOOMOUT: "Уменьшить" } }); const Si = document.querySelectorAll(".search-form"); Si.length && Si.forEach((function (e) { const t = e.querySelector(".search-form-input"), i = new bt({ selector: () => t, placeHolder: "Найти...", data: { src: async () => { try { document.querySelector(".search-form-input").setAttribute("placeholder", "Loading..."); const e = await fetch("files/search-data.json"), t = await e.json(); return document.querySelector(".search-form-input").setAttribute("placeholder", i.placeHolder), t } catch (e) { return e } }, cache: !0 }, resultsList: { element: (e, t) => { if (!t.results.length) { const i = document.createElement("div"); i.setAttribute("class", "no_result"), i.innerHTML = `<span>Не найдено "${t.query}"</span>`, e.prepend(i) } }, noResults: !0, tabSelect: !0 }, resultItem: { highlight: !0 }, events: { input: { focus: () => { i.input.value.length && i.start() } } } }); i.input.addEventListener("selection", (function (e) { const t = e.detail; i.input.blur(); const s = t.selection.value; i.input.value = s })) })); const Ci = document.querySelector(".main-slider"); Ci && new fi(Ci.querySelector(".swiper"), { modules: [gi, function ({ swiper: e, extendParams: t, on: i, emit: s }) { const n = "swiper-pagination"; let o; t({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${n}-bullet`, bulletActiveClass: `${n}-bullet-active`, modifierClass: `${n}-`, currentClass: `${n}-current`, totalClass: `${n}-total`, hiddenClass: `${n}-hidden`, progressbarFillClass: `${n}-progressbar-fill`, progressbarOppositeClass: `${n}-progressbar-opposite`, clickableClass: `${n}-clickable`, lockClass: `${n}-lock`, horizontalClass: `${n}-horizontal`, verticalClass: `${n}-vertical`, paginationDisabledClass: `${n}-disabled` } }), e.pagination = { el: null, $el: null, bullets: [] }; let a = 0; function r() { return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length } function l(t, i) { const { bulletActiveClass: s } = e.params.pagination; t[i]().addClass(`${s}-${i}`)[i]().addClass(`${s}-${i}-${i}`) } function c() { const t = e.rtl, i = e.params.pagination; if (r()) return; const n = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, c = e.pagination.$el; let u; const d = e.params.loop ? Math.ceil((n - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (u = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), u > n - 1 - 2 * e.loopedSlides && (u -= n - 2 * e.loopedSlides), u > d - 1 && (u -= d), u < 0 && "bullets" !== e.params.paginationType && (u = d + u)) : u = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === i.type && e.pagination.bullets && e.pagination.bullets.length > 0) { const s = e.pagination.bullets; let n, r, d; if (i.dynamicBullets && (o = s.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), c.css(e.isHorizontal() ? "width" : "height", o * (i.dynamicMainBullets + 4) + "px"), i.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (a += u - (e.previousIndex - e.loopedSlides || 0), a > i.dynamicMainBullets - 1 ? a = i.dynamicMainBullets - 1 : a < 0 && (a = 0)), n = Math.max(u - a, 0), r = n + (Math.min(s.length, i.dynamicMainBullets) - 1), d = (r + n) / 2), s.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${i.bulletActiveClass}${e}`)).join(" ")), c.length > 1) s.each((e => { const t = Lt(e), s = t.index(); s === u && t.addClass(i.bulletActiveClass), i.dynamicBullets && (s >= n && s <= r && t.addClass(`${i.bulletActiveClass}-main`), s === n && l(t, "prev"), s === r && l(t, "next")) })); else { const t = s.eq(u), o = t.index(); if (t.addClass(i.bulletActiveClass), i.dynamicBullets) { const t = s.eq(n), a = s.eq(r); for (let e = n; e <= r; e += 1)s.eq(e).addClass(`${i.bulletActiveClass}-main`); if (e.params.loop) if (o >= s.length) { for (let e = i.dynamicMainBullets; e >= 0; e -= 1)s.eq(s.length - e).addClass(`${i.bulletActiveClass}-main`); s.eq(s.length - i.dynamicMainBullets - 1).addClass(`${i.bulletActiveClass}-prev`) } else l(t, "prev"), l(a, "next"); else l(t, "prev"), l(a, "next") } } if (i.dynamicBullets) { const n = Math.min(s.length, i.dynamicMainBullets + 4), a = (o * n - o) / 2 - d * o, r = t ? "right" : "left"; s.css(e.isHorizontal() ? r : "top", `${a}px`) } } if ("fraction" === i.type && (c.find(vi(i.currentClass)).text(i.formatFractionCurrent(u + 1)), c.find(vi(i.totalClass)).text(i.formatFractionTotal(d))), "progressbar" === i.type) { let t; t = i.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical"; const s = (u + 1) / d; let n = 1, o = 1; "horizontal" === t ? n = s : o = s, c.find(vi(i.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${n}) scaleY(${o})`).transition(e.params.speed) } "custom" === i.type && i.renderCustom ? (c.html(i.renderCustom(e, u + 1, d)), s("paginationRender", c[0])) : s("paginationUpdate", c[0]), e.params.watchOverflow && e.enabled && c[e.isLocked ? "addClass" : "removeClass"](i.lockClass) } function u() { const t = e.params.pagination; if (r()) return; const i = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, n = e.pagination.$el; let o = ""; if ("bullets" === t.type) { let s = e.params.loop ? Math.ceil((i - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && s > i && (s = i); for (let i = 0; i < s; i += 1)t.renderBullet ? o += t.renderBullet.call(e, i, t.bulletClass) : o += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`; n.html(o), e.pagination.bullets = n.find(vi(t.bulletClass)) } "fraction" === t.type && (o = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`, n.html(o)), "progressbar" === t.type && (o = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, n.html(o)), "custom" !== t.type && s("paginationRender", e.pagination.$el[0]) } function d() { e.params.pagination = mi(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const t = e.params.pagination; if (!t.el) return; let i = Lt(t.el); 0 !== i.length && (e.params.uniqueNavElements && "string" == typeof t.el && i.length > 1 && (i = e.$el.find(t.el), i.length > 1 && (i = i.filter((t => Lt(t).parents(".swiper")[0] === e.el)))), "bullets" === t.type && t.clickable && i.addClass(t.clickableClass), i.addClass(t.modifierClass + t.type), i.addClass(e.isHorizontal() ? t.horizontalClass : t.verticalClass), "bullets" === t.type && t.dynamicBullets && (i.addClass(`${t.modifierClass}${t.type}-dynamic`), a = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && i.addClass(t.progressbarOppositeClass), t.clickable && i.on("click", vi(t.bulletClass), (function (t) { t.preventDefault(); let i = Lt(this).index() * e.params.slidesPerGroup; e.params.loop && (i += e.loopedSlides), e.slideTo(i) })), Object.assign(e.pagination, { $el: i, el: i[0] }), e.enabled || i.addClass(t.lockClass)) } function h() { const t = e.params.pagination; if (r()) return; const i = e.pagination.$el; i.removeClass(t.hiddenClass), i.removeClass(t.modifierClass + t.type), i.removeClass(e.isHorizontal() ? t.horizontalClass : t.verticalClass), e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && i.off("click", vi(t.bulletClass)) } i("init", (() => { !1 === e.params.pagination.enabled ? p() : (d(), u(), c()) })), i("activeIndexChange", (() => { (e.params.loop || void 0 === e.snapIndex) && c() })), i("snapIndexChange", (() => { e.params.loop || c() })), i("slidesLengthChange", (() => { e.params.loop && (u(), c()) })), i("snapGridLengthChange", (() => { e.params.loop || (u(), c()) })), i("destroy", (() => { h() })), i("enable disable", (() => { const { $el: t } = e.pagination; t && t[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass) })), i("lock unlock", (() => { c() })), i("click", ((t, i) => { const n = i.target, { $el: o } = e.pagination; if (e.params.pagination.el && e.params.pagination.hideOnClick && o && o.length > 0 && !Lt(n).hasClass(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && n === e.navigation.nextEl || e.navigation.prevEl && n === e.navigation.prevEl)) return; const t = o.hasClass(e.params.pagination.hiddenClass); s(!0 === t ? "paginationShow" : "paginationHide"), o.toggleClass(e.params.pagination.hiddenClass) } })); const p = () => { e.$el.addClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.addClass(e.params.pagination.paginationDisabledClass), h() }; Object.assign(e.pagination, { enable: () => { e.$el.removeClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.removeClass(e.params.pagination.paginationDisabledClass), d(), u(), c() }, disable: p, render: u, update: c, init: d, destroy: h }) }, function ({ swiper: e, extendParams: t, on: i, emit: s }) { let n; function o() { if (!e.size) return e.autoplay.running = !1, void (e.autoplay.paused = !1); const t = e.slides.eq(e.activeIndex); let i = e.params.autoplay.delay; t.attr("data-swiper-autoplay") && (i = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(n), n = Dt((() => { let t; e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), t = e.slidePrev(e.params.speed, !0, !0), s("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? r() : (t = e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), s("autoplay")) : (t = e.slidePrev(e.params.speed, !0, !0), s("autoplay")) : e.params.loop ? (e.loopFix(), t = e.slideNext(e.params.speed, !0, !0), s("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? r() : (t = e.slideTo(0, e.params.speed, !0, !0), s("autoplay")) : (t = e.slideNext(e.params.speed, !0, !0), s("autoplay")), (e.params.cssMode && e.autoplay.running || !1 === t) && o() }), i) } function a() { return void 0 === n && !e.autoplay.running && (e.autoplay.running = !0, s("autoplayStart"), o(), !0) } function r() { return !!e.autoplay.running && void 0 !== n && (n && (clearTimeout(n), n = void 0), e.autoplay.running = !1, s("autoplayStop"), !0) } function l(t) { e.autoplay.running && (e.autoplay.paused || (n && clearTimeout(n), e.autoplay.paused = !0, 0 !== t && e.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].addEventListener(t, u) })) : (e.autoplay.paused = !1, o()))) } function c() { const t = St(); "hidden" === t.visibilityState && e.autoplay.running && l(), "visible" === t.visibilityState && e.autoplay.paused && (o(), e.autoplay.paused = !1) } function u(t) { e && !e.destroyed && e.$wrapperEl && t.target === e.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].removeEventListener(t, u) })), e.autoplay.paused = !1, e.autoplay.running ? o() : r()) } function d() { e.params.autoplay.disableOnInteraction ? r() : (s("autoplayPause"), l()), ["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].removeEventListener(t, u) })) } function h() { e.params.autoplay.disableOnInteraction || (e.autoplay.paused = !1, s("autoplayResume"), o()) } e.autoplay = { running: !1, paused: !1 }, t({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }), i("init", (() => { e.params.autoplay.enabled && (a(), St().addEventListener("visibilitychange", c), e.params.autoplay.pauseOnMouseEnter && (e.$el.on("mouseenter", d), e.$el.on("mouseleave", h))) })), i("beforeTransitionStart", ((t, i, s) => { e.autoplay.running && (s || !e.params.autoplay.disableOnInteraction ? e.autoplay.pause(i) : r()) })), i("sliderFirstMove", (() => { e.autoplay.running && (e.params.autoplay.disableOnInteraction ? r() : l()) })), i("touchEnd", (() => { e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && o() })), i("destroy", (() => { e.$el.off("mouseenter", d), e.$el.off("mouseleave", h), e.autoplay.running && r(), St().removeEventListener("visibilitychange", c) })), Object.assign(e.autoplay, { pause: l, run: o, start: a, stop: r }) }], slidesPerView: 1.03, spaceBetween: 16, observer: !0, autoHeight: !0, autoplay: { delay: 6e3, pauseOnMouseEnter: !0, disableOnInteraction: !1 }, navigation: { nextEl: ".sbn-1", prevEl: ".sbp-1" }, pagination: { el: ".swiper-pagination", clickable: !0, renderBullet: function (e, t) { return '<span class="' + t + '"></span>' } }, breakpoints: { 576: { slidesPerView: 1.001, spaceBetween: 16 }, 992: { slidesPerView: 1, spaceBetween: 0 } } }); const xi = document.querySelectorAll(".doctors-slider"); if (xi.length) for (const e of xi) new fi(e.querySelector(".swiper"), { modules: [gi], slidesPerView: 1.25, spaceBetween: 16, observer: !0, autoHeight: !0, navigation: { nextEl: e.querySelector(".sbn-2"), prevEl: e.querySelector(".sbp-2") }, breakpoints: { 576: { slidesPerView: 2.001, spaceBetween: 16 }, 768: { slidesPerView: 3.001, spaceBetween: 16 }, 992: { slidesPerView: 4, spaceBetween: 16 }, 1200: { slidesPerView: 5, spaceBetween: 16 }, 1400: { slidesPerView: 5, spaceBetween: 24 } } }); const ki = document.querySelectorAll(".rates-slider"); if (ki.length) for (const e of ki) new fi(e.querySelector(".swiper"), { modules: [gi], slidesPerView: 1.25, spaceBetween: 16, observer: !0, navigation: { nextEl: e.querySelector(".sbn-3"), prevEl: e.querySelector(".sbp-3") }, breakpoints: { 576: { slidesPerView: 1.75, spaceBetween: 16 }, 768: { slidesPerView: 2.25, spaceBetween: 16 }, 992: { slidesPerView: 3, spaceBetween: 20 }, 1200: { slidesPerView: 4, spaceBetween: 20 }, 1400: { slidesPerView: 4, spaceBetween: 24 } } }); const Ti = document.querySelectorAll(".cards-slider"); if (Ti.length) for (const e of Ti) new fi(e.querySelector(".swiper"), { modules: [gi], slidesPerView: 1.15, spaceBetween: 16, observer: !0, navigation: { nextEl: e.querySelector(".sbn-4"), prevEl: e.querySelector(".sbp-4") }, breakpoints: { 576: { slidesPerView: 1.75, spaceBetween: 16 }, 768: { slidesPerView: 2.25, spaceBetween: 16 }, 992: { slidesPerView: 3, spaceBetween: 16 }, 1200: { slidesPerView: 3, spaceBetween: 24 } } }); !function (e) { let t = new Image; t.onload = t.onerror = function () { !function (e) { let t = !0 === e ? "webp" : "no-webp"; document.documentElement.classList.add(t) }(2 == t.height) }, t.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA" }(), function () { function e(i) { 9 === i.keyCode && (document.body.classList.add("user-is-tabbing"), window.removeEventListener("keydown", e), window.addEventListener("mousedown", t)) } function t() { document.body.classList.remove("user-is-tabbing"), window.removeEventListener("mousedown", t), window.addEventListener("keydown", e) } window.addEventListener("keydown", e) }(), function () { const e = document.querySelector(".scroll-to-top"); document.addEventListener("scroll", (() => { window.scrollY > 400 ? e.style.visibility = "visible" : e.style.visibility = "hidden" })), e.addEventListener("click", (() => { window.scrollTo({ top: 0, behavior: "smooth" }) })) }(), function () { const e = document.querySelectorAll(".dropdown:not(.no-hover)"); e.length && e.forEach((function (e) { const t = new bootstrap.Dropdown(e.querySelector(".dropdown-toggle"), { offset: [0, 0] }); e.addEventListener("mouseover", (function (e) { t.show() })), e.addEventListener("mouseleave", (function (e) { t.hide() })) })) }(), function () { const e = document.querySelector(".search-toggle"), t = document.querySelector(".search"); e.onclick = function (e) { e.preventDefault(), t.classList.toggle("show") } }(), function () { const e = document.querySelector(".calc-btn"), t = document.querySelector(".calc__close"), i = document.querySelector(".calc"); e.onclick = function (e) { e.preventDefault(), i.classList.add("active") }, t.onclick = function (e) { e.preventDefault(), i.classList.remove("active") } }(), function () { const e = document.querySelectorAll(".sidebar .has-submenu .nav-link"); e.length && document.addEventListener("DOMContentLoaded", (function () { e.forEach((function (e) { e.addEventListener("click", (function (t) { e.classList.toggle("active"); let i = e.nextElementSibling; if (e.parentElement, i) { t.preventDefault(); let e = new bootstrap.Collapse(i); i.classList.contains("show") ? e.hide() : e.show() } })) })) })) }(), function () { const e = document.querySelector(".nav-mobile-scroll .nav-link.active"); e && document.addEventListener("DOMContentLoaded", (function () { let t = document.querySelector(".nav-mobile-scroll > *"), i = t.getBoundingClientRect(), s = e.getBoundingClientRect(); t.scrollLeft += s.left - i.left })) }(), function () { if (document.querySelector(".form-wizard")) { const e = document.querySelector(".form-wizard-prev"), t = document.querySelector(".form-wizard-next"), i = document.querySelector(".current-step"), s = document.querySelector(".total-steps"), n = document.querySelector(".form-wizard-submit"), o = document.querySelectorAll(".form-wizard-step"); let a = 0; function r() { a === o.length - 1 ? (t.classList.add("hidden"), e.classList.remove("hidden"), n.classList.remove("hidden")) : 0 == a ? (t.classList.remove("hidden"), e.classList.add("hidden"), n.classList.add("hidden")) : (t.classList.remove("hidden"), e.classList.remove("hidden"), n.classList.add("hidden")) } s.innerHTML = o.length, i.innerHTML = a + 1, t.addEventListener("click", (e => { e.preventDefault(), o[a].classList.add("hidden"), o[a + 1].classList.remove("hidden"), a += 1, i.innerHTML = a + 1, r() })), e.addEventListener("click", (e => { e.preventDefault(), o[a].classList.add("hidden"), o[a - 1].classList.remove("hidden"), a -= 1, i.innerHTML = a + 1, t.removeAttribute("disabled"), r() })) } }(), function () { if (document.querySelector(".filial-filter")) { const e = document.getElementById("appointmentFilialFilter1"), t = document.querySelectorAll(".form-check-input"), i = document.querySelector(".filial-filter-val"); e.addEventListener("change", (function () { this.checked && (t.forEach(((e, t) => { 0 !== t && (e.checked = !1) })), i.textContent = document.querySelector("label[for=appointmentFilialFilter1]").textContent) })), t.forEach(((s, n) => { s.addEventListener("change", (function () { 0 !== n && (e.checked = !1); const s = Array.from(t).filter(((e, t) => 0 !== t && e.checked)), o = s.length; i.textContent = 0 === o ? "Любой филиал" : `Выбрано филиалов: ${o}` })) })) } }(), document.addEventListener("DOMContentLoaded", (function () { const e = document.querySelectorAll(".accordion-title"); e.length && e.forEach((function (e) { e.addEventListener("click", (function (t) { let i = e.closest(".accordion"), s = i.querySelector(".accordion-body"); if (i.classList.toggle("active"), s) { t.preventDefault(); let e = new bootstrap.Collapse(s); s.classList.contains("show") ? e.hide() : e.show() } })) })) })), function () { const e = document.querySelectorAll(".appointment-filial"); e.length && e.forEach((function (e) { const t = e.querySelector(".appointment-filial-date"), i = e.querySelector(".appointment-filial-time"); i.style.display = "none", t.addEventListener("change", (function () { i.style.display = "block" })) })) }(), function () { const e = document.querySelectorAll(".hours"); e.length && e.forEach((function (e) { const t = e.querySelectorAll(".hour"), i = e.querySelector(".hour-more"), s = (e.querySelector(".hour-more-dots"), e.querySelector(".show-more-hours")); let n = !1; function o() { for (let e = 11; e < t.length; e++)t[e].style.display = "none" } s.addEventListener("click", (function () { n = !n, n ? (function () { for (let e = 11; e < t.length; e++)t[e].style.display = "block" }(), i.classList.add("show")) : (o(), i.classList.remove("show")) })), t.length > 11 ? (o(), i.style.display = "block") : i.style.display = "none" })) }() })() })();
//# sourceMappingURL=app.js.map